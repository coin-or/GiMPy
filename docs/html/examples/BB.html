<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.9.2" />
<title>coinor.gimpy.examples.BB API documentation</title>
<meta name="description" content="Original Authors : Murat H. Mut, Serdar Yildiz,
Lehigh University ISE Department 05/07/2010
Edited by Victor Pillac on Aug 5 2010
â€¦" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>coinor.gimpy.examples.BB</code></h1>
</header>
<section id="section-intro">
<p>Original Authors : Murat H. Mut, Serdar Yildiz,
Lehigh University ISE Department 05/07/2010
Edited by Victor Pillac on Aug 5 2010
Edited by Ted Ralphs September 15, 2011
Reimplemented Using GiMPy by Ted Ralphs February 1, 2013</p>
<p>This code solves an integer program by using an LP-based branch and bound
algorithm. The search strategy is controlled by the priority given to nodes in
the queue and there are two different rules available for solecting the
branching variable (most fractional and fixed). The complete_enumeration
variable can be used to turn off fathoming by bound.</p>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">&#39;&#39;&#39;
Original Authors : Murat H. Mut, Serdar Yildiz,
                   Lehigh University ISE Department 05/07/2010
Edited by Victor Pillac on Aug 5 2010
Edited by Ted Ralphs September 15, 2011
Reimplemented Using GiMPy by Ted Ralphs February 1, 2013

This code solves an integer program by using an LP-based branch and bound
algorithm. The search strategy is controlled by the priority given to nodes in
the queue and there are two different rules available for solecting the
branching variable (most fractional and fixed). The complete_enumeration
variable can be used to turn off fathoming by bound.

&#39;&#39;&#39;
from __future__ import print_function
from __future__ import absolute_import
from builtins import str
from builtins import range

from pulp import LpVariable, lpSum, LpProblem, LpMaximize, LpConstraint, LpStatus, value
import math
import time
from coinor.gimpy import BinaryTree, ETREE_INSTALLED, XDOT_INSTALLED, MATPLOTLIB_INSTALLED

try:
    from coinor.grumpy import BBTree
    grumpy_installed = True
except ImportError:
    grumpy_installed = False

from coinor.blimpy import PriorityQueue
from random import random, randint, seed

display_mode = &#39;xdot&#39;
layout = &#39;dot&#39;
display_interval = 100
if not grumpy_installed:
    layout = &#39;dot&#39;

if layout == &#39;bak&#39; and grumpy_installed:
    T = BBTree()
else:
    T = BinaryTree()
T.set_display_mode(display_mode)
T.set_layout(layout)

&#39;&#39;&#39;
#Add key
C = Cluster(graph_name = &#39;Key&#39;, label = &#39;Key&#39;, fontsize = &#39;12&#39;)
C.add_node(&#39;C&#39;, label = &#39;Candidate&#39;, style = &#39;filled&#39;, color = &#39;yellow&#39;, fillcolor = &#39;yellow&#39;)
C.add_node(&#39;I&#39;, label = &#39;Infeasible&#39;, style = &#39;filled&#39;, color = &#39;orange&#39;, fillcolor = &#39;orange&#39;)
C.add_node(&#39;S&#39;, label = &#39;Solution&#39;, style = &#39;filled&#39;, color = &#39;lightblue&#39;, fillcolor = &#39;lightblue&#39;)
C.add_node(&#39;P&#39;, label = &#39;Pruned&#39;, style = &#39;filled&#39;, color = &#39;red&#39;, fillcolor = &#39;red&#39;)
C.add_edge(&#39;C&#39;, &#39;I&#39;, style = &#39;invisible&#39;, arrowhead = &#39;none&#39;)
C.add_edge(&#39;I&#39;, &#39;S&#39;, style = &#39;invisible&#39;, arrowhead = &#39;none&#39;)
C.add_edge(&#39;S&#39;, &#39;P&#39;, style = &#39;invisible&#39;, arrowhead = &#39;none&#39;)
T.add_subgraph(C)
&#39;&#39;&#39;

T.add_node(&#39;C&#39;, label = &#39;Candidate&#39;, style = &#39;filled&#39;, color = &#39;yellow&#39;, fillcolor = &#39;yellow&#39;)
T.add_node(&#39;I&#39;, label = &#39;Infeasible&#39;, style = &#39;filled&#39;, color = &#39;orange&#39;, fillcolor = &#39;orange&#39;)
T.add_node(&#39;S&#39;, label = &#39;Solution&#39;, style = &#39;filled&#39;, color = &#39;lightblue&#39;, fillcolor = &#39;lightblue&#39;)
T.add_node(&#39;P&#39;, label = &#39;Pruned&#39;, style = &#39;filled&#39;, color = &#39;red&#39;, fillcolor = &#39;red&#39;)
T.add_edge(&#39;C&#39;, &#39;I&#39;, style = &#39;invisible&#39;, arrowhead = &#39;none&#39;)
T.add_edge(&#39;I&#39;, &#39;S&#39;, style = &#39;invisible&#39;, arrowhead = &#39;none&#39;)
T.add_edge(&#39;S&#39;, &#39;P&#39;, style = &#39;invisible&#39;, arrowhead = &#39;none&#39;)
cluster_attrs = {&#39;name&#39;:&#39;Key&#39;, &#39;label&#39;:&#39;Key&#39;, &#39;fontsize&#39;:&#39;12&#39;}
T.create_cluster([&#39;C&#39;, &#39;I&#39;, &#39;S&#39;, &#39;P&#39;], cluster_attrs)

import_instance = False
if import_instance:
    from .milp2 import CONSTRAINTS, VARIABLES, OBJ, MAT, RHS

    #the number of variables and constraints
    numVars = len(VARIABLES)
    numCons = len(CONSTRAINTS)
else:
    seed(2)
    numVars = 40
    numCons = 20
    density = 0.2
    maxObjCoeff = 10
    maxConsCoeff = 10
    CONSTRAINTS = [&#34;C&#34;+str(i) for i in range(numCons)]
    if layout == &#39;ladot&#39;:
        VARIABLES = [&#34;x_{&#34;+str(i)+&#34;}&#34; for i in range(numVars)]
    else:
        VARIABLES = [&#34;x&#34;+str(i) for i in range(numVars)]
    OBJ = {i : randint(1, maxObjCoeff) for i in VARIABLES}
    MAT = {i : [randint(1, maxConsCoeff) if random() &lt;= density else 0
                for j in CONSTRAINTS] for i in VARIABLES}
    RHS = [randint(int(numVars*density*maxConsCoeff/2), int(numVars*density*maxConsCoeff/1.5)) for i in CONSTRAINTS]

var   = LpVariable.dicts(&#34;&#34;, VARIABLES, 0, 1)

################################################################

#Branching strategies
MOST_FRAC = &#34;MOST FRACTIONAL&#34;
FIXED = &#34;FIXED&#34;

#search strategies
DEPTH_FIRST = &#34;Depth First&#34;
BEST_FIRST = &#34;Best First&#34;

#Selected branching strategy
branch_strategy = FIXED
search_strategy = BEST_FIRST

# 1 to force complete enumeration of nodes (no fathoming by bounding)
complete_enumeration = 0

# List shows if the corresponding variable is fixed to 0 or 1 or if it is not
# fixed when the corresponding value is 2.
# Initially each variable is assigned to be unfixed
INFINITY = 9999

#The initial lower bound
LB = -INFINITY

#The number of LP&#39;s solved, and the number of nodes solved
node_count = 1
iter_count = 0
lp_count = 0

#List of incumbent solution variable values
opt = dict([(i, 0) for i in VARIABLES])

print(&#34;===========================================&#34;)
print(&#34;Starting Branch and Bound&#34;)

if branch_strategy == MOST_FRAC:
    print(&#34;Most fractional variable&#34;)
elif branch_strategy == FIXED:
    print(&#34;Fixed order&#34;)
else:
    print(&#34;Unknown branching strategy %s&#34; %branch_strategy)

if search_strategy == DEPTH_FIRST:
    print(&#34;Depth first search strategy&#34;)
elif search_strategy == BEST_FIRST:
    print(&#34;Best first search strategy&#34;)
else:
    print(&#34;Unknown search strategy %s&#34; %search_strategy)

print(&#34;===========================================&#34;)

# List of candidate nodes
Q = PriorityQueue()

# The current tree depth
cur_depth = 0
cur_index = 0

# Timer
timer = time.time()

Q.push((0, None, None, None, None), INFINITY)

# Branch and Bound Loop
while not Q.isEmpty():

    cur_index, parent, branch_var, sense, rhs = Q.pop()
    if cur_index is not 0:
        cur_depth = T.get_node_attr(parent, &#39;level&#39;) + 1
    else:
        cur_depth = 0

    print(&#34;&#34;)
    print(&#34;----------------------------------------------------&#34;)
    print(&#34;&#34;)
    print(&#34;Node: %s, Depth: %s, LB: %s&#34; %(cur_index,cur_depth,LB))

    #====================================
    #    LP Relaxation
    #====================================
    #Compute lower bound by LP relaxation
    prob = LpProblem(&#34;relax&#34;,LpMaximize)
    prob += lpSum([OBJ[i]*var[i] for i in VARIABLES]), &#34;Objective&#34;
    for j in range(numCons):
        prob += lpSum([MAT[i][j]*var[i] for i in VARIABLES]) &lt;= RHS[j], \
            CONSTRAINTS[j]

    #Fix all prescribed variables
    branch_vars = []
    if cur_index is not 0:
        print(&#34;Branching variables: &#34;)
        branch_vars.append(branch_var)
        if sense == &#39;&gt;=&#39;:
            prob += LpConstraint(lpSum(var[branch_var]) &gt;= rhs)
        else:
            prob += LpConstraint(lpSum(var[branch_var]) &lt;= rhs)
        print(branch_var, end=&#39; &#39;)
        pred = parent
        while not str(pred) == &#39;0&#39;:
            pred_branch_var = T.get_node_attr(pred, &#39;branch_var&#39;)
            pred_rhs = T.get_node_attr(pred, &#39;rhs&#39;)
            pred_sense = T.get_node_attr(pred, &#39;sense&#39;)
            if pred_sense == &#39;&lt;=&#39;:
                prob += LpConstraint(lpSum(var[pred_branch_var]) &lt;= pred_rhs)
            else:
                prob += LpConstraint(lpSum(var[pred_branch_var]) &gt;= pred_rhs)
            print(pred_branch_var, end=&#39; &#39;)
            branch_vars.append(pred_branch_var)
            pred = T.get_node_attr(pred, &#39;parent&#39;)

    print(&#34;&#34;)

    # Solve the LP relaxation
    prob.solve()

    lp_count = lp_count +1

    # Check infeasibility
    infeasible = LpStatus[prob.status] == &#34;Infeasible&#34;

    # Print status
    if infeasible:
        print(&#34;LP Solved, status: Infeasible&#34;)
    else:
        print(&#34;LP Solved, status: %s, obj: %s&#34; %(LpStatus[prob.status],
                                                 value(prob.objective)))


    if(LpStatus[prob.status] == &#34;Optimal&#34;):
        relax = value(prob.objective)
    else:
        relax = INFINITY

    integer_solution = 0

    if (LpStatus[prob.status] == &#34;Optimal&#34;):
        var_values = dict([(i, var[i].varValue) for i in VARIABLES])
        integer_solution = 1
        for i in VARIABLES:
            if (var_values[i] not in set([0,1])):
                integer_solution = 0
                break
        if (integer_solution and relax&gt;LB):
            LB = relax
            for i in VARIABLES:
                #these two have different data structures first one list
                #second one dictionary
                opt[i] = var_values[i]
            print(&#34;New best solution found, objective: %s&#34; %relax)
            for i in VARIABLES:
                if var_values[i] &gt; 0:
                    print(&#34;%s = %s&#34; %(i, var_values[i]))
        elif (integer_solution and relax&lt;=LB):
            print(&#34;New integer solution found, objective: %s&#34; %relax)
            for i in VARIABLES:
                if var_values[i] &gt; 0:
                    print(&#34;%s = %s&#34; %(i, var_values[i]))
        else:
            print(&#34;Fractional solution:&#34;)
            for i in VARIABLES:
                if var_values[i] &gt; 0:
                    print(&#34;%s = %s&#34; %(i, var_values[i]))

    #For complete enumeration
    if complete_enumeration:
        relax = LB - 1

    if integer_solution:
        print(&#34;Integer solution&#34;)
        status = &#39;S&#39;
        BAKstatus = &#39;integer&#39;
        color = &#39;lightblue&#39;
    elif infeasible:
        print(&#34;Infeasible node&#34;)
        status = &#39;I&#39;
        BAKstatus = &#39;infeasible&#39;
        color = &#39;orange&#39;
    elif not complete_enumeration and relax &lt;= LB:
        print(&#34;Node pruned by bound (obj: %s, UB: %s)&#34; %(relax,LB))
        status = &#39;P&#39;
        BAKstatus = &#39;fathomed&#39;
        color = &#39;red&#39;
    elif cur_depth &gt;= numVars :
        print(&#34;Reached a leaf&#34;)
        BAKstatus = &#39;fathomed&#39;
        status = &#39;L&#39;
    else:
        status = &#39;C&#39;
        BAKstatus = &#39;candidate&#39;
        color = &#39;yellow&#39;

    if status is not &#39;I&#39;:
#        label = status + &#34;: &#34; + &#34;%.1f&#34;%relax
        label = &#34;%.1f&#34;%relax
    else:
        label = &#39;I&#39;

    if iter_count == 0:
        if layout == &#39;bak&#39;:
            T.AddOrUpdateNode(0, -1, None, BAKstatus, -relax, None, None)
        else:
            T.add_root(0, label = label, status = status, obj = relax, color = color,
                       style = &#39;filled&#39;, fillcolor = color)
        if ETREE_INSTALLED and display_mode == &#39;svg&#39;:
            T.write_as_svg(filename = &#34;node%d&#34; % iter_count,
                           nextfile = &#34;node%d&#34; % (iter_count + 1),
                           highlight = cur_index)
    else:
        if layout == &#39;bak&#39;:
            if sense == &#39;&lt;=&#39;:
                T.AddOrUpdateNode(cur_index, parent, &#39;L&#39;, &#39;candidate&#39;,
                                  -relax, None, None, branch_var = branch_var,
                                  sense = sense, rhs = rhs)
            else:
                T.AddOrUpdateNode(cur_index, parent, &#39;R&#39;, &#39;candidate&#39;,
                                  -relax, None, None, branch_var = branch_var,
                                  sense = sense, rhs = rhs)
        else:
            T.add_child(cur_index, parent, label = label, branch_var = branch_var,
                        sense = sense, rhs = rhs, status = status, obj = relax,
                        color = color, style = &#39;filled&#39;, fillcolor = color)
            if layout == &#39;ladot&#39;:
                if sense == &#39;&gt;=&#39;:
                    T.set_edge_attr(parent, cur_index, &#39;label&#39;,
                                    &#34;$&#34;+str(branch_var) + &#34; \geq &#34; + str(rhs) + &#34;$&#34;)
                else:
                    T.set_edge_attr(parent, cur_index, &#39;label&#39;,
                                    &#34;$&#34;+str(branch_var) + &#34; \leq &#34; + str(rhs) + &#34;$&#34;)
            else:
                T.set_edge_attr(parent, cur_index, &#39;label&#39;,
                                str(branch_var) + sense + str(rhs))
        if ETREE_INSTALLED and display_mode == &#39;svg&#39;:
            T.write_as_svg(filename = &#34;node%d&#34; % iter_count,
                           prevfile = &#34;node%d&#34; % (iter_count - 1),
                           nextfile = &#34;node%d&#34; % (iter_count + 1),
                           highlight = cur_index)
    iter_count += 1

    if ((MATPLOTLIB_INSTALLED and display_mode == &#39;matplotlib&#39;)
         or (XDOT_INSTALLED and display_mode == &#39;xdot&#39;)):
        numNodes = len(T.get_node_list())
        if numNodes % display_interval == 0 and not layout != &#39;ladot&#39;:
            T.display(highlight = [cur_index])

    if status == &#39;C&#39;:

        # Branching:
        # Choose a variable for branching
        branching_var = None
        if branch_strategy == FIXED:
            #fixed order
            for i in VARIABLES:
                frac = min(var[i].varValue-math.floor(var[i].varValue),
                           math.ceil(var[i].varValue) - var[i].varValue)
                if (frac &gt; 0):
                    min_frac = frac
                    branching_var = i
                    break
        elif branch_strategy == MOST_FRAC:
            #most fractional variable
            min_frac = -1
            for i in VARIABLES:
                frac = min(var[i].varValue-math.floor(var[i].varValue),
                           math.ceil(var[i].varValue)- var[i].varValue )
                if (frac&gt; min_frac):
                    min_frac = frac
                    branching_var = i

        else:
            print(&#34;Unknown branching strategy %s&#34; %branch_strategy)
            exit()

        if branching_var is not None:
            print(&#34;Branching on variable %s&#34; %branching_var)

        #Create new nodes
        if search_strategy == DEPTH_FIRST:
            priority = -cur_depth - 1
        elif search_strategy == BEST_FIRST:
            priority = relax
        node_count += 1
        Q.push((node_count, cur_index, branching_var, &#39;&lt;=&#39;, math.floor(var[branching_var].varValue)), priority)
        node_count += 1
        Q.push((node_count, cur_index, branching_var, &#39;&gt;=&#39;, math.ceil(var[branching_var].varValue)), priority)
        T.set_node_attr(cur_index, color, &#39;green&#39;)
        if layout == &#39;bak&#39;:
            T.set_node_attr(cur_index, &#39;status&#39;, &#39;branched&#39;)

timer = int(math.ceil((time.time()-timer)*1000))

if ((XDOT_INSTALLED and display_mode == &#39;xdot&#39; and layout != &#39;ladot&#39;) or
    layout == &#39;bak&#39;):
    T.display()
if layout == &#39;ladot&#39;:
    T.write_as_dot(filename = &#39;graph&#39;)

print(&#34;&#34;)
print(&#34;===========================================&#34;)
print(&#34;Branch and bound completed in %sms&#34; %timer)
print(&#34;Strategy: %s&#34; %branch_strategy)
if complete_enumeration:
    print(&#34;Complete enumeration&#34;)
print(&#34;%s nodes visited &#34; %node_count)
print(&#34;%s LP&#39;s solved&#34; %lp_count)
print(&#34;===========================================&#34;)
print(&#34;Optimal solution&#34;)
#print optimal solution
for i in sorted(VARIABLES):
    if opt[i] &gt; 0:
        print(&#34;%s = %s&#34; %(i, opt[i]))
print(&#34;Objective function value&#34;)
print(LB)
print(&#34;===========================================&#34;)</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="coinor.gimpy.examples.BB.random"><code class="name flex">
<span>def <span class="ident">random</span></span>(<span>)</span>
</code></dt>
<dd>
<div class="desc"><p>random() -&gt; x in the interval [0, 1).</p></div>
</dd>
</dl>
</section>
<section>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="coinor.gimpy.examples" href="index.html">coinor.gimpy.examples</a></code></li>
</ul>
</li>
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="">
<li><code><a title="coinor.gimpy.examples.BB.random" href="#coinor.gimpy.examples.BB.random">random</a></code></li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc"><cite>pdoc</cite> 0.9.2</a>.</p>
</footer>
</body>
</html>