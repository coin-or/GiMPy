<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.9.2" />
<title>coinor.gimpy.tree API documentation</title>
<meta name="description" content="Tree class built on top of Graph class." />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>coinor.gimpy.tree</code></h1>
</header>
<section id="section-intro">
<p>Tree class built on top of Graph class.</p>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">&#39;&#39;&#39;
Tree class built on top of Graph class.
&#39;&#39;&#39;
from __future__ import print_function
from __future__ import absolute_import
from builtins import str

from .graph import Graph, Node
from .global_constants import *
try:
    from src.blimpy import Stack, Queue
except ImportError:
    from coinor.blimpy import Stack, Queue
import operator
import sys

class Tree(Graph):
    &#39;&#39;&#39;
    Tree class. It inherits from Graph class. Provides DFS, BFS and traverse
    methods.
    &#39;&#39;&#39;
    def __init__(self, **attrs):
        &#39;&#39;&#39;
        API: __init__(self, **attrs)
        Description:
            Constructor. Sets attrbutes of class using argument.
        Input:
            attrs: Attributes in keyword arguments format.
        &#39;&#39;&#39;
        attrs[&#39;type&#39;] = DIRECTED_GRAPH
        if &#39;layout&#39; not in attrs:
            attrs[&#39;layout&#39;] = &#39;dot&#39;
        Graph.__init__(self, **attrs)
        self.root = None

    def get_children(self, n):
        &#39;&#39;&#39;
        API: get_children(self, n)
        Description:
            Returns list of children of node n.
        Pre:
            Node with name n should exist.
        Input:
            n: Node name.
        Return:
            Returns list of names of children nodes of n.
        &#39;&#39;&#39;
        return self.get_neighbors(n)

    def get_parent(self, n):
        &#39;&#39;&#39;
        API: get_parent(self, n)
        Description:
            Returns parent node name if n&#39;s parent exists, returns
            None otherwise.
        Pre:
            Node with name n should exist.
        Input:
            n: Node name.
        Return:
            Returns parent name of n if its parent exists, returns None
            otherwise.
        &#39;&#39;&#39;
        n = self.get_node(n)
        return n.get_attr(&#39;parent&#39;)

    def add_root(self, root, **attrs):
        &#39;&#39;&#39;
        API: add_root(self, root, **attrs)
        Description:
            Adds root node to the tree with name root and returns root Node
            instance.
        Input:
            root: Root node name.
            attrs: Root node attributes.
        Post:
            Changes self.root.
        Return:
            Returns root Node instance.
        &#39;&#39;&#39;
        attrs[&#39;level&#39;] = 0
        self.root = self.add_node(root, **attrs)
        return self.root

    def add_child(self, n, parent, **attrs):
        &#39;&#39;&#39;
        API: add_child(self, n, parent, **attrs)
        Description:
            Adds child n to node parent and return Node n.
        Pre:
            Node with name parent should exist.
        Input:
            n: Child node name.
            parent: Parent node name.
            attrs: Attributes of node being added.
        Post:
            Updates Graph related graph data attributes.
        Return:
            Returns n Node instance.
        &#39;&#39;&#39;
        attrs[&#39;level&#39;] = self.get_node(parent).get_attr(&#39;level&#39;) + 1
        attrs[&#39;parent&#39;] = parent
        self.add_node(n, **attrs)
        self.add_edge(parent, n)
        return self.get_node(n)

    def dfs(self, root = None, display = None):
        &#39;&#39;&#39;
        API: dfs(self, root = None, display = None)
        Description:
            Searches tree starting from node named root using depth-first
            strategy if root argument is provided. Starts search from root node
            of the tree otherwise.
        Pre:
            Node indicated by root argument should exist.
        Input:
            root: Starting node name.
            display: Display argument.
        &#39;&#39;&#39;
        if root == None:
            root = self.root
        if display == None:
            display = self.attr[&#39;display&#39;]
        self.traverse(root, display, Stack())

    def bfs(self, root = None, display = None):
        &#39;&#39;&#39;
        API: bfs(self, root = None, display = None)
        Description:
            Searches tree starting from node named root using breadth-first
            strategy if root argument is provided. Starts search from root node
            of the tree otherwise.
        Pre:
            Node indicated by root argument should exist.
        Input:
            root: Starting node name.
            display: Display argument.
        &#39;&#39;&#39;
        if root == None:
            root = self.root
        if display == None:
            display = self.attr[&#39;display&#39;]
        self.traverse(root, display, Queue())

    def traverse(self, root = None, display = None, q = Stack()):
        &#39;&#39;&#39;
        API: traverse(self, root = None, display = None, q = Stack())
        Description:
            Traverses tree starting from node named root. Used strategy (BFS,
            DFS) is controlled by argument q. It is a DFS if q is Queue(), BFS
            if q is Stack(). Starts search from root argument if it is given.
            Starts from root node of the tree otherwise.
        Pre:
            Node indicated by root argument should exist.
        Input:
            root: Starting node name.
            display: Display argument.
            q: Queue data structure instance. It is either a Stack() or
            Queue().
        &#39;&#39;&#39;
        if root == None:
            root = self.root
        if display == None:
            display = self.attr[&#39;display&#39;]
        if isinstance(q, Queue):
            addToQ = q.enqueue
            removeFromQ = q.dequeue
        elif isinstance(q, Stack):
            addToQ = q.push
            removeFromQ = q.pop
        addToQ(root)
        while not q.isEmpty():
            current = removeFromQ()
            #print current
            if display:
                self.display(highlight = [current])
            for n in self.get_children(current):
                addToQ(n)


class BinaryTree(Tree):
    &#39;&#39;&#39;
    Binary tree class. Inherits Tree class. Provides methods for adding
    left/right childs and binary tree specific DFS and BFS methods.
    &#39;&#39;&#39;
    def __init__(self, **attrs):
        &#39;&#39;&#39;
        API: __init__(self, **attrs)
        Description:
            Class constructor.
        Input:
            attrs: Tree attributes in keyword arguments format. See Graph and
            Tree class for details.
        &#39;&#39;&#39;
        Tree.__init__(self, **attrs)

    def add_root(self, root, **attrs):
        &#39;&#39;&#39;
        API: add_root(self, root, **attrs)
        Description:
            Adds root node to the binary tree.
        Input:
            root: Name of the root node.
            attrs: Attributes of the root node.
        Post:
            Changes self.root attribute.
        &#39;&#39;&#39;
        Tree.add_root(self, root, **attrs)

    def add_right_child(self, n, parent, **attrs):
        &#39;&#39;&#39;
        API: add_right_child(self, n, parent, **attrs)
        Description:
            Adds right child n to node parent.
        Pre:
            Right child of parent should not exist.
        Input:
            n: Node name.
            parent: Parent node name.
            attrs: Attributes of node n.
        &#39;&#39;&#39;
        if self.get_right_child(parent) is not None:
            msg = &#34;Right child already exists for node &#34; + str(parent)
            raise Exception(msg)
        attrs[&#39;direction&#39;] = &#39;R&#39;
        self.set_node_attr(parent, &#39;Rchild&#39;, n)
        self.add_child(n, parent, **attrs)

    def add_left_child(self, n, parent, **attrs):
        &#39;&#39;&#39;
        API: add_left_child(self, n, parent, **attrs)
        Description:
            Adds left child n to node parent.
        Pre:
            Left child of parent should not exist.
        Input:
            n: Node name.
            parent: Parent node name.
            attrs: Attributes of node n.
        &#39;&#39;&#39;
        if self.get_left_child(parent) is not None:
            msg = &#34;Right child already exists for node &#34; + str(parent)
            raise Exception(msg)
        attrs[&#39;direction&#39;] = &#39;L&#39;
        self.set_node_attr(parent, &#39;Lchild&#39;, n)
        self.add_child(n, parent, **attrs)

    def get_right_child(self, n):
        &#39;&#39;&#39;
        API: get_right_child(self, n)
        Description:
            Returns right child of node n. n can be Node() instance or string
            (name of node).
        Pre:
            Node n should be present in the tree.
        Input:
            n: Node name or Node() instance.
        Return:
            Returns name of the right child of n.
        &#39;&#39;&#39;
        if isinstance(n, Node):
            return n.get_attr(&#39;Rchild&#39;)
        return self.get_node_attr(n, &#39;Rchild&#39;)

    def get_left_child(self, n):
        &#39;&#39;&#39;
        API: get_left_child(self, n)
        Description:
            Returns left child of node n. n can be Node() instance or string
            (name of node).
        Pre:
            Node n should be present in the tree.
        Input:
            n: Node name or Node() instance.
        Return:
            Returns name of the left child of n.
        &#39;&#39;&#39;
        if isinstance(n, Node):
            return n.get_attr(&#39;Lchild&#39;)
        return self.get_node_attr(n, &#39;Lchild&#39;)

    def del_node(self, n):
        &#39;&#39;&#39;
        API: del_node(self, n)
        Description:
            Removes node n from tree.
        Pre:
            Node n should be present in the tree.
        Input:
            n: Node name.
        &#39;&#39;&#39;
        parent = self.get_node_attr(n, &#39;parent&#39;)
        if self.get_node_attr(n, &#39;direction&#39;) == &#39;R&#39;:
            self.set_node_attr(parent, &#39;Rchild&#39;, None)
        else:
            self.set_node_attr(parent, &#39;Lchild&#39;, None)
        Graph.del_node(self, n)

    def print_nodes(self, order = &#39;in&#39;, priority = &#39;L&#39;, display = None,
                    root = None):
        &#39;&#39;&#39;
        API: print_nodes(self, order = &#39;in&#39;, priority = &#39;L&#39;, display = None,
                    root = None)
        Description:
            A recursive function that prints nodes to stdout starting from
            root.
        Input:
            order: Order of printing. Acceptable arguments are &#39;pre&#39;, &#39;in&#39;,
            &#39;post&#39;.
            priority: Priority of printing, acceptable arguments are &#39;L&#39; and
            &#39;R&#39;.
            display: Display mode.
            root: Starting node.
        &#39;&#39;&#39;
        old_display = None
        if root == None:
            root = self.root.name
        if display == None:
            display = self.attr[&#39;display&#39;]
        else:
            old_display = self.attr[&#39;display&#39;]
            self.attr[&#39;display&#39;] = display
        if priority == &#39;L&#39;:
            first_child = self.get_left_child
            second_child = self.get_right_child
        else:
            first_child = self.get_right_child
            second_child = self.get_left_child
        if order == &#39;pre&#39;:
            print(root)
        if first_child(root) is not None:
            if display:
                self.display(highlight = [root])
            self.print_nodes(order, priority, display, first_child(root))
        if order == &#39;in&#39;:
            print(root)
        if second_child(root) is not None:
            if display:
                self.display(highlight = [root])
            self.print_nodes(order, priority, display, second_child(root))
        if order == &#39;post&#39;:
            print(root)
        if display:
            self.display(highlight = [root])
        if old_display:
            self.attr[&#39;display&#39;] = old_display

    def dfs(self, root = None, display = None, priority = &#39;L&#39;):
        &#39;&#39;&#39;
        API: dfs(self, root=None, display=None, priority=&#39;L&#39;, order=&#39;in&#39;)
        Description:
            Searches tree starting from node named root using depth-first
            strategy if root argument is provided. Starts search from root node
            of the tree otherwise.
        Input:
            root: Starting node.
            display: Display mode.
            priority: Priority used when exploring children of the node.
            Acceptable arguments are &#39;L&#39; and &#39;R&#39;.
        &#39;&#39;&#39;
        if root == None:
            root = self.root
        self.traverse(root, display, Stack(), priority)

    def bfs(self, root = None, display = None, priority = &#39;L&#39;):
        &#39;&#39;&#39;
        API: bfs(self, root=None, display=None, priority=&#39;L&#39;, order=&#39;in&#39;)
        Description:
            Searches tree starting from node named root using breadth-first
            strategy if root argument is provided. Starts search from root node
            of the tree otherwise.
        Input:
            root: Starting node.
            display: Display mode.
            priority: Priority used when exploring children of the node.
            Acceptable arguments are &#39;L&#39; and &#39;R&#39;.
        &#39;&#39;&#39;
        if root == None:
            root = self.root
        self.traverse(root, display, Queue(), priority)

    def traverse(self, root = None, display = None, q = Stack(),
                 priority = &#39;L&#39;):
        &#39;&#39;&#39;
        API: traverse(self, root=None, display=None, q=Stack(), priority=&#39;L&#39;,
                      order=&#39;in&#39;)
        Description:
            Traverses tree starting from node named root if root argument is
            provided. Starts search from root node of the tree otherwise. Search
            strategy is determined by q data structure. It is DFS if q is
            Stack() and BFS if Queue().
        Input:
            root: Starting node.
            display: Display mode.
            q: Queue data structure, either Queue() or Stack().
            priority: Priority used when exploring children of the node.
            Acceptable arguments are &#39;L&#39; and &#39;R&#39;.
            order: Ineffective, will be removed.
        &#39;&#39;&#39;
        old_display = None
        if root == None:
            root = self.root
        if display == None:
            display = self.attr[&#39;display&#39;]
        else:
            old_display = self.attr[&#39;display&#39;]
            self.attr[&#39;display&#39;] = display
        if isinstance(q, Queue):
            addToQ = q.enqueue
            removeFromQ = q.dequeue
        elif isinstance(q, Stack):
            addToQ = q.push
            removeFromQ = q.pop
        if priority == &#39;L&#39;:
            first_child = self.get_left_child
            second_child = self.get_right_child
        else:
            first_child = self.get_right_child
            second_child = self.get_left_child
        addToQ(root)
        while not q.isEmpty():
            current = removeFromQ()
            if display:
                self.display(highlight = [current])
            n = first_child(current)
            if n is not None:
                addToQ(n)
            n = second_child(current)
            if n is not None:
                addToQ(n)
        if old_display:
            self.attr[&#39;display&#39;] = old_display

    def printexp(self, display = None, root = None):
        if root == None:
            root = self.root
        if display == None:
            display = self.attr[&#39;display&#39;]
        if self.get_left_child(root):
            if display:
                self.display(highlight = [root])
            print(&#39;(&#39;, end=&#39; &#39;)
            sys.stdout.flush()
            self.printexp(display, self.get_left_child(root))
        if isinstance(root, Node):
            if &#39;label&#39; in root.attr:
                root_label = root.attr[&#39;label&#39;]
            else:
                root_label = root.name
        else:
            root_label = self.get_node_attr(root, &#39;label&#39;)
            if root_label == None:
                root_label = root
        print(root_label, end=&#39; &#39;)
        sys.stdout.flush()
        if display:
                self.display(highlight = [root])
        if self.get_right_child(root):
            self.printexp(display, self.get_right_child(root))
            print(&#39;)&#39;, end=&#39; &#39;)
            sys.stdout.flush()
            if display:
                self.display(highlight = [root])

    def postordereval(self, display = None, root = None):
        if root == None:
            root = self.root
        if display == None:
            display = self.attr[&#39;display&#39;]
        opers = {&#39;+&#39;:operator.add, &#39;-&#39;:operator.sub, &#39;*&#39;:operator.mul,
                 &#39;/&#39;:operator.truediv}
        res1 = None
        res2 = None
        if self.get_left_child(root):
            if display:
                self.display(highlight = [root])
            res1 = self.postordereval(display, self.get_left_child(root))
        if isinstance(root, Node):
            if &#39;label&#39; in root.attr:
                root_label = root.attr[&#39;label&#39;]
            else:
                root_label = root.name
        else:
            root_label = self.get_node_attr(root, &#39;label&#39;)
            if root_label == None:
                root_label = root
        print(root_label, end=&#39; &#39;)
        sys.stdout.flush()
        if display:
                self.display(highlight = [root])
        if self.get_right_child(root):
            res2 = self.postordereval(display, self.get_right_child(root))
        if res1 and res2:
            result = opers[root_label](res1 , res2)
            print(&#39;=&#39;, result)
            sys.stdout.flush()
            if display:
                self.display(highlight = [root])
            print(result, end=&#39; &#39;)
            sys.stdout.flush()
            return result
        else:
            return int(root_label) 

if __name__ == &#39;__main__&#39;:

    T = BinaryTree(display = &#39;matplotlib&#39;)
    T.add_root(&#39;*&#39;)
    T.add_left_child(&#39;+&#39;, &#39;*&#39;)
    T.add_left_child(&#39;4&#39;, &#39;+&#39;)
    T.add_right_child(&#39;5&#39;, &#39;+&#39;)
    T.add_right_child(&#39;7&#39;, &#39;*&#39;)
    T.printexp()
    print()
    T.postordereval()
    print()</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="coinor.gimpy.tree.BinaryTree"><code class="flex name class">
<span>class <span class="ident">BinaryTree</span></span>
<span>(</span><span>**attrs)</span>
</code></dt>
<dd>
<div class="desc"><p>Binary tree class. Inherits Tree class. Provides methods for adding
left/right childs and binary tree specific DFS and BFS methods.</p>
<p>API: <strong>init</strong>(self, **attrs)</p>
<h2 id="description">Description</h2>
<p>Class constructor.</p>
<h2 id="input">Input</h2>
<p>attrs: Tree attributes in keyword arguments format. See Graph and
Tree class for details.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class BinaryTree(Tree):
    &#39;&#39;&#39;
    Binary tree class. Inherits Tree class. Provides methods for adding
    left/right childs and binary tree specific DFS and BFS methods.
    &#39;&#39;&#39;
    def __init__(self, **attrs):
        &#39;&#39;&#39;
        API: __init__(self, **attrs)
        Description:
            Class constructor.
        Input:
            attrs: Tree attributes in keyword arguments format. See Graph and
            Tree class for details.
        &#39;&#39;&#39;
        Tree.__init__(self, **attrs)

    def add_root(self, root, **attrs):
        &#39;&#39;&#39;
        API: add_root(self, root, **attrs)
        Description:
            Adds root node to the binary tree.
        Input:
            root: Name of the root node.
            attrs: Attributes of the root node.
        Post:
            Changes self.root attribute.
        &#39;&#39;&#39;
        Tree.add_root(self, root, **attrs)

    def add_right_child(self, n, parent, **attrs):
        &#39;&#39;&#39;
        API: add_right_child(self, n, parent, **attrs)
        Description:
            Adds right child n to node parent.
        Pre:
            Right child of parent should not exist.
        Input:
            n: Node name.
            parent: Parent node name.
            attrs: Attributes of node n.
        &#39;&#39;&#39;
        if self.get_right_child(parent) is not None:
            msg = &#34;Right child already exists for node &#34; + str(parent)
            raise Exception(msg)
        attrs[&#39;direction&#39;] = &#39;R&#39;
        self.set_node_attr(parent, &#39;Rchild&#39;, n)
        self.add_child(n, parent, **attrs)

    def add_left_child(self, n, parent, **attrs):
        &#39;&#39;&#39;
        API: add_left_child(self, n, parent, **attrs)
        Description:
            Adds left child n to node parent.
        Pre:
            Left child of parent should not exist.
        Input:
            n: Node name.
            parent: Parent node name.
            attrs: Attributes of node n.
        &#39;&#39;&#39;
        if self.get_left_child(parent) is not None:
            msg = &#34;Right child already exists for node &#34; + str(parent)
            raise Exception(msg)
        attrs[&#39;direction&#39;] = &#39;L&#39;
        self.set_node_attr(parent, &#39;Lchild&#39;, n)
        self.add_child(n, parent, **attrs)

    def get_right_child(self, n):
        &#39;&#39;&#39;
        API: get_right_child(self, n)
        Description:
            Returns right child of node n. n can be Node() instance or string
            (name of node).
        Pre:
            Node n should be present in the tree.
        Input:
            n: Node name or Node() instance.
        Return:
            Returns name of the right child of n.
        &#39;&#39;&#39;
        if isinstance(n, Node):
            return n.get_attr(&#39;Rchild&#39;)
        return self.get_node_attr(n, &#39;Rchild&#39;)

    def get_left_child(self, n):
        &#39;&#39;&#39;
        API: get_left_child(self, n)
        Description:
            Returns left child of node n. n can be Node() instance or string
            (name of node).
        Pre:
            Node n should be present in the tree.
        Input:
            n: Node name or Node() instance.
        Return:
            Returns name of the left child of n.
        &#39;&#39;&#39;
        if isinstance(n, Node):
            return n.get_attr(&#39;Lchild&#39;)
        return self.get_node_attr(n, &#39;Lchild&#39;)

    def del_node(self, n):
        &#39;&#39;&#39;
        API: del_node(self, n)
        Description:
            Removes node n from tree.
        Pre:
            Node n should be present in the tree.
        Input:
            n: Node name.
        &#39;&#39;&#39;
        parent = self.get_node_attr(n, &#39;parent&#39;)
        if self.get_node_attr(n, &#39;direction&#39;) == &#39;R&#39;:
            self.set_node_attr(parent, &#39;Rchild&#39;, None)
        else:
            self.set_node_attr(parent, &#39;Lchild&#39;, None)
        Graph.del_node(self, n)

    def print_nodes(self, order = &#39;in&#39;, priority = &#39;L&#39;, display = None,
                    root = None):
        &#39;&#39;&#39;
        API: print_nodes(self, order = &#39;in&#39;, priority = &#39;L&#39;, display = None,
                    root = None)
        Description:
            A recursive function that prints nodes to stdout starting from
            root.
        Input:
            order: Order of printing. Acceptable arguments are &#39;pre&#39;, &#39;in&#39;,
            &#39;post&#39;.
            priority: Priority of printing, acceptable arguments are &#39;L&#39; and
            &#39;R&#39;.
            display: Display mode.
            root: Starting node.
        &#39;&#39;&#39;
        old_display = None
        if root == None:
            root = self.root.name
        if display == None:
            display = self.attr[&#39;display&#39;]
        else:
            old_display = self.attr[&#39;display&#39;]
            self.attr[&#39;display&#39;] = display
        if priority == &#39;L&#39;:
            first_child = self.get_left_child
            second_child = self.get_right_child
        else:
            first_child = self.get_right_child
            second_child = self.get_left_child
        if order == &#39;pre&#39;:
            print(root)
        if first_child(root) is not None:
            if display:
                self.display(highlight = [root])
            self.print_nodes(order, priority, display, first_child(root))
        if order == &#39;in&#39;:
            print(root)
        if second_child(root) is not None:
            if display:
                self.display(highlight = [root])
            self.print_nodes(order, priority, display, second_child(root))
        if order == &#39;post&#39;:
            print(root)
        if display:
            self.display(highlight = [root])
        if old_display:
            self.attr[&#39;display&#39;] = old_display

    def dfs(self, root = None, display = None, priority = &#39;L&#39;):
        &#39;&#39;&#39;
        API: dfs(self, root=None, display=None, priority=&#39;L&#39;, order=&#39;in&#39;)
        Description:
            Searches tree starting from node named root using depth-first
            strategy if root argument is provided. Starts search from root node
            of the tree otherwise.
        Input:
            root: Starting node.
            display: Display mode.
            priority: Priority used when exploring children of the node.
            Acceptable arguments are &#39;L&#39; and &#39;R&#39;.
        &#39;&#39;&#39;
        if root == None:
            root = self.root
        self.traverse(root, display, Stack(), priority)

    def bfs(self, root = None, display = None, priority = &#39;L&#39;):
        &#39;&#39;&#39;
        API: bfs(self, root=None, display=None, priority=&#39;L&#39;, order=&#39;in&#39;)
        Description:
            Searches tree starting from node named root using breadth-first
            strategy if root argument is provided. Starts search from root node
            of the tree otherwise.
        Input:
            root: Starting node.
            display: Display mode.
            priority: Priority used when exploring children of the node.
            Acceptable arguments are &#39;L&#39; and &#39;R&#39;.
        &#39;&#39;&#39;
        if root == None:
            root = self.root
        self.traverse(root, display, Queue(), priority)

    def traverse(self, root = None, display = None, q = Stack(),
                 priority = &#39;L&#39;):
        &#39;&#39;&#39;
        API: traverse(self, root=None, display=None, q=Stack(), priority=&#39;L&#39;,
                      order=&#39;in&#39;)
        Description:
            Traverses tree starting from node named root if root argument is
            provided. Starts search from root node of the tree otherwise. Search
            strategy is determined by q data structure. It is DFS if q is
            Stack() and BFS if Queue().
        Input:
            root: Starting node.
            display: Display mode.
            q: Queue data structure, either Queue() or Stack().
            priority: Priority used when exploring children of the node.
            Acceptable arguments are &#39;L&#39; and &#39;R&#39;.
            order: Ineffective, will be removed.
        &#39;&#39;&#39;
        old_display = None
        if root == None:
            root = self.root
        if display == None:
            display = self.attr[&#39;display&#39;]
        else:
            old_display = self.attr[&#39;display&#39;]
            self.attr[&#39;display&#39;] = display
        if isinstance(q, Queue):
            addToQ = q.enqueue
            removeFromQ = q.dequeue
        elif isinstance(q, Stack):
            addToQ = q.push
            removeFromQ = q.pop
        if priority == &#39;L&#39;:
            first_child = self.get_left_child
            second_child = self.get_right_child
        else:
            first_child = self.get_right_child
            second_child = self.get_left_child
        addToQ(root)
        while not q.isEmpty():
            current = removeFromQ()
            if display:
                self.display(highlight = [current])
            n = first_child(current)
            if n is not None:
                addToQ(n)
            n = second_child(current)
            if n is not None:
                addToQ(n)
        if old_display:
            self.attr[&#39;display&#39;] = old_display

    def printexp(self, display = None, root = None):
        if root == None:
            root = self.root
        if display == None:
            display = self.attr[&#39;display&#39;]
        if self.get_left_child(root):
            if display:
                self.display(highlight = [root])
            print(&#39;(&#39;, end=&#39; &#39;)
            sys.stdout.flush()
            self.printexp(display, self.get_left_child(root))
        if isinstance(root, Node):
            if &#39;label&#39; in root.attr:
                root_label = root.attr[&#39;label&#39;]
            else:
                root_label = root.name
        else:
            root_label = self.get_node_attr(root, &#39;label&#39;)
            if root_label == None:
                root_label = root
        print(root_label, end=&#39; &#39;)
        sys.stdout.flush()
        if display:
                self.display(highlight = [root])
        if self.get_right_child(root):
            self.printexp(display, self.get_right_child(root))
            print(&#39;)&#39;, end=&#39; &#39;)
            sys.stdout.flush()
            if display:
                self.display(highlight = [root])

    def postordereval(self, display = None, root = None):
        if root == None:
            root = self.root
        if display == None:
            display = self.attr[&#39;display&#39;]
        opers = {&#39;+&#39;:operator.add, &#39;-&#39;:operator.sub, &#39;*&#39;:operator.mul,
                 &#39;/&#39;:operator.truediv}
        res1 = None
        res2 = None
        if self.get_left_child(root):
            if display:
                self.display(highlight = [root])
            res1 = self.postordereval(display, self.get_left_child(root))
        if isinstance(root, Node):
            if &#39;label&#39; in root.attr:
                root_label = root.attr[&#39;label&#39;]
            else:
                root_label = root.name
        else:
            root_label = self.get_node_attr(root, &#39;label&#39;)
            if root_label == None:
                root_label = root
        print(root_label, end=&#39; &#39;)
        sys.stdout.flush()
        if display:
                self.display(highlight = [root])
        if self.get_right_child(root):
            res2 = self.postordereval(display, self.get_right_child(root))
        if res1 and res2:
            result = opers[root_label](res1 , res2)
            print(&#39;=&#39;, result)
            sys.stdout.flush()
            if display:
                self.display(highlight = [root])
            print(result, end=&#39; &#39;)
            sys.stdout.flush()
            return result
        else:
            return int(root_label) </code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="coinor.gimpy.tree.Tree" href="#coinor.gimpy.tree.Tree">Tree</a></li>
<li><a title="coinor.gimpy.graph.Graph" href="graph.html#coinor.gimpy.graph.Graph">Graph</a></li>
</ul>
<h3>Subclasses</h3>
<ul class="hlist">
<li>coinor.grumpy.BBTree.BBTree</li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="coinor.gimpy.tree.BinaryTree.add_left_child"><code class="name flex">
<span>def <span class="ident">add_left_child</span></span>(<span>self, n, parent, **attrs)</span>
</code></dt>
<dd>
<div class="desc"><p>API: add_left_child(self, n, parent, **attrs)</p>
<h2 id="description">Description</h2>
<p>Adds left child n to node parent.</p>
<h2 id="pre">Pre</h2>
<p>Left child of parent should not exist.</p>
<h2 id="input">Input</h2>
<p>n: Node name.
parent: Parent node name.
attrs: Attributes of node n.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def add_left_child(self, n, parent, **attrs):
    &#39;&#39;&#39;
    API: add_left_child(self, n, parent, **attrs)
    Description:
        Adds left child n to node parent.
    Pre:
        Left child of parent should not exist.
    Input:
        n: Node name.
        parent: Parent node name.
        attrs: Attributes of node n.
    &#39;&#39;&#39;
    if self.get_left_child(parent) is not None:
        msg = &#34;Right child already exists for node &#34; + str(parent)
        raise Exception(msg)
    attrs[&#39;direction&#39;] = &#39;L&#39;
    self.set_node_attr(parent, &#39;Lchild&#39;, n)
    self.add_child(n, parent, **attrs)</code></pre>
</details>
</dd>
<dt id="coinor.gimpy.tree.BinaryTree.add_right_child"><code class="name flex">
<span>def <span class="ident">add_right_child</span></span>(<span>self, n, parent, **attrs)</span>
</code></dt>
<dd>
<div class="desc"><p>API: add_right_child(self, n, parent, **attrs)</p>
<h2 id="description">Description</h2>
<p>Adds right child n to node parent.</p>
<h2 id="pre">Pre</h2>
<p>Right child of parent should not exist.</p>
<h2 id="input">Input</h2>
<p>n: Node name.
parent: Parent node name.
attrs: Attributes of node n.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def add_right_child(self, n, parent, **attrs):
    &#39;&#39;&#39;
    API: add_right_child(self, n, parent, **attrs)
    Description:
        Adds right child n to node parent.
    Pre:
        Right child of parent should not exist.
    Input:
        n: Node name.
        parent: Parent node name.
        attrs: Attributes of node n.
    &#39;&#39;&#39;
    if self.get_right_child(parent) is not None:
        msg = &#34;Right child already exists for node &#34; + str(parent)
        raise Exception(msg)
    attrs[&#39;direction&#39;] = &#39;R&#39;
    self.set_node_attr(parent, &#39;Rchild&#39;, n)
    self.add_child(n, parent, **attrs)</code></pre>
</details>
</dd>
<dt id="coinor.gimpy.tree.BinaryTree.add_root"><code class="name flex">
<span>def <span class="ident">add_root</span></span>(<span>self, root, **attrs)</span>
</code></dt>
<dd>
<div class="desc"><p>API: add_root(self, root, **attrs)</p>
<h2 id="description">Description</h2>
<p>Adds root node to the binary tree.</p>
<h2 id="input">Input</h2>
<p>root: Name of the root node.
attrs: Attributes of the root node.</p>
<h2 id="post">Post</h2>
<p>Changes self.root attribute.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def add_root(self, root, **attrs):
    &#39;&#39;&#39;
    API: add_root(self, root, **attrs)
    Description:
        Adds root node to the binary tree.
    Input:
        root: Name of the root node.
        attrs: Attributes of the root node.
    Post:
        Changes self.root attribute.
    &#39;&#39;&#39;
    Tree.add_root(self, root, **attrs)</code></pre>
</details>
</dd>
<dt id="coinor.gimpy.tree.BinaryTree.bfs"><code class="name flex">
<span>def <span class="ident">bfs</span></span>(<span>self, root=None, display=None, priority='L')</span>
</code></dt>
<dd>
<div class="desc"><p>API: bfs(self, root=None, display=None, priority='L', order='in')</p>
<h2 id="description">Description</h2>
<p>Searches tree starting from node named root using breadth-first
strategy if root argument is provided. Starts search from root node
of the tree otherwise.</p>
<h2 id="input">Input</h2>
<p>root: Starting node.
display: Display mode.
priority: Priority used when exploring children of the node.
Acceptable arguments are 'L' and 'R'.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def bfs(self, root = None, display = None, priority = &#39;L&#39;):
    &#39;&#39;&#39;
    API: bfs(self, root=None, display=None, priority=&#39;L&#39;, order=&#39;in&#39;)
    Description:
        Searches tree starting from node named root using breadth-first
        strategy if root argument is provided. Starts search from root node
        of the tree otherwise.
    Input:
        root: Starting node.
        display: Display mode.
        priority: Priority used when exploring children of the node.
        Acceptable arguments are &#39;L&#39; and &#39;R&#39;.
    &#39;&#39;&#39;
    if root == None:
        root = self.root
    self.traverse(root, display, Queue(), priority)</code></pre>
</details>
</dd>
<dt id="coinor.gimpy.tree.BinaryTree.del_node"><code class="name flex">
<span>def <span class="ident">del_node</span></span>(<span>self, n)</span>
</code></dt>
<dd>
<div class="desc"><p>API: del_node(self, n)</p>
<h2 id="description">Description</h2>
<p>Removes node n from tree.</p>
<h2 id="pre">Pre</h2>
<p>Node n should be present in the tree.</p>
<h2 id="input">Input</h2>
<p>n: Node name.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def del_node(self, n):
    &#39;&#39;&#39;
    API: del_node(self, n)
    Description:
        Removes node n from tree.
    Pre:
        Node n should be present in the tree.
    Input:
        n: Node name.
    &#39;&#39;&#39;
    parent = self.get_node_attr(n, &#39;parent&#39;)
    if self.get_node_attr(n, &#39;direction&#39;) == &#39;R&#39;:
        self.set_node_attr(parent, &#39;Rchild&#39;, None)
    else:
        self.set_node_attr(parent, &#39;Lchild&#39;, None)
    Graph.del_node(self, n)</code></pre>
</details>
</dd>
<dt id="coinor.gimpy.tree.BinaryTree.dfs"><code class="name flex">
<span>def <span class="ident">dfs</span></span>(<span>self, root=None, display=None, priority='L')</span>
</code></dt>
<dd>
<div class="desc"><p>API: dfs(self, root=None, display=None, priority='L', order='in')</p>
<h2 id="description">Description</h2>
<p>Searches tree starting from node named root using depth-first
strategy if root argument is provided. Starts search from root node
of the tree otherwise.</p>
<h2 id="input">Input</h2>
<p>root: Starting node.
display: Display mode.
priority: Priority used when exploring children of the node.
Acceptable arguments are 'L' and 'R'.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def dfs(self, root = None, display = None, priority = &#39;L&#39;):
    &#39;&#39;&#39;
    API: dfs(self, root=None, display=None, priority=&#39;L&#39;, order=&#39;in&#39;)
    Description:
        Searches tree starting from node named root using depth-first
        strategy if root argument is provided. Starts search from root node
        of the tree otherwise.
    Input:
        root: Starting node.
        display: Display mode.
        priority: Priority used when exploring children of the node.
        Acceptable arguments are &#39;L&#39; and &#39;R&#39;.
    &#39;&#39;&#39;
    if root == None:
        root = self.root
    self.traverse(root, display, Stack(), priority)</code></pre>
</details>
</dd>
<dt id="coinor.gimpy.tree.BinaryTree.get_left_child"><code class="name flex">
<span>def <span class="ident">get_left_child</span></span>(<span>self, n)</span>
</code></dt>
<dd>
<div class="desc"><p>API: get_left_child(self, n)</p>
<h2 id="description">Description</h2>
<p>Returns left child of node n. n can be Node() instance or string
(name of node).</p>
<h2 id="pre">Pre</h2>
<p>Node n should be present in the tree.</p>
<h2 id="input">Input</h2>
<p>n: Node name or Node() instance.</p>
<h2 id="return">Return</h2>
<p>Returns name of the left child of n.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_left_child(self, n):
    &#39;&#39;&#39;
    API: get_left_child(self, n)
    Description:
        Returns left child of node n. n can be Node() instance or string
        (name of node).
    Pre:
        Node n should be present in the tree.
    Input:
        n: Node name or Node() instance.
    Return:
        Returns name of the left child of n.
    &#39;&#39;&#39;
    if isinstance(n, Node):
        return n.get_attr(&#39;Lchild&#39;)
    return self.get_node_attr(n, &#39;Lchild&#39;)</code></pre>
</details>
</dd>
<dt id="coinor.gimpy.tree.BinaryTree.get_right_child"><code class="name flex">
<span>def <span class="ident">get_right_child</span></span>(<span>self, n)</span>
</code></dt>
<dd>
<div class="desc"><p>API: get_right_child(self, n)</p>
<h2 id="description">Description</h2>
<p>Returns right child of node n. n can be Node() instance or string
(name of node).</p>
<h2 id="pre">Pre</h2>
<p>Node n should be present in the tree.</p>
<h2 id="input">Input</h2>
<p>n: Node name or Node() instance.</p>
<h2 id="return">Return</h2>
<p>Returns name of the right child of n.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_right_child(self, n):
    &#39;&#39;&#39;
    API: get_right_child(self, n)
    Description:
        Returns right child of node n. n can be Node() instance or string
        (name of node).
    Pre:
        Node n should be present in the tree.
    Input:
        n: Node name or Node() instance.
    Return:
        Returns name of the right child of n.
    &#39;&#39;&#39;
    if isinstance(n, Node):
        return n.get_attr(&#39;Rchild&#39;)
    return self.get_node_attr(n, &#39;Rchild&#39;)</code></pre>
</details>
</dd>
<dt id="coinor.gimpy.tree.BinaryTree.postordereval"><code class="name flex">
<span>def <span class="ident">postordereval</span></span>(<span>self, display=None, root=None)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def postordereval(self, display = None, root = None):
    if root == None:
        root = self.root
    if display == None:
        display = self.attr[&#39;display&#39;]
    opers = {&#39;+&#39;:operator.add, &#39;-&#39;:operator.sub, &#39;*&#39;:operator.mul,
             &#39;/&#39;:operator.truediv}
    res1 = None
    res2 = None
    if self.get_left_child(root):
        if display:
            self.display(highlight = [root])
        res1 = self.postordereval(display, self.get_left_child(root))
    if isinstance(root, Node):
        if &#39;label&#39; in root.attr:
            root_label = root.attr[&#39;label&#39;]
        else:
            root_label = root.name
    else:
        root_label = self.get_node_attr(root, &#39;label&#39;)
        if root_label == None:
            root_label = root
    print(root_label, end=&#39; &#39;)
    sys.stdout.flush()
    if display:
            self.display(highlight = [root])
    if self.get_right_child(root):
        res2 = self.postordereval(display, self.get_right_child(root))
    if res1 and res2:
        result = opers[root_label](res1 , res2)
        print(&#39;=&#39;, result)
        sys.stdout.flush()
        if display:
            self.display(highlight = [root])
        print(result, end=&#39; &#39;)
        sys.stdout.flush()
        return result
    else:
        return int(root_label) </code></pre>
</details>
</dd>
<dt id="coinor.gimpy.tree.BinaryTree.print_nodes"><code class="name flex">
<span>def <span class="ident">print_nodes</span></span>(<span>self, order='in', priority='L', display=None, root=None)</span>
</code></dt>
<dd>
<div class="desc"><p>API: print_nodes(self, order = 'in', priority = 'L', display = None,
root = None)</p>
<h2 id="description">Description</h2>
<p>A recursive function that prints nodes to stdout starting from
root.</p>
<h2 id="input">Input</h2>
<p>order: Order of printing. Acceptable arguments are 'pre', 'in',
'post'.
priority: Priority of printing, acceptable arguments are 'L' and
'R'.
display: Display mode.
root: Starting node.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def print_nodes(self, order = &#39;in&#39;, priority = &#39;L&#39;, display = None,
                root = None):
    &#39;&#39;&#39;
    API: print_nodes(self, order = &#39;in&#39;, priority = &#39;L&#39;, display = None,
                root = None)
    Description:
        A recursive function that prints nodes to stdout starting from
        root.
    Input:
        order: Order of printing. Acceptable arguments are &#39;pre&#39;, &#39;in&#39;,
        &#39;post&#39;.
        priority: Priority of printing, acceptable arguments are &#39;L&#39; and
        &#39;R&#39;.
        display: Display mode.
        root: Starting node.
    &#39;&#39;&#39;
    old_display = None
    if root == None:
        root = self.root.name
    if display == None:
        display = self.attr[&#39;display&#39;]
    else:
        old_display = self.attr[&#39;display&#39;]
        self.attr[&#39;display&#39;] = display
    if priority == &#39;L&#39;:
        first_child = self.get_left_child
        second_child = self.get_right_child
    else:
        first_child = self.get_right_child
        second_child = self.get_left_child
    if order == &#39;pre&#39;:
        print(root)
    if first_child(root) is not None:
        if display:
            self.display(highlight = [root])
        self.print_nodes(order, priority, display, first_child(root))
    if order == &#39;in&#39;:
        print(root)
    if second_child(root) is not None:
        if display:
            self.display(highlight = [root])
        self.print_nodes(order, priority, display, second_child(root))
    if order == &#39;post&#39;:
        print(root)
    if display:
        self.display(highlight = [root])
    if old_display:
        self.attr[&#39;display&#39;] = old_display</code></pre>
</details>
</dd>
<dt id="coinor.gimpy.tree.BinaryTree.printexp"><code class="name flex">
<span>def <span class="ident">printexp</span></span>(<span>self, display=None, root=None)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def printexp(self, display = None, root = None):
    if root == None:
        root = self.root
    if display == None:
        display = self.attr[&#39;display&#39;]
    if self.get_left_child(root):
        if display:
            self.display(highlight = [root])
        print(&#39;(&#39;, end=&#39; &#39;)
        sys.stdout.flush()
        self.printexp(display, self.get_left_child(root))
    if isinstance(root, Node):
        if &#39;label&#39; in root.attr:
            root_label = root.attr[&#39;label&#39;]
        else:
            root_label = root.name
    else:
        root_label = self.get_node_attr(root, &#39;label&#39;)
        if root_label == None:
            root_label = root
    print(root_label, end=&#39; &#39;)
    sys.stdout.flush()
    if display:
            self.display(highlight = [root])
    if self.get_right_child(root):
        self.printexp(display, self.get_right_child(root))
        print(&#39;)&#39;, end=&#39; &#39;)
        sys.stdout.flush()
        if display:
            self.display(highlight = [root])</code></pre>
</details>
</dd>
<dt id="coinor.gimpy.tree.BinaryTree.traverse"><code class="name flex">
<span>def <span class="ident">traverse</span></span>(<span>self, root=None, display=None, q=[], priority='L')</span>
</code></dt>
<dd>
<div class="desc"><p>API: traverse(self, root=None, display=None, q=Stack(), priority='L',
order='in')</p>
<h2 id="description">Description</h2>
<p>Traverses tree starting from node named root if root argument is
provided. Starts search from root node of the tree otherwise. Search
strategy is determined by q data structure. It is DFS if q is
Stack() and BFS if Queue().</p>
<h2 id="input">Input</h2>
<p>root: Starting node.
display: Display mode.
q: Queue data structure, either Queue() or Stack().
priority: Priority used when exploring children of the node.
Acceptable arguments are 'L' and 'R'.
order: Ineffective, will be removed.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def traverse(self, root = None, display = None, q = Stack(),
             priority = &#39;L&#39;):
    &#39;&#39;&#39;
    API: traverse(self, root=None, display=None, q=Stack(), priority=&#39;L&#39;,
                  order=&#39;in&#39;)
    Description:
        Traverses tree starting from node named root if root argument is
        provided. Starts search from root node of the tree otherwise. Search
        strategy is determined by q data structure. It is DFS if q is
        Stack() and BFS if Queue().
    Input:
        root: Starting node.
        display: Display mode.
        q: Queue data structure, either Queue() or Stack().
        priority: Priority used when exploring children of the node.
        Acceptable arguments are &#39;L&#39; and &#39;R&#39;.
        order: Ineffective, will be removed.
    &#39;&#39;&#39;
    old_display = None
    if root == None:
        root = self.root
    if display == None:
        display = self.attr[&#39;display&#39;]
    else:
        old_display = self.attr[&#39;display&#39;]
        self.attr[&#39;display&#39;] = display
    if isinstance(q, Queue):
        addToQ = q.enqueue
        removeFromQ = q.dequeue
    elif isinstance(q, Stack):
        addToQ = q.push
        removeFromQ = q.pop
    if priority == &#39;L&#39;:
        first_child = self.get_left_child
        second_child = self.get_right_child
    else:
        first_child = self.get_right_child
        second_child = self.get_left_child
    addToQ(root)
    while not q.isEmpty():
        current = removeFromQ()
        if display:
            self.display(highlight = [current])
        n = first_child(current)
        if n is not None:
            addToQ(n)
        n = second_child(current)
        if n is not None:
            addToQ(n)
    if old_display:
        self.attr[&#39;display&#39;] = old_display</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="coinor.gimpy.tree.Tree" href="#coinor.gimpy.tree.Tree">Tree</a></b></code>:
<ul class="hlist">
<li><code><a title="coinor.gimpy.tree.Tree.add_child" href="#coinor.gimpy.tree.Tree.add_child">add_child</a></code></li>
<li><code><a title="coinor.gimpy.tree.Tree.add_edge" href="graph.html#coinor.gimpy.graph.Graph.add_edge">add_edge</a></code></li>
<li><code><a title="coinor.gimpy.tree.Tree.add_node" href="graph.html#coinor.gimpy.graph.Graph.add_node">add_node</a></code></li>
<li><code><a title="coinor.gimpy.tree.Tree.augment_cycle" href="graph.html#coinor.gimpy.graph.Graph.augment_cycle">augment_cycle</a></code></li>
<li><code><a title="coinor.gimpy.tree.Tree.check_edge" href="graph.html#coinor.gimpy.graph.Graph.check_edge">check_edge</a></code></li>
<li><code><a title="coinor.gimpy.tree.Tree.create" href="graph.html#coinor.gimpy.graph.Graph.create">create</a></code></li>
<li><code><a title="coinor.gimpy.tree.Tree.create_cluster" href="graph.html#coinor.gimpy.graph.Graph.create_cluster">create_cluster</a></code></li>
<li><code><a title="coinor.gimpy.tree.Tree.create_residual_graph" href="graph.html#coinor.gimpy.graph.Graph.create_residual_graph">create_residual_graph</a></code></li>
<li><code><a title="coinor.gimpy.tree.Tree.cycle_canceling" href="graph.html#coinor.gimpy.graph.Graph.cycle_canceling">cycle_canceling</a></code></li>
<li><code><a title="coinor.gimpy.tree.Tree.del_edge" href="graph.html#coinor.gimpy.graph.Graph.del_edge">del_edge</a></code></li>
<li><code><a title="coinor.gimpy.tree.Tree.display" href="graph.html#coinor.gimpy.graph.Graph.display">display</a></code></li>
<li><code><a title="coinor.gimpy.tree.Tree.edge_to_string" href="graph.html#coinor.gimpy.graph.Graph.edge_to_string">edge_to_string</a></code></li>
<li><code><a title="coinor.gimpy.tree.Tree.fifo_label_correcting" href="graph.html#coinor.gimpy.graph.Graph.fifo_label_correcting">fifo_label_correcting</a></code></li>
<li><code><a title="coinor.gimpy.tree.Tree.find_cycle_capacity" href="graph.html#coinor.gimpy.graph.Graph.find_cycle_capacity">find_cycle_capacity</a></code></li>
<li><code><a title="coinor.gimpy.tree.Tree.find_feasible_flow" href="graph.html#coinor.gimpy.graph.Graph.find_feasible_flow">find_feasible_flow</a></code></li>
<li><code><a title="coinor.gimpy.tree.Tree.floyd_warshall" href="graph.html#coinor.gimpy.graph.Graph.floyd_warshall">floyd_warshall</a></code></li>
<li><code><a title="coinor.gimpy.tree.Tree.floyd_warshall_get_cycle" href="graph.html#coinor.gimpy.graph.Graph.floyd_warshall_get_cycle">floyd_warshall_get_cycle</a></code></li>
<li><code><a title="coinor.gimpy.tree.Tree.floyd_warshall_get_path" href="graph.html#coinor.gimpy.graph.Graph.floyd_warshall_get_path">floyd_warshall_get_path</a></code></li>
<li><code><a title="coinor.gimpy.tree.Tree.get_children" href="#coinor.gimpy.tree.Tree.get_children">get_children</a></code></li>
<li><code><a title="coinor.gimpy.tree.Tree.get_degrees" href="graph.html#coinor.gimpy.graph.Graph.get_degrees">get_degrees</a></code></li>
<li><code><a title="coinor.gimpy.tree.Tree.get_diameter" href="graph.html#coinor.gimpy.graph.Graph.get_diameter">get_diameter</a></code></li>
<li><code><a title="coinor.gimpy.tree.Tree.get_edge_attr" href="graph.html#coinor.gimpy.graph.Graph.get_edge_attr">get_edge_attr</a></code></li>
<li><code><a title="coinor.gimpy.tree.Tree.get_edge_cost" href="graph.html#coinor.gimpy.graph.Graph.get_edge_cost">get_edge_cost</a></code></li>
<li><code><a title="coinor.gimpy.tree.Tree.get_edge_list" href="graph.html#coinor.gimpy.graph.Graph.get_edge_list">get_edge_list</a></code></li>
<li><code><a title="coinor.gimpy.tree.Tree.get_edge_num" href="graph.html#coinor.gimpy.graph.Graph.get_edge_num">get_edge_num</a></code></li>
<li><code><a title="coinor.gimpy.tree.Tree.get_in_degrees" href="graph.html#coinor.gimpy.graph.Graph.get_in_degrees">get_in_degrees</a></code></li>
<li><code><a title="coinor.gimpy.tree.Tree.get_in_neighbors" href="graph.html#coinor.gimpy.graph.Graph.get_in_neighbors">get_in_neighbors</a></code></li>
<li><code><a title="coinor.gimpy.tree.Tree.get_layout" href="graph.html#coinor.gimpy.graph.Graph.get_layout">get_layout</a></code></li>
<li><code><a title="coinor.gimpy.tree.Tree.get_negative_cycle" href="graph.html#coinor.gimpy.graph.Graph.get_negative_cycle">get_negative_cycle</a></code></li>
<li><code><a title="coinor.gimpy.tree.Tree.get_neighbors" href="graph.html#coinor.gimpy.graph.Graph.get_neighbors">get_neighbors</a></code></li>
<li><code><a title="coinor.gimpy.tree.Tree.get_node" href="graph.html#coinor.gimpy.graph.Graph.get_node">get_node</a></code></li>
<li><code><a title="coinor.gimpy.tree.Tree.get_node_attr" href="graph.html#coinor.gimpy.graph.Graph.get_node_attr">get_node_attr</a></code></li>
<li><code><a title="coinor.gimpy.tree.Tree.get_node_list" href="graph.html#coinor.gimpy.graph.Graph.get_node_list">get_node_list</a></code></li>
<li><code><a title="coinor.gimpy.tree.Tree.get_node_num" href="graph.html#coinor.gimpy.graph.Graph.get_node_num">get_node_num</a></code></li>
<li><code><a title="coinor.gimpy.tree.Tree.get_out_degrees" href="graph.html#coinor.gimpy.graph.Graph.get_out_degrees">get_out_degrees</a></code></li>
<li><code><a title="coinor.gimpy.tree.Tree.get_out_neighbors" href="graph.html#coinor.gimpy.graph.Graph.get_out_neighbors">get_out_neighbors</a></code></li>
<li><code><a title="coinor.gimpy.tree.Tree.get_parent" href="#coinor.gimpy.tree.Tree.get_parent">get_parent</a></code></li>
<li><code><a title="coinor.gimpy.tree.Tree.get_simplex_solution_graph" href="graph.html#coinor.gimpy.graph.Graph.get_simplex_solution_graph">get_simplex_solution_graph</a></code></li>
<li><code><a title="coinor.gimpy.tree.Tree.label_components" href="graph.html#coinor.gimpy.graph.Graph.label_components">label_components</a></code></li>
<li><code><a title="coinor.gimpy.tree.Tree.label_correcting_check_cycle" href="graph.html#coinor.gimpy.graph.Graph.label_correcting_check_cycle">label_correcting_check_cycle</a></code></li>
<li><code><a title="coinor.gimpy.tree.Tree.label_correcting_get_cycle" href="graph.html#coinor.gimpy.graph.Graph.label_correcting_get_cycle">label_correcting_get_cycle</a></code></li>
<li><code><a title="coinor.gimpy.tree.Tree.label_strong_component" href="graph.html#coinor.gimpy.graph.Graph.label_strong_component">label_strong_component</a></code></li>
<li><code><a title="coinor.gimpy.tree.Tree.max_flow" href="graph.html#coinor.gimpy.graph.Graph.max_flow">max_flow</a></code></li>
<li><code><a title="coinor.gimpy.tree.Tree.max_flow_preflowpush" href="graph.html#coinor.gimpy.graph.Graph.max_flow_preflowpush">max_flow_preflowpush</a></code></li>
<li><code><a title="coinor.gimpy.tree.Tree.min_cost_flow" href="graph.html#coinor.gimpy.graph.Graph.min_cost_flow">min_cost_flow</a></code></li>
<li><code><a title="coinor.gimpy.tree.Tree.minimum_spanning_tree_kruskal" href="graph.html#coinor.gimpy.graph.Graph.minimum_spanning_tree_kruskal">minimum_spanning_tree_kruskal</a></code></li>
<li><code><a title="coinor.gimpy.tree.Tree.minimum_spanning_tree_prim" href="graph.html#coinor.gimpy.graph.Graph.minimum_spanning_tree_prim">minimum_spanning_tree_prim</a></code></li>
<li><code><a title="coinor.gimpy.tree.Tree.network_simplex" href="graph.html#coinor.gimpy.graph.Graph.network_simplex">network_simplex</a></code></li>
<li><code><a title="coinor.gimpy.tree.Tree.page_rank" href="graph.html#coinor.gimpy.graph.Graph.page_rank">page_rank</a></code></li>
<li><code><a title="coinor.gimpy.tree.Tree.print_flow" href="graph.html#coinor.gimpy.graph.Graph.print_flow">print_flow</a></code></li>
<li><code><a title="coinor.gimpy.tree.Tree.process_edge_dijkstra" href="graph.html#coinor.gimpy.graph.Graph.process_edge_dijkstra">process_edge_dijkstra</a></code></li>
<li><code><a title="coinor.gimpy.tree.Tree.process_edge_flow" href="graph.html#coinor.gimpy.graph.Graph.process_edge_flow">process_edge_flow</a></code></li>
<li><code><a title="coinor.gimpy.tree.Tree.process_edge_prim" href="graph.html#coinor.gimpy.graph.Graph.process_edge_prim">process_edge_prim</a></code></li>
<li><code><a title="coinor.gimpy.tree.Tree.process_edge_search" href="graph.html#coinor.gimpy.graph.Graph.process_edge_search">process_edge_search</a></code></li>
<li><code><a title="coinor.gimpy.tree.Tree.process_node_search" href="graph.html#coinor.gimpy.graph.Graph.process_node_search">process_node_search</a></code></li>
<li><code><a title="coinor.gimpy.tree.Tree.random" href="graph.html#coinor.gimpy.graph.Graph.random">random</a></code></li>
<li><code><a title="coinor.gimpy.tree.Tree.relabel" href="graph.html#coinor.gimpy.graph.Graph.relabel">relabel</a></code></li>
<li><code><a title="coinor.gimpy.tree.Tree.search" href="graph.html#coinor.gimpy.graph.Graph.search">search</a></code></li>
<li><code><a title="coinor.gimpy.tree.Tree.set_display_mode" href="graph.html#coinor.gimpy.graph.Graph.set_display_mode">set_display_mode</a></code></li>
<li><code><a title="coinor.gimpy.tree.Tree.set_edge_attr" href="graph.html#coinor.gimpy.graph.Graph.set_edge_attr">set_edge_attr</a></code></li>
<li><code><a title="coinor.gimpy.tree.Tree.set_layout" href="graph.html#coinor.gimpy.graph.Graph.set_layout">set_layout</a></code></li>
<li><code><a title="coinor.gimpy.tree.Tree.set_node_attr" href="graph.html#coinor.gimpy.graph.Graph.set_node_attr">set_node_attr</a></code></li>
<li><code><a title="coinor.gimpy.tree.Tree.show_flow" href="graph.html#coinor.gimpy.graph.Graph.show_flow">show_flow</a></code></li>
<li><code><a title="coinor.gimpy.tree.Tree.simplex_augment_cycle" href="graph.html#coinor.gimpy.graph.Graph.simplex_augment_cycle">simplex_augment_cycle</a></code></li>
<li><code><a title="coinor.gimpy.tree.Tree.simplex_compute_potentials" href="graph.html#coinor.gimpy.graph.Graph.simplex_compute_potentials">simplex_compute_potentials</a></code></li>
<li><code><a title="coinor.gimpy.tree.Tree.simplex_connect" href="graph.html#coinor.gimpy.graph.Graph.simplex_connect">simplex_connect</a></code></li>
<li><code><a title="coinor.gimpy.tree.Tree.simplex_determine_leaving_arc" href="graph.html#coinor.gimpy.graph.Graph.simplex_determine_leaving_arc">simplex_determine_leaving_arc</a></code></li>
<li><code><a title="coinor.gimpy.tree.Tree.simplex_find_cycle" href="graph.html#coinor.gimpy.graph.Graph.simplex_find_cycle">simplex_find_cycle</a></code></li>
<li><code><a title="coinor.gimpy.tree.Tree.simplex_find_tree" href="graph.html#coinor.gimpy.graph.Graph.simplex_find_tree">simplex_find_tree</a></code></li>
<li><code><a title="coinor.gimpy.tree.Tree.simplex_identify_cycle" href="graph.html#coinor.gimpy.graph.Graph.simplex_identify_cycle">simplex_identify_cycle</a></code></li>
<li><code><a title="coinor.gimpy.tree.Tree.simplex_mark_entering_arc" href="graph.html#coinor.gimpy.graph.Graph.simplex_mark_entering_arc">simplex_mark_entering_arc</a></code></li>
<li><code><a title="coinor.gimpy.tree.Tree.simplex_mark_leaving_arc" href="graph.html#coinor.gimpy.graph.Graph.simplex_mark_leaving_arc">simplex_mark_leaving_arc</a></code></li>
<li><code><a title="coinor.gimpy.tree.Tree.simplex_mark_st_arcs" href="graph.html#coinor.gimpy.graph.Graph.simplex_mark_st_arcs">simplex_mark_st_arcs</a></code></li>
<li><code><a title="coinor.gimpy.tree.Tree.simplex_optimal" href="graph.html#coinor.gimpy.graph.Graph.simplex_optimal">simplex_optimal</a></code></li>
<li><code><a title="coinor.gimpy.tree.Tree.simplex_redraw" href="graph.html#coinor.gimpy.graph.Graph.simplex_redraw">simplex_redraw</a></code></li>
<li><code><a title="coinor.gimpy.tree.Tree.simplex_remove_arc" href="graph.html#coinor.gimpy.graph.Graph.simplex_remove_arc">simplex_remove_arc</a></code></li>
<li><code><a title="coinor.gimpy.tree.Tree.simplex_search" href="graph.html#coinor.gimpy.graph.Graph.simplex_search">simplex_search</a></code></li>
<li><code><a title="coinor.gimpy.tree.Tree.simplex_select_entering_arc" href="graph.html#coinor.gimpy.graph.Graph.simplex_select_entering_arc">simplex_select_entering_arc</a></code></li>
<li><code><a title="coinor.gimpy.tree.Tree.strong_connect" href="graph.html#coinor.gimpy.graph.Graph.strong_connect">strong_connect</a></code></li>
<li><code><a title="coinor.gimpy.tree.Tree.tarjan" href="graph.html#coinor.gimpy.graph.Graph.tarjan">tarjan</a></code></li>
<li><code><a title="coinor.gimpy.tree.Tree.to_string" href="graph.html#coinor.gimpy.graph.Graph.to_string">to_string</a></code></li>
<li><code><a title="coinor.gimpy.tree.Tree.write" href="graph.html#coinor.gimpy.graph.Graph.write">write</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="coinor.gimpy.tree.Tree"><code class="flex name class">
<span>class <span class="ident">Tree</span></span>
<span>(</span><span>**attrs)</span>
</code></dt>
<dd>
<div class="desc"><p>Tree class. It inherits from Graph class. Provides DFS, BFS and traverse
methods.</p>
<p>API: <strong>init</strong>(self, **attrs)</p>
<h2 id="description">Description</h2>
<p>Constructor. Sets attrbutes of class using argument.</p>
<h2 id="input">Input</h2>
<p>attrs: Attributes in keyword arguments format.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Tree(Graph):
    &#39;&#39;&#39;
    Tree class. It inherits from Graph class. Provides DFS, BFS and traverse
    methods.
    &#39;&#39;&#39;
    def __init__(self, **attrs):
        &#39;&#39;&#39;
        API: __init__(self, **attrs)
        Description:
            Constructor. Sets attrbutes of class using argument.
        Input:
            attrs: Attributes in keyword arguments format.
        &#39;&#39;&#39;
        attrs[&#39;type&#39;] = DIRECTED_GRAPH
        if &#39;layout&#39; not in attrs:
            attrs[&#39;layout&#39;] = &#39;dot&#39;
        Graph.__init__(self, **attrs)
        self.root = None

    def get_children(self, n):
        &#39;&#39;&#39;
        API: get_children(self, n)
        Description:
            Returns list of children of node n.
        Pre:
            Node with name n should exist.
        Input:
            n: Node name.
        Return:
            Returns list of names of children nodes of n.
        &#39;&#39;&#39;
        return self.get_neighbors(n)

    def get_parent(self, n):
        &#39;&#39;&#39;
        API: get_parent(self, n)
        Description:
            Returns parent node name if n&#39;s parent exists, returns
            None otherwise.
        Pre:
            Node with name n should exist.
        Input:
            n: Node name.
        Return:
            Returns parent name of n if its parent exists, returns None
            otherwise.
        &#39;&#39;&#39;
        n = self.get_node(n)
        return n.get_attr(&#39;parent&#39;)

    def add_root(self, root, **attrs):
        &#39;&#39;&#39;
        API: add_root(self, root, **attrs)
        Description:
            Adds root node to the tree with name root and returns root Node
            instance.
        Input:
            root: Root node name.
            attrs: Root node attributes.
        Post:
            Changes self.root.
        Return:
            Returns root Node instance.
        &#39;&#39;&#39;
        attrs[&#39;level&#39;] = 0
        self.root = self.add_node(root, **attrs)
        return self.root

    def add_child(self, n, parent, **attrs):
        &#39;&#39;&#39;
        API: add_child(self, n, parent, **attrs)
        Description:
            Adds child n to node parent and return Node n.
        Pre:
            Node with name parent should exist.
        Input:
            n: Child node name.
            parent: Parent node name.
            attrs: Attributes of node being added.
        Post:
            Updates Graph related graph data attributes.
        Return:
            Returns n Node instance.
        &#39;&#39;&#39;
        attrs[&#39;level&#39;] = self.get_node(parent).get_attr(&#39;level&#39;) + 1
        attrs[&#39;parent&#39;] = parent
        self.add_node(n, **attrs)
        self.add_edge(parent, n)
        return self.get_node(n)

    def dfs(self, root = None, display = None):
        &#39;&#39;&#39;
        API: dfs(self, root = None, display = None)
        Description:
            Searches tree starting from node named root using depth-first
            strategy if root argument is provided. Starts search from root node
            of the tree otherwise.
        Pre:
            Node indicated by root argument should exist.
        Input:
            root: Starting node name.
            display: Display argument.
        &#39;&#39;&#39;
        if root == None:
            root = self.root
        if display == None:
            display = self.attr[&#39;display&#39;]
        self.traverse(root, display, Stack())

    def bfs(self, root = None, display = None):
        &#39;&#39;&#39;
        API: bfs(self, root = None, display = None)
        Description:
            Searches tree starting from node named root using breadth-first
            strategy if root argument is provided. Starts search from root node
            of the tree otherwise.
        Pre:
            Node indicated by root argument should exist.
        Input:
            root: Starting node name.
            display: Display argument.
        &#39;&#39;&#39;
        if root == None:
            root = self.root
        if display == None:
            display = self.attr[&#39;display&#39;]
        self.traverse(root, display, Queue())

    def traverse(self, root = None, display = None, q = Stack()):
        &#39;&#39;&#39;
        API: traverse(self, root = None, display = None, q = Stack())
        Description:
            Traverses tree starting from node named root. Used strategy (BFS,
            DFS) is controlled by argument q. It is a DFS if q is Queue(), BFS
            if q is Stack(). Starts search from root argument if it is given.
            Starts from root node of the tree otherwise.
        Pre:
            Node indicated by root argument should exist.
        Input:
            root: Starting node name.
            display: Display argument.
            q: Queue data structure instance. It is either a Stack() or
            Queue().
        &#39;&#39;&#39;
        if root == None:
            root = self.root
        if display == None:
            display = self.attr[&#39;display&#39;]
        if isinstance(q, Queue):
            addToQ = q.enqueue
            removeFromQ = q.dequeue
        elif isinstance(q, Stack):
            addToQ = q.push
            removeFromQ = q.pop
        addToQ(root)
        while not q.isEmpty():
            current = removeFromQ()
            #print current
            if display:
                self.display(highlight = [current])
            for n in self.get_children(current):
                addToQ(n)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="coinor.gimpy.graph.Graph" href="graph.html#coinor.gimpy.graph.Graph">Graph</a></li>
</ul>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="coinor.gimpy.tree.BinaryTree" href="#coinor.gimpy.tree.BinaryTree">BinaryTree</a></li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="coinor.gimpy.tree.Tree.add_child"><code class="name flex">
<span>def <span class="ident">add_child</span></span>(<span>self, n, parent, **attrs)</span>
</code></dt>
<dd>
<div class="desc"><p>API: add_child(self, n, parent, **attrs)</p>
<h2 id="description">Description</h2>
<p>Adds child n to node parent and return Node n.</p>
<h2 id="pre">Pre</h2>
<p>Node with name parent should exist.</p>
<h2 id="input">Input</h2>
<p>n: Child node name.
parent: Parent node name.
attrs: Attributes of node being added.</p>
<h2 id="post">Post</h2>
<p>Updates Graph related graph data attributes.</p>
<h2 id="return">Return</h2>
<p>Returns n Node instance.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def add_child(self, n, parent, **attrs):
    &#39;&#39;&#39;
    API: add_child(self, n, parent, **attrs)
    Description:
        Adds child n to node parent and return Node n.
    Pre:
        Node with name parent should exist.
    Input:
        n: Child node name.
        parent: Parent node name.
        attrs: Attributes of node being added.
    Post:
        Updates Graph related graph data attributes.
    Return:
        Returns n Node instance.
    &#39;&#39;&#39;
    attrs[&#39;level&#39;] = self.get_node(parent).get_attr(&#39;level&#39;) + 1
    attrs[&#39;parent&#39;] = parent
    self.add_node(n, **attrs)
    self.add_edge(parent, n)
    return self.get_node(n)</code></pre>
</details>
</dd>
<dt id="coinor.gimpy.tree.Tree.add_root"><code class="name flex">
<span>def <span class="ident">add_root</span></span>(<span>self, root, **attrs)</span>
</code></dt>
<dd>
<div class="desc"><p>API: add_root(self, root, **attrs)</p>
<h2 id="description">Description</h2>
<p>Adds root node to the tree with name root and returns root Node
instance.</p>
<h2 id="input">Input</h2>
<p>root: Root node name.
attrs: Root node attributes.</p>
<h2 id="post">Post</h2>
<p>Changes self.root.</p>
<h2 id="return">Return</h2>
<p>Returns root Node instance.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def add_root(self, root, **attrs):
    &#39;&#39;&#39;
    API: add_root(self, root, **attrs)
    Description:
        Adds root node to the tree with name root and returns root Node
        instance.
    Input:
        root: Root node name.
        attrs: Root node attributes.
    Post:
        Changes self.root.
    Return:
        Returns root Node instance.
    &#39;&#39;&#39;
    attrs[&#39;level&#39;] = 0
    self.root = self.add_node(root, **attrs)
    return self.root</code></pre>
</details>
</dd>
<dt id="coinor.gimpy.tree.Tree.bfs"><code class="name flex">
<span>def <span class="ident">bfs</span></span>(<span>self, root=None, display=None)</span>
</code></dt>
<dd>
<div class="desc"><p>API: bfs(self, root = None, display = None)</p>
<h2 id="description">Description</h2>
<p>Searches tree starting from node named root using breadth-first
strategy if root argument is provided. Starts search from root node
of the tree otherwise.</p>
<h2 id="pre">Pre</h2>
<p>Node indicated by root argument should exist.</p>
<h2 id="input">Input</h2>
<p>root: Starting node name.
display: Display argument.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def bfs(self, root = None, display = None):
    &#39;&#39;&#39;
    API: bfs(self, root = None, display = None)
    Description:
        Searches tree starting from node named root using breadth-first
        strategy if root argument is provided. Starts search from root node
        of the tree otherwise.
    Pre:
        Node indicated by root argument should exist.
    Input:
        root: Starting node name.
        display: Display argument.
    &#39;&#39;&#39;
    if root == None:
        root = self.root
    if display == None:
        display = self.attr[&#39;display&#39;]
    self.traverse(root, display, Queue())</code></pre>
</details>
</dd>
<dt id="coinor.gimpy.tree.Tree.dfs"><code class="name flex">
<span>def <span class="ident">dfs</span></span>(<span>self, root=None, display=None)</span>
</code></dt>
<dd>
<div class="desc"><p>API: dfs(self, root = None, display = None)</p>
<h2 id="description">Description</h2>
<p>Searches tree starting from node named root using depth-first
strategy if root argument is provided. Starts search from root node
of the tree otherwise.</p>
<h2 id="pre">Pre</h2>
<p>Node indicated by root argument should exist.</p>
<h2 id="input">Input</h2>
<p>root: Starting node name.
display: Display argument.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def dfs(self, root = None, display = None):
    &#39;&#39;&#39;
    API: dfs(self, root = None, display = None)
    Description:
        Searches tree starting from node named root using depth-first
        strategy if root argument is provided. Starts search from root node
        of the tree otherwise.
    Pre:
        Node indicated by root argument should exist.
    Input:
        root: Starting node name.
        display: Display argument.
    &#39;&#39;&#39;
    if root == None:
        root = self.root
    if display == None:
        display = self.attr[&#39;display&#39;]
    self.traverse(root, display, Stack())</code></pre>
</details>
</dd>
<dt id="coinor.gimpy.tree.Tree.get_children"><code class="name flex">
<span>def <span class="ident">get_children</span></span>(<span>self, n)</span>
</code></dt>
<dd>
<div class="desc"><p>API: get_children(self, n)</p>
<h2 id="description">Description</h2>
<p>Returns list of children of node n.</p>
<h2 id="pre">Pre</h2>
<p>Node with name n should exist.</p>
<h2 id="input">Input</h2>
<p>n: Node name.</p>
<h2 id="return">Return</h2>
<p>Returns list of names of children nodes of n.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_children(self, n):
    &#39;&#39;&#39;
    API: get_children(self, n)
    Description:
        Returns list of children of node n.
    Pre:
        Node with name n should exist.
    Input:
        n: Node name.
    Return:
        Returns list of names of children nodes of n.
    &#39;&#39;&#39;
    return self.get_neighbors(n)</code></pre>
</details>
</dd>
<dt id="coinor.gimpy.tree.Tree.get_parent"><code class="name flex">
<span>def <span class="ident">get_parent</span></span>(<span>self, n)</span>
</code></dt>
<dd>
<div class="desc"><p>API: get_parent(self, n)</p>
<h2 id="description">Description</h2>
<p>Returns parent node name if n's parent exists, returns
None otherwise.</p>
<h2 id="pre">Pre</h2>
<p>Node with name n should exist.</p>
<h2 id="input">Input</h2>
<p>n: Node name.</p>
<h2 id="return">Return</h2>
<p>Returns parent name of n if its parent exists, returns None
otherwise.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_parent(self, n):
    &#39;&#39;&#39;
    API: get_parent(self, n)
    Description:
        Returns parent node name if n&#39;s parent exists, returns
        None otherwise.
    Pre:
        Node with name n should exist.
    Input:
        n: Node name.
    Return:
        Returns parent name of n if its parent exists, returns None
        otherwise.
    &#39;&#39;&#39;
    n = self.get_node(n)
    return n.get_attr(&#39;parent&#39;)</code></pre>
</details>
</dd>
<dt id="coinor.gimpy.tree.Tree.traverse"><code class="name flex">
<span>def <span class="ident">traverse</span></span>(<span>self, root=None, display=None, q=[])</span>
</code></dt>
<dd>
<div class="desc"><p>API: traverse(self, root = None, display = None, q = Stack())</p>
<h2 id="description">Description</h2>
<p>Traverses tree starting from node named root. Used strategy (BFS,
DFS) is controlled by argument q. It is a DFS if q is Queue(), BFS
if q is Stack(). Starts search from root argument if it is given.
Starts from root node of the tree otherwise.</p>
<h2 id="pre">Pre</h2>
<p>Node indicated by root argument should exist.</p>
<h2 id="input">Input</h2>
<p>root: Starting node name.
display: Display argument.
q: Queue data structure instance. It is either a Stack() or
Queue().</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def traverse(self, root = None, display = None, q = Stack()):
    &#39;&#39;&#39;
    API: traverse(self, root = None, display = None, q = Stack())
    Description:
        Traverses tree starting from node named root. Used strategy (BFS,
        DFS) is controlled by argument q. It is a DFS if q is Queue(), BFS
        if q is Stack(). Starts search from root argument if it is given.
        Starts from root node of the tree otherwise.
    Pre:
        Node indicated by root argument should exist.
    Input:
        root: Starting node name.
        display: Display argument.
        q: Queue data structure instance. It is either a Stack() or
        Queue().
    &#39;&#39;&#39;
    if root == None:
        root = self.root
    if display == None:
        display = self.attr[&#39;display&#39;]
    if isinstance(q, Queue):
        addToQ = q.enqueue
        removeFromQ = q.dequeue
    elif isinstance(q, Stack):
        addToQ = q.push
        removeFromQ = q.pop
    addToQ(root)
    while not q.isEmpty():
        current = removeFromQ()
        #print current
        if display:
            self.display(highlight = [current])
        for n in self.get_children(current):
            addToQ(n)</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="coinor.gimpy.graph.Graph" href="graph.html#coinor.gimpy.graph.Graph">Graph</a></b></code>:
<ul class="hlist">
<li><code><a title="coinor.gimpy.graph.Graph.add_edge" href="graph.html#coinor.gimpy.graph.Graph.add_edge">add_edge</a></code></li>
<li><code><a title="coinor.gimpy.graph.Graph.add_node" href="graph.html#coinor.gimpy.graph.Graph.add_node">add_node</a></code></li>
<li><code><a title="coinor.gimpy.graph.Graph.augment_cycle" href="graph.html#coinor.gimpy.graph.Graph.augment_cycle">augment_cycle</a></code></li>
<li><code><a title="coinor.gimpy.graph.Graph.check_edge" href="graph.html#coinor.gimpy.graph.Graph.check_edge">check_edge</a></code></li>
<li><code><a title="coinor.gimpy.graph.Graph.create" href="graph.html#coinor.gimpy.graph.Graph.create">create</a></code></li>
<li><code><a title="coinor.gimpy.graph.Graph.create_cluster" href="graph.html#coinor.gimpy.graph.Graph.create_cluster">create_cluster</a></code></li>
<li><code><a title="coinor.gimpy.graph.Graph.create_residual_graph" href="graph.html#coinor.gimpy.graph.Graph.create_residual_graph">create_residual_graph</a></code></li>
<li><code><a title="coinor.gimpy.graph.Graph.cycle_canceling" href="graph.html#coinor.gimpy.graph.Graph.cycle_canceling">cycle_canceling</a></code></li>
<li><code><a title="coinor.gimpy.graph.Graph.del_edge" href="graph.html#coinor.gimpy.graph.Graph.del_edge">del_edge</a></code></li>
<li><code><a title="coinor.gimpy.graph.Graph.del_node" href="graph.html#coinor.gimpy.graph.Graph.del_node">del_node</a></code></li>
<li><code><a title="coinor.gimpy.graph.Graph.display" href="graph.html#coinor.gimpy.graph.Graph.display">display</a></code></li>
<li><code><a title="coinor.gimpy.graph.Graph.edge_to_string" href="graph.html#coinor.gimpy.graph.Graph.edge_to_string">edge_to_string</a></code></li>
<li><code><a title="coinor.gimpy.graph.Graph.fifo_label_correcting" href="graph.html#coinor.gimpy.graph.Graph.fifo_label_correcting">fifo_label_correcting</a></code></li>
<li><code><a title="coinor.gimpy.graph.Graph.find_cycle_capacity" href="graph.html#coinor.gimpy.graph.Graph.find_cycle_capacity">find_cycle_capacity</a></code></li>
<li><code><a title="coinor.gimpy.graph.Graph.find_feasible_flow" href="graph.html#coinor.gimpy.graph.Graph.find_feasible_flow">find_feasible_flow</a></code></li>
<li><code><a title="coinor.gimpy.graph.Graph.floyd_warshall" href="graph.html#coinor.gimpy.graph.Graph.floyd_warshall">floyd_warshall</a></code></li>
<li><code><a title="coinor.gimpy.graph.Graph.floyd_warshall_get_cycle" href="graph.html#coinor.gimpy.graph.Graph.floyd_warshall_get_cycle">floyd_warshall_get_cycle</a></code></li>
<li><code><a title="coinor.gimpy.graph.Graph.floyd_warshall_get_path" href="graph.html#coinor.gimpy.graph.Graph.floyd_warshall_get_path">floyd_warshall_get_path</a></code></li>
<li><code><a title="coinor.gimpy.graph.Graph.get_degrees" href="graph.html#coinor.gimpy.graph.Graph.get_degrees">get_degrees</a></code></li>
<li><code><a title="coinor.gimpy.graph.Graph.get_diameter" href="graph.html#coinor.gimpy.graph.Graph.get_diameter">get_diameter</a></code></li>
<li><code><a title="coinor.gimpy.graph.Graph.get_edge_attr" href="graph.html#coinor.gimpy.graph.Graph.get_edge_attr">get_edge_attr</a></code></li>
<li><code><a title="coinor.gimpy.graph.Graph.get_edge_cost" href="graph.html#coinor.gimpy.graph.Graph.get_edge_cost">get_edge_cost</a></code></li>
<li><code><a title="coinor.gimpy.graph.Graph.get_edge_list" href="graph.html#coinor.gimpy.graph.Graph.get_edge_list">get_edge_list</a></code></li>
<li><code><a title="coinor.gimpy.graph.Graph.get_edge_num" href="graph.html#coinor.gimpy.graph.Graph.get_edge_num">get_edge_num</a></code></li>
<li><code><a title="coinor.gimpy.graph.Graph.get_in_degrees" href="graph.html#coinor.gimpy.graph.Graph.get_in_degrees">get_in_degrees</a></code></li>
<li><code><a title="coinor.gimpy.graph.Graph.get_in_neighbors" href="graph.html#coinor.gimpy.graph.Graph.get_in_neighbors">get_in_neighbors</a></code></li>
<li><code><a title="coinor.gimpy.graph.Graph.get_layout" href="graph.html#coinor.gimpy.graph.Graph.get_layout">get_layout</a></code></li>
<li><code><a title="coinor.gimpy.graph.Graph.get_negative_cycle" href="graph.html#coinor.gimpy.graph.Graph.get_negative_cycle">get_negative_cycle</a></code></li>
<li><code><a title="coinor.gimpy.graph.Graph.get_neighbors" href="graph.html#coinor.gimpy.graph.Graph.get_neighbors">get_neighbors</a></code></li>
<li><code><a title="coinor.gimpy.graph.Graph.get_node" href="graph.html#coinor.gimpy.graph.Graph.get_node">get_node</a></code></li>
<li><code><a title="coinor.gimpy.graph.Graph.get_node_attr" href="graph.html#coinor.gimpy.graph.Graph.get_node_attr">get_node_attr</a></code></li>
<li><code><a title="coinor.gimpy.graph.Graph.get_node_list" href="graph.html#coinor.gimpy.graph.Graph.get_node_list">get_node_list</a></code></li>
<li><code><a title="coinor.gimpy.graph.Graph.get_node_num" href="graph.html#coinor.gimpy.graph.Graph.get_node_num">get_node_num</a></code></li>
<li><code><a title="coinor.gimpy.graph.Graph.get_out_degrees" href="graph.html#coinor.gimpy.graph.Graph.get_out_degrees">get_out_degrees</a></code></li>
<li><code><a title="coinor.gimpy.graph.Graph.get_out_neighbors" href="graph.html#coinor.gimpy.graph.Graph.get_out_neighbors">get_out_neighbors</a></code></li>
<li><code><a title="coinor.gimpy.graph.Graph.get_simplex_solution_graph" href="graph.html#coinor.gimpy.graph.Graph.get_simplex_solution_graph">get_simplex_solution_graph</a></code></li>
<li><code><a title="coinor.gimpy.graph.Graph.label_components" href="graph.html#coinor.gimpy.graph.Graph.label_components">label_components</a></code></li>
<li><code><a title="coinor.gimpy.graph.Graph.label_correcting_check_cycle" href="graph.html#coinor.gimpy.graph.Graph.label_correcting_check_cycle">label_correcting_check_cycle</a></code></li>
<li><code><a title="coinor.gimpy.graph.Graph.label_correcting_get_cycle" href="graph.html#coinor.gimpy.graph.Graph.label_correcting_get_cycle">label_correcting_get_cycle</a></code></li>
<li><code><a title="coinor.gimpy.graph.Graph.label_strong_component" href="graph.html#coinor.gimpy.graph.Graph.label_strong_component">label_strong_component</a></code></li>
<li><code><a title="coinor.gimpy.graph.Graph.max_flow" href="graph.html#coinor.gimpy.graph.Graph.max_flow">max_flow</a></code></li>
<li><code><a title="coinor.gimpy.graph.Graph.max_flow_preflowpush" href="graph.html#coinor.gimpy.graph.Graph.max_flow_preflowpush">max_flow_preflowpush</a></code></li>
<li><code><a title="coinor.gimpy.graph.Graph.min_cost_flow" href="graph.html#coinor.gimpy.graph.Graph.min_cost_flow">min_cost_flow</a></code></li>
<li><code><a title="coinor.gimpy.graph.Graph.minimum_spanning_tree_kruskal" href="graph.html#coinor.gimpy.graph.Graph.minimum_spanning_tree_kruskal">minimum_spanning_tree_kruskal</a></code></li>
<li><code><a title="coinor.gimpy.graph.Graph.minimum_spanning_tree_prim" href="graph.html#coinor.gimpy.graph.Graph.minimum_spanning_tree_prim">minimum_spanning_tree_prim</a></code></li>
<li><code><a title="coinor.gimpy.graph.Graph.network_simplex" href="graph.html#coinor.gimpy.graph.Graph.network_simplex">network_simplex</a></code></li>
<li><code><a title="coinor.gimpy.graph.Graph.page_rank" href="graph.html#coinor.gimpy.graph.Graph.page_rank">page_rank</a></code></li>
<li><code><a title="coinor.gimpy.graph.Graph.print_flow" href="graph.html#coinor.gimpy.graph.Graph.print_flow">print_flow</a></code></li>
<li><code><a title="coinor.gimpy.graph.Graph.process_edge_dijkstra" href="graph.html#coinor.gimpy.graph.Graph.process_edge_dijkstra">process_edge_dijkstra</a></code></li>
<li><code><a title="coinor.gimpy.graph.Graph.process_edge_flow" href="graph.html#coinor.gimpy.graph.Graph.process_edge_flow">process_edge_flow</a></code></li>
<li><code><a title="coinor.gimpy.graph.Graph.process_edge_prim" href="graph.html#coinor.gimpy.graph.Graph.process_edge_prim">process_edge_prim</a></code></li>
<li><code><a title="coinor.gimpy.graph.Graph.process_edge_search" href="graph.html#coinor.gimpy.graph.Graph.process_edge_search">process_edge_search</a></code></li>
<li><code><a title="coinor.gimpy.graph.Graph.process_node_search" href="graph.html#coinor.gimpy.graph.Graph.process_node_search">process_node_search</a></code></li>
<li><code><a title="coinor.gimpy.graph.Graph.random" href="graph.html#coinor.gimpy.graph.Graph.random">random</a></code></li>
<li><code><a title="coinor.gimpy.graph.Graph.relabel" href="graph.html#coinor.gimpy.graph.Graph.relabel">relabel</a></code></li>
<li><code><a title="coinor.gimpy.graph.Graph.search" href="graph.html#coinor.gimpy.graph.Graph.search">search</a></code></li>
<li><code><a title="coinor.gimpy.graph.Graph.set_display_mode" href="graph.html#coinor.gimpy.graph.Graph.set_display_mode">set_display_mode</a></code></li>
<li><code><a title="coinor.gimpy.graph.Graph.set_edge_attr" href="graph.html#coinor.gimpy.graph.Graph.set_edge_attr">set_edge_attr</a></code></li>
<li><code><a title="coinor.gimpy.graph.Graph.set_layout" href="graph.html#coinor.gimpy.graph.Graph.set_layout">set_layout</a></code></li>
<li><code><a title="coinor.gimpy.graph.Graph.set_node_attr" href="graph.html#coinor.gimpy.graph.Graph.set_node_attr">set_node_attr</a></code></li>
<li><code><a title="coinor.gimpy.graph.Graph.show_flow" href="graph.html#coinor.gimpy.graph.Graph.show_flow">show_flow</a></code></li>
<li><code><a title="coinor.gimpy.graph.Graph.simplex_augment_cycle" href="graph.html#coinor.gimpy.graph.Graph.simplex_augment_cycle">simplex_augment_cycle</a></code></li>
<li><code><a title="coinor.gimpy.graph.Graph.simplex_compute_potentials" href="graph.html#coinor.gimpy.graph.Graph.simplex_compute_potentials">simplex_compute_potentials</a></code></li>
<li><code><a title="coinor.gimpy.graph.Graph.simplex_connect" href="graph.html#coinor.gimpy.graph.Graph.simplex_connect">simplex_connect</a></code></li>
<li><code><a title="coinor.gimpy.graph.Graph.simplex_determine_leaving_arc" href="graph.html#coinor.gimpy.graph.Graph.simplex_determine_leaving_arc">simplex_determine_leaving_arc</a></code></li>
<li><code><a title="coinor.gimpy.graph.Graph.simplex_find_cycle" href="graph.html#coinor.gimpy.graph.Graph.simplex_find_cycle">simplex_find_cycle</a></code></li>
<li><code><a title="coinor.gimpy.graph.Graph.simplex_find_tree" href="graph.html#coinor.gimpy.graph.Graph.simplex_find_tree">simplex_find_tree</a></code></li>
<li><code><a title="coinor.gimpy.graph.Graph.simplex_identify_cycle" href="graph.html#coinor.gimpy.graph.Graph.simplex_identify_cycle">simplex_identify_cycle</a></code></li>
<li><code><a title="coinor.gimpy.graph.Graph.simplex_mark_entering_arc" href="graph.html#coinor.gimpy.graph.Graph.simplex_mark_entering_arc">simplex_mark_entering_arc</a></code></li>
<li><code><a title="coinor.gimpy.graph.Graph.simplex_mark_leaving_arc" href="graph.html#coinor.gimpy.graph.Graph.simplex_mark_leaving_arc">simplex_mark_leaving_arc</a></code></li>
<li><code><a title="coinor.gimpy.graph.Graph.simplex_mark_st_arcs" href="graph.html#coinor.gimpy.graph.Graph.simplex_mark_st_arcs">simplex_mark_st_arcs</a></code></li>
<li><code><a title="coinor.gimpy.graph.Graph.simplex_optimal" href="graph.html#coinor.gimpy.graph.Graph.simplex_optimal">simplex_optimal</a></code></li>
<li><code><a title="coinor.gimpy.graph.Graph.simplex_redraw" href="graph.html#coinor.gimpy.graph.Graph.simplex_redraw">simplex_redraw</a></code></li>
<li><code><a title="coinor.gimpy.graph.Graph.simplex_remove_arc" href="graph.html#coinor.gimpy.graph.Graph.simplex_remove_arc">simplex_remove_arc</a></code></li>
<li><code><a title="coinor.gimpy.graph.Graph.simplex_search" href="graph.html#coinor.gimpy.graph.Graph.simplex_search">simplex_search</a></code></li>
<li><code><a title="coinor.gimpy.graph.Graph.simplex_select_entering_arc" href="graph.html#coinor.gimpy.graph.Graph.simplex_select_entering_arc">simplex_select_entering_arc</a></code></li>
<li><code><a title="coinor.gimpy.graph.Graph.strong_connect" href="graph.html#coinor.gimpy.graph.Graph.strong_connect">strong_connect</a></code></li>
<li><code><a title="coinor.gimpy.graph.Graph.tarjan" href="graph.html#coinor.gimpy.graph.Graph.tarjan">tarjan</a></code></li>
<li><code><a title="coinor.gimpy.graph.Graph.to_string" href="graph.html#coinor.gimpy.graph.Graph.to_string">to_string</a></code></li>
<li><code><a title="coinor.gimpy.graph.Graph.write" href="graph.html#coinor.gimpy.graph.Graph.write">write</a></code></li>
</ul>
</li>
</ul>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="coinor.gimpy" href="index.html">coinor.gimpy</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="coinor.gimpy.tree.BinaryTree" href="#coinor.gimpy.tree.BinaryTree">BinaryTree</a></code></h4>
<ul class="two-column">
<li><code><a title="coinor.gimpy.tree.BinaryTree.add_left_child" href="#coinor.gimpy.tree.BinaryTree.add_left_child">add_left_child</a></code></li>
<li><code><a title="coinor.gimpy.tree.BinaryTree.add_right_child" href="#coinor.gimpy.tree.BinaryTree.add_right_child">add_right_child</a></code></li>
<li><code><a title="coinor.gimpy.tree.BinaryTree.add_root" href="#coinor.gimpy.tree.BinaryTree.add_root">add_root</a></code></li>
<li><code><a title="coinor.gimpy.tree.BinaryTree.bfs" href="#coinor.gimpy.tree.BinaryTree.bfs">bfs</a></code></li>
<li><code><a title="coinor.gimpy.tree.BinaryTree.del_node" href="#coinor.gimpy.tree.BinaryTree.del_node">del_node</a></code></li>
<li><code><a title="coinor.gimpy.tree.BinaryTree.dfs" href="#coinor.gimpy.tree.BinaryTree.dfs">dfs</a></code></li>
<li><code><a title="coinor.gimpy.tree.BinaryTree.get_left_child" href="#coinor.gimpy.tree.BinaryTree.get_left_child">get_left_child</a></code></li>
<li><code><a title="coinor.gimpy.tree.BinaryTree.get_right_child" href="#coinor.gimpy.tree.BinaryTree.get_right_child">get_right_child</a></code></li>
<li><code><a title="coinor.gimpy.tree.BinaryTree.postordereval" href="#coinor.gimpy.tree.BinaryTree.postordereval">postordereval</a></code></li>
<li><code><a title="coinor.gimpy.tree.BinaryTree.print_nodes" href="#coinor.gimpy.tree.BinaryTree.print_nodes">print_nodes</a></code></li>
<li><code><a title="coinor.gimpy.tree.BinaryTree.printexp" href="#coinor.gimpy.tree.BinaryTree.printexp">printexp</a></code></li>
<li><code><a title="coinor.gimpy.tree.BinaryTree.traverse" href="#coinor.gimpy.tree.BinaryTree.traverse">traverse</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="coinor.gimpy.tree.Tree" href="#coinor.gimpy.tree.Tree">Tree</a></code></h4>
<ul class="two-column">
<li><code><a title="coinor.gimpy.tree.Tree.add_child" href="#coinor.gimpy.tree.Tree.add_child">add_child</a></code></li>
<li><code><a title="coinor.gimpy.tree.Tree.add_root" href="#coinor.gimpy.tree.Tree.add_root">add_root</a></code></li>
<li><code><a title="coinor.gimpy.tree.Tree.bfs" href="#coinor.gimpy.tree.Tree.bfs">bfs</a></code></li>
<li><code><a title="coinor.gimpy.tree.Tree.dfs" href="#coinor.gimpy.tree.Tree.dfs">dfs</a></code></li>
<li><code><a title="coinor.gimpy.tree.Tree.get_children" href="#coinor.gimpy.tree.Tree.get_children">get_children</a></code></li>
<li><code><a title="coinor.gimpy.tree.Tree.get_parent" href="#coinor.gimpy.tree.Tree.get_parent">get_parent</a></code></li>
<li><code><a title="coinor.gimpy.tree.Tree.traverse" href="#coinor.gimpy.tree.Tree.traverse">traverse</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc"><cite>pdoc</cite> 0.9.2</a>.</p>
</footer>
</body>
</html>