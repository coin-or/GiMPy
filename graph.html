<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.9.2" />
<title>coinor.gimpy.graph API documentation</title>
<meta name="description" content="A Graph class implementation. The aim for this implementation is
1. To reflect implementation methods in literature as much as possible
3. To have â€¦" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>coinor.gimpy.graph</code></h1>
</header>
<section id="section-intro">
<p>A Graph class implementation. The aim for this implementation is
1. To reflect implementation methods in literature as much as possible
3. To have something close to a "classic" object-oriented design
(compared to previous versions)</p>
<p>This implementation can be considered as a compromise between a graph
class designed for visualization and an efficient graph data structure.</p>
<p>One deviation from standard Graph implementations is to keep in neighbors in
an other adjacency list. We do this for efficiency reasons considering
traversing residual graphs.</p>
<p>We have a class for Graph and a class for Node. Edges are not represented as
objects. They are kept in a dictionary which also keeps their attributes.</p>
<p>Graph display related methods are inspired from Pydot. They are re-written
considering GIMPy needs. We also borrow two methods from Pydot, see
global_constants.py for details.</p>
<p>Default graph type is an undirected graph.</p>
<p>No custom exception will raise when the user tries to get in_neighbors of an
undirected graph. She should be aware of this. Python will raise an exception
since user is trying to read an attribute that does not exits.</p>
<p>Methods that implement algorithms has display argument in their API. If this
argument is not specified global display setting will be used for display
purposes of the algorithm method implements. You can use display argument to
get visualization of algorithm without changing global display behavior of your
Graph/Tree object.</p>
<p>Method documentation strings are orginized as follows.
API: method_name(arguments)
Description: Description of the method.
Input: Arguments and their explanation.
Pre: Necessary class attributes that should exists, methods to be called
before this method.
Post: Class attributes changed within the method.
Return: Return value of the method.</p>
<p>TODO(aykut):
-&gt; svg display mode
-&gt; label_strong_components() API change. Check backward compatibilty.
-&gt; dfs should use search()?
-&gt; display mode svg is not supported.
future:
-&gt; The solution we find is not strongly feasible. Fix this.</p>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">&#39;&#39;&#39;
A Graph class implementation. The aim for this implementation is
1. To reflect implementation methods in literature as much as possible
3. To have something close to a &#34;classic&#34; object-oriented design
(compared to previous versions)

This implementation can be considered as a compromise between a graph
class designed for visualization and an efficient graph data structure.

One deviation from standard Graph implementations is to keep in neighbors in
an other adjacency list. We do this for efficiency reasons considering
traversing residual graphs.

We have a class for Graph and a class for Node. Edges are not represented as
objects. They are kept in a dictionary which also keeps their attributes.

Graph display related methods are inspired from Pydot. They are re-written
considering GIMPy needs. We also borrow two methods from Pydot, see
global_constants.py for details.

Default graph type is an undirected graph.

No custom exception will raise when the user tries to get in_neighbors of an
undirected graph. She should be aware of this. Python will raise an exception
since user is trying to read an attribute that does not exits.

Methods that implement algorithms has display argument in their API. If this
argument is not specified global display setting will be used for display
purposes of the algorithm method implements. You can use display argument to
get visualization of algorithm without changing global display behavior of your
Graph/Tree object.

Method documentation strings are orginized as follows.
API: method_name(arguments)
Description: Description of the method.
Input: Arguments and their explanation.
Pre: Necessary class attributes that should exists, methods to be called
     before this method.
Post: Class attributes changed within the method.
Return: Return value of the method.

TODO(aykut):
-&gt; svg display mode
-&gt; label_strong_components() API change. Check backward compatibilty.
-&gt; dfs should use search()?
-&gt; display mode svg is not supported.
future:
-&gt; The solution we find is not strongly feasible. Fix this.
&#39;&#39;&#39;
from __future__ import division
from __future__ import print_function
from __future__ import absolute_import
from future import standard_library
standard_library.install_aliases()
from builtins import str
from builtins import range
from past.utils import old_div
from builtins import object

from .global_constants import *
try:
    from src.blimpy import Stack, Queue, PriorityQueue
except ImportError:
    from coinor.blimpy import Stack, Queue, PriorityQueue
import subprocess # for call()
import io   # for StringIO()
import copy       # for deepcopy()
import sys        # for exit()
import random     # for seed, random, randint
import tempfile   # for mkstemp()
import os         # for close()
import operator   # for itemgetter()

try:
    import pygtk
    import gtk
    import xdot
except ImportError:
    XDOT_INSTALLED = False
else:
    XDOT_INSTALLED = True

try:
    import dot2tex # for dot2tex method
except ImportError:
    DOT2TEX_INSTALLED = False
else:
    DOT2TEX_INSTALLED = True

try:
    from PIL import Image as PIL_Image
except ImportError:
    PIL_INSTALLED = False
else:
    PIL_INSTALLED = True

try:
    import matplotlib
except ImportError:
    MATPLOTLIB_INSTALLED = False
else:
    MATPLOTLIB_INSTALLED = True
#    matplotlib.use(&#39;TkAgg&#39;)
    import matplotlib.pyplot as plt
    plt.rcParams[&#39;figure.dpi&#39;] = 300

def handle_close(evt):
    print(&#39;Figure closed. Exiting!&#39;)
    plt.close(&#39;all&#39;)

class Node(object):
    &#39;&#39;&#39;
    Node class. A node object keeps node attributes. Has a method to write
    node in Dot language grammer.
    &#39;&#39;&#39;
    def __init__(self, name, **attr):
        &#39;&#39;&#39;
        API: __init__(self, name, **attrs)
        Description:
        Node class constructor. Sets name and attributes using arguments.
        Input:
            name: Name of node.
            **attrs: Node attributes.
        Post:
            Sets self.name and self.attr.
        &#39;&#39;&#39;
        self.name = name
        self.attr = copy.deepcopy(DEFAULT_NODE_ATTRIBUTES)
        for a in attr:
            self.attr[a] = attr[a]

    def get_attr(self, attr):
        &#39;&#39;&#39;
        API: get_attr(self, attr)
        Description:
        Returns node attribute attr.
        Input:
            attr: Node attribute to get.
        Return:
            Returns Node attribute attr if exists returns None, otherwise.
        &#39;&#39;&#39;
        if attr in self.attr:
            return self.attr[attr]
        else:
            return None

    def set_attr(self, attr, value):
        &#39;&#39;&#39;
        API: set_attr(self, attr, value)
        Description:
        Sets node attribute attr to value.
        Input:
            attr: Node attribute to set.
            value: New value of the attribute.
        Post:
            Updates self.attr[attr].
        &#39;&#39;&#39;
        self.attr[attr] = value

    def to_string(self):
        &#39;&#39;&#39;
        API: to_string(self)
        Description:
        Returns string representation of node in dot language.
        Return:
            String representation of node.
        &#39;&#39;&#39;
        node = list()
        node.append(quote_if_necessary(str(self.name)))
        node.append(&#39; [&#39;)
        flag = False
        for a in self.attr:
            flag = True
            node.append(a)
            node.append(&#39;=&#39;)
            node.append(quote_if_necessary(str(self.attr[a])))
            node.append(&#39;, &#39;)
        if flag is True:
            node = node[:-1]
        node.append(&#39;]&#39;)
        return &#39;&#39;.join(node)

    def __repr__(self):
        &#39;&#39;&#39;
        API: __repr__(self)
        Description:
        Returns string representation of node in dot language.
        Return:
            String representation of node.
        &#39;&#39;&#39;
        return self.to_string()


class Graph(object):
    &#39;&#39;&#39;
    Graph class, implemented using adjacency list. See GIMPy README for more
    information.
    &#39;&#39;&#39;
    def __init__(self, **attr):
        &#39;&#39;&#39;
        API: __init__(self, **attrs)
        Description:
        Graph class constructor. Sets attributes using argument.
        Input:
            **attrs: Graph attributes.
        Post:
            Sets following attributes using **attrs; self.attr,
            self.graph_type. Creates following initial attributes;
            self.neighbors, self.in_neighbors, self.nodes, self.out_neighbors,
            self.cluster
        &#39;&#39;&#39;
        # graph attributes
        self.attr = copy.deepcopy(DEFAULT_GRAPH_ATTRIBUTES)
        # set attributes using constructor
        for a in attr:
            self.attr[a] = attr[a]
        # set name
        if &#39;name&#39; in self.attr:
            self.name = self.attr[&#39;name&#39;]
        else:
            self.name = &#39;G&#39;
        # edge attributes
        self.edge_attr = dict()
        # we treat type attribute and keep it in a separate class attribute
        if &#39;type&#39; in self.attr:
            self.graph_type = self.attr[&#39;type&#39;]
        else:
            self.graph_type = UNDIRECTED_GRAPH
        # adjacency list of nodes, it is a dictionary of lists
        self.neighbors = {}
        # if the graph is undirected we do not need in_neighbor
        if self.graph_type is DIRECTED_GRAPH:
            self.in_neighbors = {}
        self.nodes = {}
        self.edge_connect_symbol = EDGE_CONNECT_SYMBOL[self.graph_type]
        self.out_neighbors = self.neighbors
        if &#39;display&#39; not in self.attr:
            self.attr[&#39;display&#39;]=&#39;off&#39;
        if &#39;layout&#39; not in self.attr:
            self.attr[&#39;layout&#39;] = &#39;fdp&#39;
        self.attr[&#39;cluster_count&#39;] = 0
        self.cluster = {}

    def __repr__(self):
        &#39;&#39;&#39;
        API: __repr__(self)
        Description:
        Returns string representation of the graph.
        Return:
            String representation of the graph.
        &#39;&#39;&#39;
        data = str()
        for n in self.nodes:
            data += str(n)
            data += &#39; -&gt; &#39;
            data += self.neighbors[n].__repr__()
            data += &#39;\n&#39;
        data = data[:-1]
        return data

    def __contains__(self, item):
        &#39;&#39;&#39;
        API: __contains__(self, item)
        Description:
        Return true if item is in graph. item can be a node name or a tuple
        that represents an edge.
        Return:
            True if item is in graph.
        &#39;&#39;&#39;
        if isinstance(item, tuple):
            name1 = item[0]
            name2 = item[1]
            if self.graph_type is DIRECTED_GRAPH:
                return (name1, name2) in self.edge_attr
            else:
                return ((name1, name2) in self.edge_attr or
                        (name2, name1) in self.edge_attr)
        else:
            return item in self.nodes

    def add_node(self, name, **attr):
        &#39;&#39;&#39;
        API: add_node(self, name, **attr)
        Description:
        Adds node to the graph.
        Pre:
            Graph should not contain a node with this name. We do not allow
            multiple nodes with the same name.
        Input:
            name: Name of the node.
            attr: Node attributes.
        Post:
            self.neighbors, self.nodes and self.in_neighbors are updated.
        Return:
            Node (a Node class instance) added to the graph.
        &#39;&#39;&#39;
        if name in self.neighbors:
            raise MultipleNodeException
        self.neighbors[name] = list()
        if self.graph_type is DIRECTED_GRAPH:
            self.in_neighbors[name] = list()
        self.nodes[name] = Node(name, **attr)
        return self.nodes[name]

    def del_node(self, name):
        &#39;&#39;&#39;
        API: del_node(self, name)
        Description:
        Removes node from Graph.
        Input:
            name: Name of the node.
        Pre:
            Graph should contain a node with this name.
        Post:
            self.neighbors, self.nodes and self.in_neighbors are updated.
        &#39;&#39;&#39;
        if name not in self.neighbors:
            raise Exception(&#39;Node %s does not exist!&#39; %str(name))
        for n in self.neighbors[name]:
            del self.edge_attr[(name, n)]
            if self.graph_type == UNDIRECTED_GRAPH:
                self.neighbors[n].remove(name)
            else:
                self.in_neighbors[n].remove(name)
        if self.graph_type is DIRECTED_GRAPH:
            for n in self.in_neighbors[name]:
                del self.edge_attr[(n, name)]
                self.neighbors[n].remove(name)
        del self.neighbors[name]
        del self.in_neighbors[name]
        del self.nodes[name]

    def add_edge(self, name1, name2, **attr):
        &#39;&#39;&#39;
        API: add_edge(self, name1, name2, **attr)
        Description:
        Adds edge to the graph. Sets edge attributes using attr argument.
        Input:
            name1: Name of the source node (if directed).
            name2: Name of the sink node (if directed).
            attr: Edge attributes.
        Pre:
            Graph should not already contain this edge. We do not allow
            multiple edges with same source and sink nodes.
        Post:
            self.edge_attr is updated.
            self.neighbors, self.nodes and self.in_neighbors are updated if
            graph was missing at least one of the nodes.
        &#39;&#39;&#39;
        if (name1, name2) in self.edge_attr:
            raise MultipleEdgeException
        if self.graph_type is UNDIRECTED_GRAPH and (name2,name1) in self.edge_attr:
            raise MultipleEdgeException
        self.edge_attr[(name1,name2)] = copy.deepcopy(DEFAULT_EDGE_ATTRIBUTES)
        for a in attr:
            self.edge_attr[(name1,name2)][a] = attr[a]
        if name1 not in self.nodes:
            self.add_node(name1)
        if name2 not in self.nodes:
            self.add_node(name2)
        self.neighbors[name1].append(name2)
        if self.graph_type is UNDIRECTED_GRAPH:
            self.neighbors[name2].append(name1)
        else:
            self.in_neighbors[name2].append(name1)

    def del_edge(self, e):
        &#39;&#39;&#39;
        API: del_edge(self, e)
        Description:
        Removes edge from graph.
        Input:
            e: Tuple that represents edge, in (source,sink) form.
        Pre:
            Graph should contain this edge.
        Post:
            self.edge_attr, self.neighbors and self.in_neighbors are updated.
        &#39;&#39;&#39;
        if self.graph_type is DIRECTED_GRAPH:
            try:
                del self.edge_attr[e]
            except KeyError:
                raise Exception(&#39;Edge %s does not exists!&#39; %str(e))
            self.neighbors[e[0]].remove(e[1])
            self.in_neighbors[e[1]].remove(e[0])
        else:
            try:
                del self.edge_attr[e]
            except KeyError:
                try:
                    del self.edge_attr[(e[1],e[0])]
                except KeyError:
                    raise Exception(&#39;Edge %s does not exists!&#39; %str(e))
            self.neighbors[e[0]].remove(e[1])
            self.neighbors[e[1]].remove(e[0])

    def get_node(self, name):
        &#39;&#39;&#39;
        API: get_node(self, name)
        Description:
        Returns node object with the provided name.
        Input:
            name: Name of the node.
        Return:
            Returns node object if node exists, returns None otherwise.
        &#39;&#39;&#39;
        if name in self.nodes:
            return self.nodes[name]
        else:
            return None

    def get_edge_cost(self, edge):
        &#39;&#39;&#39;
        API: get_edge_cost(self, edge)
        Description:
        Returns cost attr of edge, required for minimum_spanning_tree_kruskal().
        Input:
            edge: Tuple that represents edge, in (source,sink) form.
        Return:
            Returns cost attribute value of the edge.
        &#39;&#39;&#39;
        return self.get_edge_attr(edge[0], edge[1], &#39;cost&#39;)

    def check_edge(self, name1, name2):
        &#39;&#39;&#39;
        API: check_edge(self, name1, name2)
        Description:
        Return True if edge exists, False otherwise.
        Input:
            name1: name of the source node.
            name2: name of the sink node.
        Return:
            Returns True if edge exists, False otherwise.
        &#39;&#39;&#39;
        if self.graph_type is DIRECTED_GRAPH:
            return (name1, name2) in self.edge_attr
        else:
            return ((name1, name2) in self.edge_attr or
                    (name2, name1) in self.edge_attr)

    def get_node_list(self):
        &#39;&#39;&#39;
        API: get_node_list(self)
        Description:
        Returns node list.
        Return:
            List of nodes.
        &#39;&#39;&#39;
        return list(self.neighbors.keys())

    def get_edge_list(self):
        &#39;&#39;&#39;
        API: get_edge_list(self)
        Description:
        Returns edge list.
        Return:
            List of edges, edges are tuples and in (source,sink) format.
        &#39;&#39;&#39;
        return list(self.edge_attr.keys())

    def get_node_num(self):
        &#39;&#39;&#39;
        API: get_node_num(self)
        Description:
        Returns number of nodes.
        Return:
            Number of nodes.
        &#39;&#39;&#39;
        return len(self.neighbors)

    def get_edge_num(self):
        &#39;&#39;&#39;
        API: get_edge_num(self)
        Description:
        Returns number of edges.
        Return:
            Number of edges.
        &#39;&#39;&#39;
        return len(self.edge_attr)

    def get_node_attr(self, name, attr):
        &#39;&#39;&#39;
        API: get_node_attr(self, name, attr)
        Description:
        Returns attribute attr of given node.
        Input:
            name: Name of node.
            attr: Attribute of node.
        Pre:
            Graph should have this node.
        Return:
            Value of node attribute attr.
        &#39;&#39;&#39;
        return self.get_node(name).get_attr(attr)

    def get_edge_attr(self, n, m, attr):
        &#39;&#39;&#39;
        API: get_edge_attr(self, n, m, attr)
        Description:
        Returns attribute attr of edge (n,m).
        Input:
            n: Source node name.
            m: Sink node name.
            attr: Attribute of edge.
        Pre:
            Graph should have this edge.
        Return:
            Value of edge attribute attr.
        &#39;&#39;&#39;
        if self.graph_type is DIRECTED_GRAPH:
            return self.edge_attr[(n,m)][attr]
        else:
            try:
                return self.edge_attr[(n,m)][attr]
            except KeyError:
                return self.edge_attr[(m,n)][attr]

    def set_node_attr(self, name, attr, value):
        &#39;&#39;&#39;
        API: set_node_attr(self, name, attr)
        Description:
        Sets attr attribute of node named name to value.
        Input:
            name: Name of node.
            attr: Attribute of node to set.
        Pre:
            Graph should have this node.
        Post:
            Node attribute will be updated.
        &#39;&#39;&#39;
        self.get_node(name).set_attr(attr, value)

    def set_edge_attr(self, n, m, attr, value):
        &#39;&#39;&#39;
        API: set_edge_attr(self, n, m, attr, value)
        Description:
        Sets attr attribute of edge (n,m) to value.
        Input:
            n: Source node name.
            m: Sink node name.
            attr: Attribute of edge to set.
            value: New value of attribute.
        Pre:
            Graph should have this edge.
        Post:
            Edge attribute will be updated.
        &#39;&#39;&#39;
        if self.graph_type is DIRECTED_GRAPH:
            self.edge_attr[(n,m)][attr] = value
        else:
            try:
                self.edge_attr[(n,m)][attr] = value
            except KeyError:
                self.edge_attr[(m,n)][attr] = value

    def get_neighbors(self, name):
        &#39;&#39;&#39;
        API: get_neighbors(self, name)
        Description:
        Returns list of neighbors of given node.
        Input:
            name: Node name.
        Pre:
            Graph should have this node.
        Return:
            List of neighbor node names.
        &#39;&#39;&#39;
        return self.neighbors[name]

    def get_in_neighbors(self, name):
        &#39;&#39;&#39;
        API: get_in_neighbors(self, name)
        Description:
        Returns list of in neighbors of given node.
        Input:
            name: Node name.
        Pre:
            Graph should have this node.
        Return:
            List of in-neighbor node names.
        &#39;&#39;&#39;
        return self.in_neighbors[name]

    def get_out_neighbors(self, name):
        &#39;&#39;&#39;
        API: get_out_neighbors(self, name)
        Description:
        Returns list of out-neighbors of given node.
        Input:
            name: Node name.
        Pre:
            Graph should have this node.
        Return:
            List of out-neighbor node names.
        &#39;&#39;&#39;
        return self.neighbors[name]

    def edge_to_string(self, e):
        &#39;&#39;&#39;
        API: edge_to_string(self, e)
        Description:
        Return string that represents edge e in dot language.
        Input:
            e: Edge tuple in (source,sink) format.
        Pre:
            Graph should have this edge.
        Return:
            String that represents given edge.
        &#39;&#39;&#39;
        edge = list()
        edge.append(quote_if_necessary(str(e[0])))
        edge.append(self.edge_connect_symbol)
        edge.append(quote_if_necessary(str(e[1])))
        # return if there is nothing in self.edge_attr[e]
        if len(self.edge_attr[e]) == 0:
            return &#39;&#39;.join(edge)
        edge.append(&#39;  [&#39;)
        for a in self.edge_attr[e]:
            edge.append(a)
            edge.append(&#39;=&#39;)
            edge.append(quote_if_necessary(str(self.edge_attr[e][a])))
            edge.append(&#39;, &#39;)
        edge = edge[:-1]
        edge.append(&#39;]&#39;)
        return &#39;&#39;.join(edge)

    def to_string(self):
        &#39;&#39;&#39;
        API: to_string(self)
        Description:
        This method is based on pydot Graph class with the same name.
        Returns a string representation of the graph in dot language.
        It will return the graph and all its subelements in string form.
        Return:
            String that represents graph in dot language.
        &#39;&#39;&#39;
        graph = list()
        processed_edges = {}
        graph.append(&#39;%s %s {\n&#39; %(self.graph_type, self.name))
        for a in self.attr:
            if a not in GRAPH_ATTRIBUTES:
                continue
            val = self.attr[a]
            if val is not None:
                graph.append( &#39;%s=%s&#39; % (a, quote_if_necessary(val)) )
            else:
                graph.append(a)
            graph.append( &#39;;\n&#39; )
        # clusters
        for c in self.cluster:
            graph.append(&#39;subgraph cluster_%s {\n&#39; %c)
            for a in self.cluster[c][&#39;attrs&#39;]:
                if a==&#39;label&#39;:
                    graph.append(a+&#39;=&#39;+quote_if_necessary(self.cluster[c][&#39;attrs&#39;][a])+&#39;;\n&#39;)
                    continue
                graph.append(a+&#39;=&#39;+self.cluster[c][&#39;attrs&#39;][a]+&#39;;\n&#39;)
            if len(self.cluster[c][&#39;node_attrs&#39;])!=0:
                graph.append(&#39;node [&#39;)
            for a in self.cluster[c][&#39;node_attrs&#39;]:
                graph.append(a+&#39;=&#39;+self.cluster[c][&#39;node_attrs&#39;][a])
                graph.append(&#39;,&#39;)
            if len(self.cluster[c][&#39;node_attrs&#39;])!=0:
                graph.pop()
                graph.append(&#39;];\n&#39;)
            # process cluster nodes
            for n in self.cluster[c][&#39;node_list&#39;]:
                data = self.get_node(n).to_string()
                graph.append(data + &#39;;\n&#39;)
            # process cluster edges
            for n in self.cluster[c][&#39;node_list&#39;]:
                for m in self.cluster[c][&#39;node_list&#39;]:
                    if self.check_edge(n,m):
                        data = self.edge_to_string((n,m))
                        graph.append(data + &#39;;\n&#39;)
                        processed_edges[(n,m)]=None
            graph.append(&#39;}\n&#39;)
        # process remaining (non-cluster) nodes
        for n in self.neighbors:
            for c in self.cluster:
                if n in self.cluster[c][&#39;node_list&#39;]:
                    break
            else:
                data = self.get_node(n).to_string()
                graph.append(data + &#39;;\n&#39;)
        # process edges
        for e in self.edge_attr:
            if e in processed_edges:
                continue
            data = self.edge_to_string(e)
            graph.append(data + &#39;;\n&#39;)
        graph.append( &#39;}\n&#39; )
        return &#39;&#39;.join(graph)

    def label_components(self, display = None):
        &#39;&#39;&#39;
        API: label_components(self, display=None)
        Description:
        This method labels the nodes of an undirected graph with component
        numbers so that each node has the same label as all nodes in the
        same component. It will display the algortihm if display argument is
        provided.
        Input:
            display: display method.
        Pre:
            self.graph_type should be UNDIRECTED_GRAPH.
        Post:
            Nodes will have &#39;component&#39; attribute that will have component
            number as value.
        &#39;&#39;&#39;
        if self.graph_type == DIRECTED_GRAPH:
            raise Exception(&#34;label_components only works for &#34;,
                            &#34;undirected graphs&#34;)
        self.num_components = 0
        for n in self.get_node_list():
            self.get_node(n).set_attr(&#39;component&#39;, None)
        for n in self.neighbors:
            self.get_node(n).set_attr(&#39;label&#39;, &#39;-&#39;)
        for n in self.get_node_list():
            if self.get_node(n).get_attr(&#39;component&#39;) == None:
                self.search(n, display=display,
                            component=self.num_components, algo=&#39;DFS&#39;)
                self.num_components += 1

    def tarjan(self):
        &#39;&#39;&#39;
        API: tarjan(self)
        Description:
        Implements Tarjan&#39;s algorithm for determining strongly connected set of
        nodes.
        Pre:
            self.graph_type should be DIRECTED_GRAPH.
        Post:
            Nodes will have &#39;component&#39; attribute that will have component
            number as value. Changes &#39;index&#39; attribute of nodes.
        &#39;&#39;&#39;
        index = 0
        component = 0
        q = []
        for n in self.get_node_list():
            if self.get_node_attr(n, &#39;index&#39;) is None:
                index, component = self.strong_connect(q, n, index, component)

    def strong_connect(self, q, node, index, component):
        &#39;&#39;&#39;
        API: strong_connect (self, q, node, index, component)
        Description:
        Used by tarjan method. This method should not be called directly by
        user.
        Input:
            q: Node list.
            node: Node that is being connected to nodes in q.
            index: Index used by tarjan method.
            component: Current component number.
        Pre:
            Should be called by tarjan and itself (recursive) only.
        Post:
            Nodes will have &#39;component&#39; attribute that will have component
            number as value. Changes &#39;index&#39; attribute of nodes.
        Return:
            Returns new index and component numbers.
        &#39;&#39;&#39;
        self.set_node_attr(node, &#39;index&#39;, index)
        self.set_node_attr(node, &#39;lowlink&#39;, index)
        index += 1
        q.append(node)
        for m in self.get_neighbors(node):
            if self.get_node_attr(m, &#39;index&#39;) is None:
                index, component = self.strong_connect(q, m, index, component)
                self.set_node_attr(node, &#39;lowlink&#39;,
                                   min([self.get_node_attr(node, &#39;lowlink&#39;),
                                        self.get_node_attr(m, &#39;lowlink&#39;)]))
            elif m in q:
                self.set_node_attr(node, &#39;lowlink&#39;,
                                   min([self.get_node_attr(node, &#39;lowlink&#39;),
                                        self.get_node_attr(m, &#39;index&#39;)]))
        if self.get_node_attr(node, &#39;lowlink&#39;) == self.get_node_attr(node, &#39;index&#39;):
            m = q.pop()
            self.set_node_attr(m, &#39;component&#39;, component)
            while (node!=m):
                m = q.pop()
                self.set_node_attr(m, &#39;component&#39;, component)
            component += 1
            self.num_components = component

        return (index, component)

    def label_strong_component(self):
        &#39;&#39;&#39;
        API: label_strong_component(self)
        Description:
        This method labels the nodes of a directed graph with component
        numbers so that each node has the same label as all nodes in the
        same component.
        Pre:
            self.graph_type should be DIRECTED_GRAPH.
        Post:
            Nodes will have &#39;component&#39; attribute that will have component
            number as value. Changes &#39;index&#39; attribute of nodes.
        &#39;&#39;&#39;
        self.num_components = 0
        self.tarjan()

    def dfs(self, root, disc_count = 0, finish_count = 1, component = None,
            transpose = False, display = None, pred = None):
        &#39;&#39;&#39;
        API: dfs(self, root, disc_count = 0, finish_count = 1, component=None,
            transpose=False)
        Description:
        Make a depth-first search starting from node with name root.
        Input:
            root: Starting node name.
            disc_count: Discovery time.
            finish_count: Finishing time.
            component: component number.
            transpose: Goes in the reverse direction along edges if transpose
            is True.
        Post:
            Nodes will have &#39;component&#39; attribute that will have component
            number as value. Updates &#39;disc_time&#39; and &#39;finish_time&#39; attributes
            of nodes which represents discovery time and finishing time.
        Return:
            Returns a tuple that has discovery time and finish time of the
            last node in the following form (disc_time,finish_time).
        &#39;&#39;&#39;
        if pred == None:
            pred = {}
        if display == None:
            display = self.attr[&#39;display&#39;]
        else:
            self.set_display_mode(display)
        neighbors = self.neighbors
        if self.graph_type == DIRECTED_GRAPH and transpose:
            neighbors = self.in_neighbors
        self.get_node(root).set_attr(&#39;component&#39;, component)
        disc_count += 1
        self.get_node(root).set_attr(&#39;disc_time&#39;, disc_count)
        self.get_node(root).set_attr(&#39;label&#39;, str(disc_count)+&#39;,-&#39;)
        self.get_node(root).set_attr(&#39;color&#39;, &#39;blue&#39;)
        if root in pred:
            self.set_edge_attr(pred[root], root, &#39;color&#39;, &#39;green&#39;)
        self.display()
        if transpose:
            fTime = []
            for n in neighbors[root]:
                fTime.append((n,self.get_node(n).get_attr(&#39;finish_time&#39;)))
            neighbor_list = sorted(fTime, key=operator.itemgetter(1))
            neighbor_list = list(t[0] for t in neighbor_list)
            neighbor_list.reverse()
        else:
            neighbor_list = neighbors[root]
        for i in neighbor_list:
            if not transpose:
                if self.get_node(i).get_attr(&#39;disc_time&#39;) is None:
                    pred[i] = root
                    disc_count, finish_count = self.dfs(i, disc_count,
                                                        finish_count,
                                                        component, transpose,
                                                        pred = pred)
            else:
                if self.get_node(i).get_attr(&#39;component&#39;) is None:
                    disc_count, finish_count = self.dfs(i, disc_count,
                                                        finish_count,
                                                        component, transpose,
                                                        pred = pred)
        self.get_node(root).set_attr(&#39;finish_time&#39;, finish_count)
        d_time = self.get_node(root).get_attr(&#39;disc_time&#39;)
        label = &#39;&#34;&#39; + str(d_time) + &#39;,&#39; + str(finish_count) + &#39;&#34;&#39;
        self.get_node(root).set_attr(&#39;label&#39;, label)
        self.get_node(root).set_attr(&#39;color&#39;, &#39;green&#39;)
        self.display()
        finish_count += 1
        return disc_count, finish_count

    def bfs(self, root, display = None, component = None):
        &#39;&#39;&#39;
        API: bfs(self, root, display = None, component=None)
        Description:
        Make a breadth-first search starting from node with name root.
        Input:
            root: Starting node name.
            display: display method.
            component: component number.
        Post:
            Nodes will have &#39;component&#39; attribute that will have component
            number as value.
        &#39;&#39;&#39;
        self.search(root, display = display, component = component, q = Queue())

    def search(self, source, destination = None, display = None,
               component = None, q = None,
               algo = &#39;DFS&#39;, reverse = False, **kargs):
        &#39;&#39;&#39;
        API: search(self, source, destination = None, display = None,
               component = None, q = Stack(),
               algo = &#39;DFS&#39;, reverse = False, **kargs)
        Description:
        Generic search method. Changes behavior (dfs,bfs,dijkstra,prim)
        according to algo argument.
        if destination is not specified:
           This method determines all nodes reachable from &#34;source&#34; ie. creates
           precedence tree and returns it (dictionary).
        if destionation is given:
           If there exists a path from &#34;source&#34; to &#34;destination&#34; it will return
           list of the nodes is this path. If there is no such path, it will
           return the precedence tree constructed from source (dictionary).
        Optionally, it marks all nodes reachable from &#34;source&#34; with a component
        number. The variable &#34;q&#34; determines the order in which the nodes are
        searched.
        Input:
            source: Search starts from node with this name.
            destination: Destination node name.
            display: Display method.
            algo: Algortihm that specifies search. Available algortihms are
            &#39;DFS&#39;, &#39;BFS&#39;, &#39;Dijkstra&#39; and &#39;Prim&#39;.
            reverse: Search goes in reverse arc directions if True.
            kargs: Additional keyword arguments.
        Post:
            Nodes will have &#39;component&#39; attribute that will have component
            number as value (if component argument provided). Color attribute
            of nodes and edges may change.
        Return:
            Returns predecessor tree in dictionary form if destination is
            not specified, returns list of node names in the path from source
            to destionation if destionation is specified and there is a path.
            If there is no path returns predecessor tree in dictionary form.
            See description section.
        &#39;&#39;&#39;
        if display == None:
            display = self.attr[&#39;display&#39;]
        else:
            self.set_display_mode(display)
        if algo == &#39;DFS&#39;:
            if q is None:
                q = Stack()
            self.get_node(source).set_attr(&#39;component&#39;, component)
        elif algo == &#39;BFS&#39; or algo == &#39;UnweightedSPT&#39;:
            if q is None:
                q = Queue()
            self.get_node(source).set_attr(&#39;component&#39;, component)
        elif algo == &#39;Dijkstra&#39; or algo == &#39;Prim&#39;:
            if q is None:
                q = PriorityQueue()
        else:
            print(&#34;Unknown search algorithm...exiting&#34;)
            return
        neighbors = self.neighbors
        if self.graph_type == DIRECTED_GRAPH and reverse:
            neighbors = self.in_neighbors
        for i in self.get_node_list():
            self.get_node(i).set_attr(&#39;label&#39;, &#39;-&#39;)
            self.get_node(i).attr.pop(&#39;priority&#39;, None)
            self.get_node(i).set_attr(&#39;distance&#39;, None)
            self.get_node(i).set_attr(&#39;color&#39;, &#39;black&#39;)
            for j in neighbors[i]:
                if reverse:
                    self.set_edge_attr(j, i, &#39;color&#39;, &#39;black&#39;)
                else:
                    self.set_edge_attr(i, j, &#39;color&#39;, &#39;black&#39;)
        self.display()
        pred = {}
        self.process_edge_search(None, source, pred, q, component, algo,
                                 **kargs)
        found = True
        if source != destination:
            found = False
        while not q.isEmpty() and not found:
            current = q.peek()
            if self.get_node(current).get_attr(&#39;color&#39;) == &#39;green&#39;:
                q.remove(current)
                continue
            self.process_node_search(current, q, **kargs)
            self.get_node(current).set_attr(&#39;color&#39;, &#39;blue&#39;)
            if current != source:
                if reverse:
                    self.set_edge_attr(current, pred[current], &#39;color&#39;, &#39;green&#39;)
                else:
                    self.set_edge_attr(pred[current], current, &#39;color&#39;, &#39;green&#39;)
            if current == destination:
                found = True
                break
            self.display()
            for n in neighbors[current]:
                if self.get_node(n).get_attr(&#39;color&#39;) != &#39;green&#39;:
                    if reverse:
                        self.set_edge_attr(n, current, &#39;color&#39;, &#39;yellow&#39;)
                    else:
                        self.set_edge_attr(current, n, &#39;color&#39;, &#39;yellow&#39;)
                    self.display()
                    self.process_edge_search(current, n, pred, q, component,
                                             algo, **kargs)
                    if reverse:
                        self.set_edge_attr(n, current, &#39;color&#39;, &#39;black&#39;)
                    else:
                        self.set_edge_attr(current, n, &#39;color&#39;, &#39;black&#39;)
            q.remove(current)
            self.get_node(current).set_attr(&#39;color&#39;, &#39;green&#39;)
            self.display()
        if found:
            path = [destination]
            current = destination
            while current != source:
                path.insert(0, pred[current])
                current = pred[current]
            return path
        if destination == None:
            return pred
        else:
            return None

    def process_node_search(self, node, q, **kwargs):
        &#39;&#39;&#39;
        API: process_node_search(self, node, q, **kwargs)
        Description:
        Used by search() method. Process nodes along the search. Should not be
        called by user directly.
        Input:
            node: Name of the node being processed.
            q: Queue data structure.
            kwargs: Keyword arguments.
        Post:
            &#39;priority&#39; attribute of the node may get updated.
        &#39;&#39;&#39;
        if isinstance(q, PriorityQueue):
            self.get_node(node).set_attr(&#39;priority&#39;, q.get_priority(node))

    def process_edge_dijkstra(self, current, neighbor, pred, q, component):
        &#39;&#39;&#39;
        API: process_edge_dijkstra(self, current, neighbor, pred, q, component)
        Description:
        Used by search() method if the algo argument is &#39;Dijkstra&#39;. Processes
        edges along Dijkstra&#39;s algorithm. User does not need to call this
        method directly.
        Input:
            current: Name of the current node.
            neighbor: Name of the neighbor node.
            pred: Predecessor tree.
            q: Data structure that holds nodes to be processed in a queue.
            component: component number.
        Post:
            &#39;color&#39; attribute of nodes and edges may change.
        &#39;&#39;&#39;
        if current is None:
            self.get_node(neighbor).set_attr(&#39;color&#39;, &#39;red&#39;)
            self.get_node(neighbor).set_attr(&#39;label&#39;, 0)
            q.push(neighbor, 0)
            self.display()
            self.get_node(neighbor).set_attr(&#39;color&#39;, &#39;black&#39;)
            return
        new_estimate = (q.get_priority(current) +
                        self.get_edge_attr(current, neighbor, &#39;cost&#39;))
        if neighbor not in pred or new_estimate &lt; q.get_priority(neighbor):
            pred[neighbor] = current
            self.get_node(neighbor).set_attr(&#39;color&#39;, &#39;red&#39;)
            self.get_node(neighbor).set_attr(&#39;label&#39;, new_estimate)
            q.push(neighbor, new_estimate)
            self.display()
            self.get_node(neighbor).set_attr(&#39;color&#39;, &#39;black&#39;)

    def process_edge_prim(self, current, neighbor, pred, q, component):
        &#39;&#39;&#39;
        API: process_edge_prim(self, current, neighbor, pred, q, component)
        Description:
        Used by search() method if the algo argument is &#39;Prim&#39;. Processes
        edges along Prim&#39;s algorithm. User does not need to call this method
        directly.
        Input:
            current: Name of the current node.
            neighbor: Name of the neighbor node.
            pred: Predecessor tree.
            q: Data structure that holds nodes to be processed in a queue.
            component: component number.
        Post:
            &#39;color&#39; attribute of nodes and edges may change.
        &#39;&#39;&#39;
        if current is None:
            self.get_node(neighbor).set_attr(&#39;color&#39;, &#39;red&#39;)
            self.get_node(neighbor).set_attr(&#39;label&#39;, 0)
            q.push(neighbor, 0)
            self.display()
            self.get_node(neighbor).set_attr(&#39;color&#39;, &#39;black&#39;)
            return
        new_estimate = self.get_edge_attr(current, neighbor, &#39;cost&#39;)
        if not neighbor in pred or new_estimate &lt; q.get_priority(neighbor):
            pred[neighbor] = current
            self.get_node(neighbor).set_attr(&#39;color&#39;, &#39;red&#39;)
            self.get_node(neighbor).set_attr(&#39;label&#39;, new_estimate)
            q.push(neighbor, new_estimate)
            self.display()
            self.get_node(neighbor).set_attr(&#39;color&#39;, &#39;black&#39;)

    def process_edge_search(self, current, neighbor, pred, q, component, algo,
                            **kargs):
        &#39;&#39;&#39;
        API: process_edge_search(self, current, neighbor, pred, q, component,
                                 algo, **kargs)
        Description:
        Used by search() method. Processes edges according to the underlying
        algortihm. User does not need to call this method directly.
        Input:
            current: Name of the current node.
            neighbor: Name of the neighbor node.
            pred: Predecessor tree.
            q: Data structure that holds nodes to be processed in a queue.
            component: component number.
            algo: Search algorithm. See search() documentation.
            kwargs: Keyword arguments.
        Post:
            &#39;color&#39;, &#39;distance&#39;, &#39;component&#39; attribute of nodes and edges may
            change.
        &#39;&#39;&#39;
        if algo == &#39;Dijkstra&#39;:
            return self.process_edge_dijkstra(current, neighbor, pred, q,
                                              component)
        if algo == &#39;Prim&#39;:
            return self.process_edge_prim(current, neighbor, pred, q,
                                          component)
        neighbor_node = self.get_node(neighbor)
        if current == None:
            neighbor_node.set_attr(&#39;distance&#39;, 0)
            if isinstance(q, PriorityQueue):
                q.push(neighbor, 0)
            else:
                q.push(neighbor)
            if component != None:
                neighbor_node.set_attr(&#39;component&#39;, component)
                neighbor_node.set_attr(&#39;label&#39;, component)
            else:
                neighbor_node.set_attr(&#39;label&#39;, 0)
            return
        if isinstance(q, PriorityQueue):
            current_priority = q.get_priority(neighbor)
            if algo == &#39;UnweightedSPT&#39; or algo == &#39;BFS&#39;:
                priority = self.get_node(current).get_attr(&#39;distance&#39;) + 1
            if algo == &#39;DFS&#39;:
                priority = -self.get_node(current).get_attr(&#39;distance&#39;) - 1
            if current_priority is not None and priority &gt;= current_priority:
                return
            q.push(neighbor, priority)
            if algo == &#39;UnweightedSPT&#39; or algo == &#39;BFS&#39;:
                neighbor_node.set_attr(&#39;distance&#39;, priority)
            if algo == &#39;DFS&#39;:
                neighbor_node.set_attr(&#39;depth&#39;, -priority)
        else:
            distance = self.get_node(current).get_attr(&#39;distance&#39;) + 1
            if ((algo == &#39;UnweightedSPT&#39; or algo == &#39;BFS&#39;) and
                neighbor_node.get_attr(&#39;distance&#39;) is not None):
                return
            neighbor_node.set_attr(&#39;distance&#39;, distance)
            neighbor_node.set_attr(&#39;label&#39;, str(distance))
            q.push(neighbor)
        pred[neighbor] = current
        neighbor_node.set_attr(&#39;color&#39;, &#39;red&#39;)
        if component != None:
            neighbor_node.set_attr(&#39;component&#39;, component)
            neighbor_node.set_attr(&#39;label&#39;, component)
        self.display()

    def minimum_spanning_tree_prim(self, source, display = None,
                                   q = PriorityQueue()):
        &#39;&#39;&#39;
        API: minimum_spanning_tree_prim(self, source, display = None,
                                        q = PriorityQueue())
        Description:
        Determines a minimum spanning tree of all nodes reachable
        from source using Prim&#39;s Algorithm.
        Input:
            source: Name of source node.
            display: Display method.
            q: Data structure that holds nodes to be processed in a queue.
        Post:
            &#39;color&#39;, &#39;distance&#39;, &#39;component&#39; attribute of nodes and edges may
            change.
        Return:
            Returns predecessor tree in dictionary format.
        &#39;&#39;&#39;
        if display == None:
            display = self.attr[&#39;display&#39;]
        else:
            self.set_display_mode(display)
        if isinstance(q, PriorityQueue):
            addToQ = q.push
            removeFromQ = q.pop
            peek = q.peek
            isEmpty = q.isEmpty
        neighbors = self.get_neighbors
        pred = {}
        addToQ(source)
        done = False
        while not isEmpty() and not done:
            current = removeFromQ()
            self.set_node_attr(current, &#39;color&#39;, &#39;blue&#39;)
            if current != source:
                self.set_edge_attr(pred[current], current, &#39;color&#39;, &#39;green&#39;)
            self.display()
            for n in neighbors(current):
                if self.get_node_attr(n, &#39;color&#39;) != &#39;green&#39;:
                    self.set_edge_attr(current, n, &#39;color&#39;, &#39;yellow&#39;)
                    self.display()
                    new_estimate = self.get_edge_attr(current, n, &#39;cost&#39;)
                    if not n in pred or new_estimate &lt; peek(n)[0]:
                        pred[n] = current
                        self.set_node_attr(n, &#39;color&#39;, &#39;red&#39;)
                        self.set_node_attr(n, &#39;label&#39;, new_estimate)
                        addToQ(n, new_estimate)
                        self.display()
                        self.set_node_attr(n, &#39;color&#39;, &#39;black&#39;)
                    self.set_edge_attr(current, n, &#39;color&#39;, &#39;black&#39;)
            self.set_node_attr(current, &#39;color&#39;, &#39;green&#39;)
            self.display()
        return pred

    def minimum_spanning_tree_kruskal(self, display = None, components = None):
        &#39;&#39;&#39;
        API: minimum_spanning_tree_kruskal(self, display = None,
                                           components = None)
        Description:
        Determines a minimum spanning tree using Kruskal&#39;s Algorithm.
        Input:
            display: Display method.
            component: component number.
        Post:
            &#39;color&#39; attribute of nodes and edges may change.
        Return:
            Returns list of edges where edges are tuples in (source,sink)
            format.
        &#39;&#39;&#39;
        if display == None:
            display = self.attr[&#39;display&#39;]
        else:
            self.set_display_mode(display)
        if components is None:
            components = DisjointSet(display = display, layout = &#39;dot&#39;,
                                     optimize = False)
        sorted_edge_list = sorted(self.get_edge_list(), key=self.get_edge_cost)
        edges = []
        for n in self.get_node_list():
            components.add([n])
        components.display()
        for e in sorted_edge_list:
            if len(edges) == len(self.get_node_list()) - 1:
                break
            self.set_edge_attr(e[0], e[1], &#39;color&#39;, &#39;yellow&#39;)
            self.display()
            if components.union(e[0], e[1]):
                self.set_edge_attr(e[0], e[1], &#39;color&#39;, &#39;green&#39;)
                self.display()
                edges.append(e)
            else:
                self.set_edge_attr(e[0], e[1], &#39;color&#39;, &#39;black&#39;)
                self.display()
            components.display()
        return edges

    def max_flow_preflowpush(self, source, sink, algo = &#39;FIFO&#39;, display = None):
        &#39;&#39;&#39;
        API: max_flow_preflowpush(self, source, sink, algo = &#39;FIFO&#39;,
                                  display = None)
        Description:
        Finds maximum flow from source to sink by a depth-first search based
        augmenting path algorithm.
        Pre:
             Assumes a directed graph in which each arc has a &#39;capacity&#39;
             attribute and for which there does does not exist both arcs (i,j)
             and (j,i) for any pair of nodes i and j.
        Input:
            source: Source node name.
            sink: Sink node name.
            algo: Algorithm choice, &#39;FIFO&#39;, &#39;SAP&#39; or &#39;HighestLabel&#39;.
            display: display method.
        Post:
            The &#39;flow&#39; attribute of each arc gives a maximum flow.
        &#39;&#39;&#39;
        if display == None:
            display = self.attr[&#39;display&#39;]
        else:
            self.set_display_mode(display)
        nl = self.get_node_list()
        # set excess of all nodes to 0
        for n in nl:
            self.set_node_attr(n, &#39;excess&#39;, 0)
        # set flow of all edges to 0
        for e in self.edge_attr:
            self.edge_attr[e][&#39;flow&#39;] = 0
            if &#39;capacity&#39; in self.edge_attr[e]:
                capacity = self.edge_attr[e][&#39;capacity&#39;]
                self.edge_attr[e][&#39;label&#39;] = str(capacity)+&#39;/0&#39;
            else:
                self.edge_attr[e][&#39;capacity&#39;] = INF
                self.edge_attr[e][&#39;label&#39;] = &#39;INF/0&#39;
        self.display()
        self.set_display_mode(&#39;off&#39;)
        self.search(sink, algo = &#39;UnweightedSPT&#39;, reverse = True)
        self.set_display_mode(display)
        disconnect = False
        for n in nl:
            if self.get_node_attr(n, &#39;distance&#39;) is None:
                disconnect = True
                self.set_node_attr(n, &#39;distance&#39;,
                                   2*len(nl) + 1)
        if disconnect:
            print(&#39;Warning: graph contains nodes not connected to the sink...&#39;)
        if algo == &#39;FIFO&#39;:
            q = Queue()
        elif algo == &#39;SAP&#39;:
            q = Stack()
        elif algo == &#39;HighestLabel&#39;:
            q = PriorityQueue()
        for n in self.get_neighbors(source):
            capacity = self.get_edge_attr(source, n, &#39;capacity&#39;)
            self.set_edge_attr(source, n, &#39;flow&#39;, capacity)
            self.set_node_attr(n, &#39;excess&#39;, capacity)
            excess = self.get_node_attr(source, &#39;excess&#39;)
            self.set_node_attr(source, &#39;excess&#39;, excess - capacity)
            if algo == &#39;FIFO&#39; or algo == &#39;SAP&#39;:
                q.push(n)
            elif algo == &#39;HighestLabel&#39;:
                q.push(n, -1)
        self.set_node_attr(source, &#39;distance&#39;, len(nl))
        self.show_flow()
        while not q.isEmpty():
            relabel = True
            current = q.peek()
            neighbors = (self.get_neighbors(current) +
                         self.get_in_neighbors(current))
            for n in neighbors:
                pushed = self.process_edge_flow(source, sink, current, n, algo,
                                                q)
                if pushed:
                    self.show_flow()
                    if algo == &#39;FIFO&#39;:
                        &#39;&#39;&#39;With FIFO, we need to add the neighbors to the queue
                        before the current is added back in or the nodes will
                        be out of order
                        &#39;&#39;&#39;
                        if q.peek(n) is None and n != source and n != sink:
                            q.push(n)
                        &#39;&#39;&#39;Keep pushing while there is excess&#39;&#39;&#39;
                        if self.get_node_attr(current, &#39;excess&#39;) &gt; 0:
                            continue
                    &#39;&#39;&#39;If we were able to push, then there we should not
                    relabel
                    &#39;&#39;&#39;
                    relabel = False
                    break
            q.remove(current)
            if current != sink:
                if relabel:
                    self.relabel(current)
                    self.show_flow()
                if self.get_node_attr(current, &#39;excess&#39;) &gt; 0:
                    if algo == &#39;FIFO&#39; or algo == &#39;SAP&#39;:
                        q.push(current)
                    elif algo == &#39;HighestLabel&#39;:
                        q.push(current, -self.get_node_attr(current,
                                                            &#39;distance&#39;))
            if pushed and q.peek(n) is None and n != source:
                if algo == &#39;SAP&#39;:
                    q.push(n)
                elif algo == &#39;HighestLabel&#39;:
                    q.push(n, -self.get_node_attr(n, &#39;distance&#39;))

    def process_edge_flow(self, source, sink, i, j, algo, q):
        &#39;&#39;&#39;
        API: process_edge_flow(self, source, sink, i, j, algo, q)
        Description:
        Used by by max_flow_preflowpush() method. Processes edges along
        prefolow push.
        Input:
            source: Source node name of flow graph.
            sink: Sink node name of flow graph.
            i: Source node in the processed edge (tail of arc).
            j: Sink node in the processed edge (head of arc).
        Post:
            The &#39;flow&#39; and &#39;excess&#39; attributes of nodes may get updated.
        Return:
            Returns False if residual capacity is 0, True otherwise.
        &#39;&#39;&#39;
        if (self.get_node_attr(i, &#39;distance&#39;) !=
            self.get_node_attr(j, &#39;distance&#39;) + 1):
            return False
        if (i, j) in self.edge_attr:
            edge = (i, j)
            capacity = self.get_edge_attr(i, j, &#39;capacity&#39;)
            mult = 1
        else:
            edge = (j, i)
            capacity = 0
            mult = -1
        flow = mult*self.edge_attr[edge][&#39;flow&#39;]
        residual_capacity = capacity - flow
        if residual_capacity == 0:
            return False
        excess_i = self.get_node_attr(i, &#39;excess&#39;)
        excess_j = self.get_node_attr(j, &#39;excess&#39;)
        push_amount = min(excess_i, residual_capacity)
        self.edge_attr[edge][&#39;flow&#39;] = mult*(flow + push_amount)
        self.set_node_attr(i, &#39;excess&#39;, excess_i - push_amount)
        self.set_node_attr(j, &#39;excess&#39;, excess_j + push_amount)
        return True

    def relabel(self, i):
        &#39;&#39;&#39;
        API: relabel(self, i)
        Description:
        Used by max_flow_preflowpush() method for relabelling node i.
        Input:
            i: Node that is being relabelled.
        Post:
            &#39;distance&#39; attribute of node i is updated.
        &#39;&#39;&#39;
        min_distance = 2*len(self.get_node_list()) + 1
        for j in self.get_neighbors(i):
            if (self.get_node_attr(j, &#39;distance&#39;) &lt; min_distance and
                (self.get_edge_attr(i, j, &#39;flow&#39;) &lt;
                 self.get_edge_attr(i, j, &#39;capacity&#39;))):
                min_distance = self.get_node_attr(j, &#39;distance&#39;)
        for j in self.get_in_neighbors(i):
            if (self.get_node_attr(j, &#39;distance&#39;) &lt; min_distance and
                self.get_edge_attr(j, i, &#39;flow&#39;) &gt; 0):
                min_distance = self.get_node_attr(j, &#39;distance&#39;)
        self.set_node_attr(i, &#39;distance&#39;, min_distance + 1)

    def show_flow(self):
        &#39;&#39;&#39;
        API: relabel(self, i)
        Description:
        Used by max_flow_preflowpush() method for display purposed.
        Post:
            &#39;color&#39; and &#39;label&#39; attribute of edges/nodes are updated.
        &#39;&#39;&#39;
        for n in self.get_node_list():
            excess = self.get_node_attr(n, &#39;excess&#39;)
            distance = self.get_node_attr(n, &#39;distance&#39;)
            self.set_node_attr(n, &#39;label&#39;, str(excess)+&#39;/&#39;+str(distance))
            for neighbor in self.get_neighbors(n):
                capacity = self.get_edge_attr(n, neighbor, &#39;capacity&#39;)
                flow = self.get_edge_attr(n, neighbor, &#39;flow&#39;)
                if capacity == INF:
                    self.set_edge_attr(n, neighbor, &#39;label&#39;,
                                       &#39;INF&#39;+&#39;/&#39;+str(flow))
                else:
                    self.set_edge_attr(n, neighbor, &#39;label&#39;,
                                       str(capacity)+&#39;/&#39;+str(flow))
                if capacity == flow:
                    self.set_edge_attr(n, neighbor, &#39;color&#39;, &#39;red&#39;)
                elif flow &gt; 0:
                    self.set_edge_attr(n, neighbor, &#39;color&#39;, &#39;green&#39;)
                else:
                    self.set_edge_attr(n, neighbor, &#39;color&#39;, &#39;black&#39;)
        self.display()

    def create_residual_graph(self):
        &#39;&#39;&#39;
        API: create_residual_graph(self)
        Description:
        Creates and returns residual graph, which is a Graph instance
        itself.
        Pre:
            (1) Arcs should have &#39;flow&#39;, &#39;capacity&#39; and &#39;cost&#39; attribute
            (2) Graph should be a directed graph
        Return:
            Returns residual graph, which is a Graph instance.
        &#39;&#39;&#39;
        if self.graph_type is UNDIRECTED_GRAPH:
            raise Exception(&#39;residual graph is defined for directed graphs.&#39;)
        residual_g = Graph(type = DIRECTED_GRAPH)
        for e in self.get_edge_list():
            capacity_e = self.get_edge_attr(e[0], e[1], &#39;capacity&#39;)
            flow_e = self.get_edge_attr(e[0], e[1], &#39;flow&#39;)
            cost_e = self.get_edge_attr(e[0], e[1], &#39;cost&#39;)
            if flow_e &gt; 0:
                residual_g.add_edge(e[1], e[0], cost=-1*cost_e,
                                    capacity=flow_e)
            if capacity_e - flow_e &gt; 0:
                residual_g.add_edge(e[0], e[1], cost=cost_e,
                                    capacity=capacity_e-flow_e)
        return residual_g

    def cycle_canceling(self, display):
        &#39;&#39;&#39;
        API:
            cycle_canceling(self, display)
        Description:
            Solves minimum cost feasible flow problem using cycle canceling
            algorithm. Returns True when an optimal solution is found, returns
            False otherwise. &#39;flow&#39; attribute values of arcs should be
            considered as junk when returned False.
        Input:
            display: Display method.
        Pre:
            (1) Arcs should have &#39;capacity&#39; and &#39;cost&#39; attribute.
            (2) Nodes should have &#39;demand&#39; attribute, this value should be
            positive if the node is a supply node, negative if it is demand
            node and 0 if it is transhipment node.
            (3) graph should not have node &#39;s&#39; and &#39;t&#39;.
        Post:
            Changes &#39;flow&#39; attributes of arcs.
        Return:
            Returns True when an optimal solution is found, returns False
            otherwise.
        &#39;&#39;&#39;
        # find a feasible solution to flow problem
        if not self.find_feasible_flow():
            return False
        # create residual graph
        residual_g = self.create_residual_graph()
        # identify a negative cycle in residual graph
        ncycle = residual_g.get_negative_cycle()
        # loop while residual graph has a negative cycle
        while ncycle is not None:
            # find capacity of cycle
            cap = residual_g.find_cycle_capacity(ncycle)
            # augment capacity amount along the cycle
            self.augment_cycle(cap, ncycle)
            # create residual graph
            residual_g = self.create_residual_graph()
            # identify next negative cycle
            ncycle = residual_g.get_negative_cycle()
        return True

    def find_feasible_flow(self):
        &#39;&#39;&#39;
        API:
            find_feasible_flow(self)
        Description:
            Solves feasible flow problem, stores solution in &#39;flow&#39; attribute
            or arcs. This method is used to get an initial feasible flow for
            simplex and cycle canceling algorithms. Uses max_flow() method.
            Other max flow methods can also be used. Returns True if a feasible
            flow is found, returns False, if the problem is infeasible. When
            the problem is infeasible &#39;flow&#39; attributes of arcs should be
            considered as junk.
        Pre:
            (1) &#39;capacity&#39; attribute of arcs
            (2) &#39;demand&#39; attribute of nodes
        Post:
            Keeps solution in &#39;flow&#39; attribute of arcs.
        Return:
            Returns True if a feasible flow is found, returns False, if the
            problem is infeasible
        &#39;&#39;&#39;
        # establish a feasible flow in the network, to do this add nodes s and
        # t and solve a max flow problem.
        nl = self.get_node_list()
        for i in nl:
            b_i = self.get_node(i).get_attr(&#39;demand&#39;)
            if b_i &gt; 0:
                # i is a supply node, add (s,i) arc
                self.add_edge(&#39;s&#39;, i, capacity=b_i)
            elif b_i &lt; 0:
                # i is a demand node, add (i,t) arc
                self.add_edge(i, &#39;t&#39;, capacity=-1*b_i)
        # solve max flow on this modified graph
        self.max_flow(&#39;s&#39;, &#39;t&#39;, &#39;off&#39;)
        # check if all demand is satisfied, i.e. the min cost problem is
        # feasible or not
        for i in self.neighbors[&#39;s&#39;]:
            flow = self.get_edge_attr(&#39;s&#39;, i, &#39;flow&#39;)
            capacity = self.get_edge_attr(&#39;s&#39;, i, &#39;capacity&#39;)
            if flow != capacity:
                self.del_node(&#39;s&#39;)
                self.del_node(&#39;t&#39;)
                return False
        # remove node &#39;s&#39; and node &#39;t&#39;
        self.del_node(&#39;s&#39;)
        self.del_node(&#39;t&#39;)
        return True

    def get_layout(self):
        &#39;&#39;&#39;
        API:
            get_layout(self)
        Description:
        Returns layout attribute of the graph.
        Return:
            Returns layout attribute of the graph.
        &#39;&#39;&#39;
        return self.attr[&#39;layout&#39;]

    def set_layout(self, value):
        &#39;&#39;&#39;
        API:
            set_layout(self, value)
        Description:
        Sets layout attribute of the graph to value.
        Input:
            value: New value of the layout.
        &#39;&#39;&#39;
        self.attr[&#39;layout&#39;]=value
        if value == &#39;dot2tex&#39;:
            self.attr[&#39;d2tgraphstyle&#39;] = &#39;every text node part/.style={align=center}&#39;

    def write(self, file_obj, layout = None, format=&#39;png&#39;):
        &#39;&#39;&#39;
        API:
            write(self, basename = &#39;graph&#39;, layout = None, format=&#39;png&#39;)
        Description:
        Writes graph to dist using layout and format.
        Input:
            basename: name of the file that will be written.
            layout: Dot layout for generating graph image.
            format: Image format, all format supported by Dot are wellcome.
        Post:
            File will be written to disk.
        &#39;&#39;&#39;
        if layout == None:
            layout = self.get_layout()
        if format == &#39;dot&#39;:
            file_obj.write(bytearray(self.to_string(), &#39;utf8&#39;))
        else:
            out = self.create(layout, format)
            if (out != None):
                file_obj.write(out)

    def create(self, layout, format, **args):
        &#39;&#39;&#39;
        API:
            create(self, layout, format, **args)
        Description:
            Returns postscript representation of graph.
        Input:
            layout: Dot layout for generating graph image.
            format: Image format, all format supported by Dot are wellcome.
        Return:
            Returns postscript representation of graph.
        &#39;&#39;&#39;
        tmp_fd, tmp_name = tempfile.mkstemp()
        tmp_file = os.fdopen(tmp_fd, &#39;w&#39;)
        tmp_file.write(self.to_string())
        tmp_file.close()
        try:
            p = subprocess.run([layout, &#39;-T&#39;+format, tmp_name],
                               capture_output = True)
        except OSError:
            print(&#39;&#39;&#39;Graphviz executable not found.
Graphviz must be installed and in your search path.
Please visit http://www.graphviz.org/ for information on installation.
After installation, ensure that the PATH variable is properly set.&#39;&#39;&#39;)
            return None

        
        p.check_returncode()

        os.remove(tmp_name)
            
        if p.stderr:
            print(p.stderr)
        return p.stdout

    def display(self, highlight = None, basename = &#39;graph&#39;, format = &#39;png&#39;,
                pause = False, wait_for_click = True):
        &#39;&#39;&#39;
        API:
            display(self, highlight = None, basename = &#39;graph&#39;, format = &#39;png&#39;,
                pause = True)
        Description:
            Displays graph according to the arguments provided.
            Current display modes: &#39;off&#39;, &#39;file&#39;, &#39;PIL&#39;, &#39;matplotlib&#39;, &#39;xdot&#39;,
            &#39;svg&#39;
            Current layout modes: Layouts provided by graphviz (&#39;dot&#39;, &#39;fdp&#39;,
            &#39;circo&#39;, etc.) and &#39;dot2tex&#39;.
            Current formats: Formats provided by graphviz (&#39;ps&#39;, &#39;pdf&#39;, &#39;png&#39;,
            etc.)
        Input:
            highlight: List of nodes to be highlighted.
            basename: File name. It will be used if display mode is &#39;file&#39;.
            format: Image format, all format supported by Dot are wellcome.
            pause: If display is &#39;matplotlib&#39;, window will remain open until closed.
            wait_for_click: If display is &#39;matplotlib&#39;, setting to True will 
            wait for a button click before proceeding. This is useful when 
            animating an algorithm. 
        Post:
            A display window will pop up or a file will be written depending
            on display mode.
        &#39;&#39;&#39;
        if self.attr[&#39;display&#39;] == &#39;off&#39;:
            return
        if highlight != None:
            for n in highlight:
                if not isinstance(n, Node):
                    n = self.get_node(n)
                n.set_attr(&#39;color&#39;, &#39;red&#39;)
        if self.get_layout() == &#39;dot2tex&#39;:
            if self.attr[&#39;display&#39;] != &#39;file&#39;:
                self.attr[&#39;display&#39;] = &#39;file&#39;
                print(&#34;Warning: Dot2tex layout can only be used with display mode &#39;file&#39;&#34;)
                print(&#34;         Automatically changing setting&#34;)
        if self.attr[&#39;display&#39;] == &#39;file&#39;:
            if self.get_layout() == &#39;dot2tex&#39;:
                try:
                    if DOT2TEX_INSTALLED:
                        if format != &#39;pdf&#39; or format != &#39;ps&#39;:
                            print(&#34;Dot2tex only supports pdf and ps formats, falling back to pdf&#34;)
                            format = &#39;pdf&#39;
                        self.set_layout(&#39;dot&#39;)
                        tex = dot2tex.dot2tex(self.to_string(), autosize=True, texmode = &#39;math&#39;, template = DOT2TEX_TEMPLATE)
                    else:
                        print(&#34;Error: Dot2tex not installed.&#34;)
                except:
                    try:
                        self.set_layout(&#39;dot&#39;)
                        with open(basename+&#39;.dot&#39;, &#34;w+b&#34;) as f:
                            self.write(f, self.get_layout(), &#39;dot&#39;)
                            p = subprocess.call([&#39;dot2tex&#39;, &#39;-t math&#39;,
                                                 basename + &#39;.dot&#39;])
                    except:
                        print(&#34;There was an error running dot2tex.&#34;)
                with open(basename+&#39;.tex&#39;, &#39;w&#39;) as f:
                    f.write(tex)
                try: 
                    subprocess.call([&#39;latex&#39;, basename])
                    if format == &#39;ps&#39;:
                        subprocess.call([&#39;dvips&#39;, basename])
                    elif format == &#39;pdf&#39;:
                        subprocess.call([&#39;pdflatex&#39;, basename])
                    self.set_layout(&#39;dot2tex&#39;)
                except:
                    print(&#34;There was an error runing latex. Is it installed?&#34;)
            else:
                with open(basename+&#39;.&#39;+format, &#34;w+b&#34;) as f:
                    self.write(f, self.get_layout(), format)
            return
        elif self.attr[&#39;display&#39;] == &#39;PIL&#39;:
            if PIL_INSTALLED:
                tmp_fd, tmp_name = tempfile.mkstemp()
                tmp_file = os.fdopen(tmp_fd, &#39;w+b&#39;)
                self.write(tmp_file, self.get_layout(), format)
                tmp_file.close()
                im = PIL_Image.open(tmp_name)
                im.show()
                os.remove(tmp_name)
            else:
                print(&#39;Error: PIL not installed. Display disabled.&#39;)
                self.attr[&#39;display&#39;] = &#39;off&#39;
        elif self.attr[&#39;display&#39;] == &#39;matplotlib&#39;:
            if MATPLOTLIB_INSTALLED and PIL_INSTALLED:
                tmp_fd, tmp_name = tempfile.mkstemp()
                tmp_file = os.fdopen(tmp_fd, &#39;w+b&#39;)
                self.write(tmp_file, self.get_layout(), format)
                tmp_file.close()
                im = PIL_Image.open(tmp_name)
                fig = plt.figure(1)
                fig.canvas.mpl_connect(&#39;close_event&#39;, handle_close)
                plt.clf()
                plt.axis(&#39;off&#39;)
                plt.imshow(im, interpolation=&#39;bilinear&#39; #resample=True
                           #extent = (0, 100, 0, 100)
                )
                if wait_for_click == True:
                    plt.draw()
                    try:
                        if plt.waitforbuttonpress(timeout = 10000):
                            plt.close()
                            exit()
                    except:
                        exit()
                else:
                    plt.show(block=pause)
                im.close()
                os.remove(tmp_name)
            else:
                print(&#39;Warning: Either matplotlib or Pillow is not installed. Display disabled.&#39;)
                self.attr[&#39;display&#39;] = &#39;off&#39;
        elif self.attr[&#39;display&#39;] == &#39;xdot&#39;:
            if XDOT_INSTALLED:
                window = xdot.DotWindow()
                window.set_dotcode(self.to_string())
                window.connect(&#39;destroy&#39;, gtk.main_quit)
                gtk.main()
            else:
                print(&#39;Error: xdot not installed. Display disabled.&#39;)
                self.attr[&#39;display&#39;] = &#39;off&#39;
        else:
            print(&#34;Unknown display mode: &#34;, end=&#39; &#39;)
            print(self.attr[&#39;display&#39;])
        if highlight != None:
            for n in highlight:
                if not isinstance(n, Node):
                    n = self.get_node(n)
                n.set_attr(&#39;color&#39;, &#39;black&#39;)

    def set_display_mode(self, value):
        &#39;&#39;&#39;
        API:
            set_display_mode(self, value)
        Description:
            Sets display mode to value.
        Input:
            value: New display mode.
        Post:
            Display mode attribute of graph is updated.
        &#39;&#39;&#39;
        self.attr[&#39;display&#39;] = value

    def max_flow(self, source, sink, display = None, algo = &#39;DFS&#39;):
        &#39;&#39;&#39;
        API: max_flow(self, source, sink, display=None)
        Description:
        Finds maximum flow from source to sink by a depth-first search based
        augmenting path algorithm.
        Pre:
            Assumes a directed graph in which each arc has a &#39;capacity&#39;
            attribute and for which there does does not exist both arcs (i,j)
            and (j, i) for any pair of nodes i and j.
        Input:
            source: Source node name.
            sink: Sink node name.
            display: Display mode.
        Post:
            The &#39;flow&#34; attribute of each arc gives a maximum flow.
        &#39;&#39;&#39;
        if display is not None:
            old_display =  self.attr[&#39;display&#39;]
            self.attr[&#39;display&#39;] = display
        nl = self.get_node_list()
        # set flow of all edges to 0
        for e in self.edge_attr:
            self.edge_attr[e][&#39;flow&#39;] = 0
            if &#39;capacity&#39; in self.edge_attr[e]:
                capacity = self.edge_attr[e][&#39;capacity&#39;]
                self.edge_attr[e][&#39;label&#39;] = str(capacity)+&#39;/0&#39;
            else:
                self.edge_attr[e][&#39;capacity&#39;] = INF
                self.edge_attr[e][&#39;label&#39;] = &#39;INF/0&#39;
        while True:
            # find an augmenting path from source to sink using DFS
            if algo == &#39;DFS&#39;:
                q = Stack()
            elif algo == &#39;BFS&#39;:
                q = Queue()
            q.push(source)
            pred = {source:None}
            explored = [source]
            for n in nl:
                self.get_node(n).set_attr(&#39;color&#39;, &#39;black&#39;)
            for e in self.edge_attr:
                if self.edge_attr[e][&#39;flow&#39;] == 0:
                    self.edge_attr[e][&#39;color&#39;] = &#39;black&#39;
                elif self.edge_attr[e][&#39;flow&#39;]==self.edge_attr[e][&#39;capacity&#39;]:
                    self.edge_attr[e][&#39;color&#39;] = &#39;red&#39;
                else:
                    self.edge_attr[e][&#39;color&#39;] = &#39;green&#39;
            self.display()
            while not q.isEmpty():
                current = q.peek()
                q.remove(current)
                if current == sink:
                    break
                out_neighbor = self.neighbors[current]
                in_neighbor = self.in_neighbors[current]
                neighbor = out_neighbor+in_neighbor
                for m in neighbor:
                    if m in explored:
                        continue
                    self.get_node(m).set_attr(&#39;color&#39;, &#39;yellow&#39;)
                    if m in out_neighbor:
                        self.set_edge_attr(current, m, &#39;color&#39;, &#39;yellow&#39;)
                        available_capacity = (
                            self.get_edge_attr(current, m, &#39;capacity&#39;)-
                            self.get_edge_attr(current, m, &#39;flow&#39;))
                    else:
                        self.set_edge_attr(m, current, &#39;color&#39;, &#39;yellow&#39;)
                        available_capacity=self.get_edge_attr(m, current, &#39;flow&#39;)
                    self.display()
                    if available_capacity &gt; 0:
                        self.get_node(m).set_attr(&#39;color&#39;, &#39;blue&#39;)
                        if m in out_neighbor:
                            self.set_edge_attr(current, m, &#39;color&#39;, &#39;blue&#39;)
                        else:
                            self.set_edge_attr(m, current, &#39;color&#39;, &#39;blue&#39;)
                        explored.append(m)
                        pred[m] = current
                        q.push(m)
                    else:
                        self.get_node(m).set_attr(&#39;color&#39;, &#39;black&#39;)
                        if m in out_neighbor:
                            if (self.get_edge_attr(current, m, &#39;flow&#39;) ==
                                self.get_edge_attr(current, m, &#39;capacity&#39;)):
                                self.set_edge_attr(current, m, &#39;color&#39;, &#39;red&#39;)
                            elif self.get_edge_attr(current, m, &#39;flow&#39;) == 0:
                                self.set_edge_attr(current, m, &#39;color&#39;, &#39;black&#39;)
                            #else:
                            #    self.set_edge_attr(current, m, &#39;color&#39;, &#39;green&#39;)
                        else:
                            if (self.get_edge_attr(m, current, &#39;flow&#39;) ==
                                self.get_edge_attr(m, current, &#39;capacity&#39;)):
                                self.set_edge_attr(m, current, &#39;color&#39;, &#39;red&#39;)
                            elif self.get_edge_attr(m, current, &#39;flow&#39;) == 0:
                                self.set_edge_attr(m, current, &#39;color&#39;, &#39;black&#39;)
                            #else:
                            #    self.set_edge_attr(m, current, &#39;color&#39;, &#39;green&#39;)
                    self.display()
            # if no path with positive capacity from source sink exists, stop
            if sink not in pred:
                break
            # find capacity of the path
            current = sink
            min_capacity = &#39;infinite&#39;
            while True:
                m = pred[current]
                if (m,current) in self.edge_attr:
                    arc_capacity = self.edge_attr[(m, current)][&#39;capacity&#39;]
                    flow = self.edge_attr[(m, current)][&#39;flow&#39;]
                    potential = arc_capacity-flow
                    if min_capacity == &#39;infinite&#39;:
                        min_capacity = potential
                    elif min_capacity &gt; potential:
                        min_capacity = potential
                else:
                    potential = self.edge_attr[(current, m)][&#39;flow&#39;]
                    if min_capacity == &#39;infinite&#39;:
                        min_capacity = potential
                    elif min_capacity &gt; potential:
                        min_capacity = potential
                if m == source:
                    break
                current = m
            # update flows on the path
            current = sink
            while True:
                m = pred[current]
                if (m, current) in self.edge_attr:
                    flow = self.edge_attr[(m, current)][&#39;flow&#39;]
                    capacity = self.edge_attr[(m, current)][&#39;capacity&#39;]
                    new_flow = flow+min_capacity
                    self.edge_attr[(m, current)][&#39;flow&#39;] = new_flow
                    if capacity == INF:
                        self.edge_attr[(m, current)][&#39;label&#39;] = \
                            &#39;INF&#39; + &#39;/&#39;+str(new_flow)
                    else:
                        self.edge_attr[(m, current)][&#39;label&#39;] = \
                            str(capacity)+&#39;/&#39;+str(new_flow)
                    if new_flow==capacity:
                        self.edge_attr[(m, current)][&#39;color&#39;] = &#39;red&#39;
                    else:
                        self.edge_attr[(m, current)][&#39;color&#39;] = &#39;green&#39;
                    self.display()
                else:
                    flow = self.edge_attr[(current, m)][&#39;flow&#39;]
                    capacity = self.edge_attr[(current, m)][&#39;capacity&#39;]
                    new_flow = flow-min_capacity
                    self.edge_attr[(current, m)][&#39;flow&#39;] = new_flow
                    if capacity == INF:
                        self.edge_attr[(current, m)][&#39;label&#39;] = \
                            &#39;INF&#39; + &#39;/&#39;+str(new_flow)
                    else:
                        self.edge_attr[(current, m)][&#39;label&#39;] = \
                            str(capacity)+&#39;/&#39;+str(new_flow)
                    if new_flow==0:
                        self.edge_attr[(current, m)][&#39;color&#39;] = &#39;red&#39;
                    else:
                        self.edge_attr[(current, m)][&#39;color&#39;] = &#39;green&#39;
                    self.display()
                if m == source:
                    break
                current = m
        if display is not None:
            self.attr[&#39;display&#39;] = old_display

    def get_negative_cycle(self):
        &#39;&#39;&#39;
        API:
            get_negative_cycle(self)
        Description:
            Finds and returns negative cost cycle using &#39;cost&#39; attribute of
            arcs. Return value is a list of nodes representing cycle it is in
            the following form; n_1-n_2-...-n_k, when the cycle has k nodes.
        Pre:
            Arcs should have &#39;cost&#39; attribute.
        Return:
            Returns a list of nodes in the cycle if a negative cycle exists,
            returns None otherwise.
        &#39;&#39;&#39;
        nl = self.get_node_list()
        i = nl[0]
        (valid, distance, nextn) = self.floyd_warshall()
        if not valid:
            cycle = self.floyd_warshall_get_cycle(distance, nextn)
            return cycle
        else:
            return None

    def floyd_warshall(self):
        &#39;&#39;&#39;
        API:
            floyd_warshall(self)
        Description:
            Finds all pair shortest paths and stores it in a list of lists.
            This is possible if the graph does not have negative cycles. It will
            return a tuple with 3 elements. The first element indicates whether
            the graph has a negative cycle. It is true if the graph does not
            have a negative cycle, ie. distances found are valid shortest
            distances. The second element is a dictionary of shortest distances
            between nodes. Keys are tuple of node pairs ie. (i,j). The third
            element is a dictionary that helps to retrieve the shortest path
            between nodes. Then return value can be represented as (validity,
            distance, nextn) where nextn is the dictionary to retrieve paths.
            distance and nextn can be used as inputs to other methods to get
            shortest path between nodes.
        Pre:
            Arcs should have &#39;cost&#39; attribute.
        Return:
            Returns (validity, distance, nextn). The distances are valid if
            validity is True.
        &#39;&#39;&#39;
        nl = self.get_node_list()
        el = self.get_edge_list()
        # initialize distance
        distance = {}
        for i in nl:
            for j in nl:
                distance[(i,j)] = &#39;infinity&#39;
        for i in nl:
            distance[(i,i)] = 0
        for e in el:
            distance[(e[0],e[1])] = self.get_edge_cost(e)
        # == end of distance initialization
        # initialize next
        nextn = {}
        for i in nl:
            for j in nl:
                if i==j or distance[(i,j)]==&#39;infinity&#39;:
                    nextn[(i,j)] = None
                else:
                    nextn[(i,j)] = i
        # == end of next initialization
        # compute shortest distance
        for k in nl:
            for i in nl:
                for j in nl:
                    if distance[(i,k)]==&#39;infinity&#39; or distance[(k,j)]==&#39;infinity&#39;:
                        continue
                    elif distance[(i,j)]==&#39;infinity&#39;:
                        distance[(i,j)] = distance[(i,k)] + distance[(k,j)]
                        nextn[(i,j)] = nextn[(k,j)]
                    elif distance[(i,j)] &gt; distance[(i,k)] + distance[(k,j)]:
                        distance[(i,j)] = distance[(i,k)] + distance[(k,j)]
                        nextn[(i,j)] = nextn[(k,j)]
        # == end of compute shortest distance
        # check if graph has negative cycles
        for i in nl:
            if distance[(i,i)] &lt; 0:
                # shortest distances are not valid
                # graph has negative cycle
                return (False, distance, nextn)
        return (True, distance, nextn)

    def floyd_warshall_get_path(self, distance, nextn, i, j):
        &#39;&#39;&#39;
        API:
            floyd_warshall_get_path(self, distance, nextn, i, j):
        Description:
            Finds shortest path between i and j using distance and nextn
            dictionaries.
        Pre:
            (1) distance and nextn are outputs of floyd_warshall method.
            (2) The graph does not have a negative cycle, , ie.
            distance[(i,i)] &gt;=0 for all node i.
        Return:
            Returns the list of nodes on the path from i to j, ie. [i,...,j]
        &#39;&#39;&#39;
        if distance[(i,j)]==&#39;infinity&#39;:
            return None
        k = nextn[(i,j)]
        path = self.floyd_warshall_get_path
        if i==k:
            return [i, j]
        else:
            return path(distance, nextn, i,k) + [k] + path(distance, nextn, k,j)

    def floyd_warshall_get_cycle(self, distance, nextn, element = None):
        &#39;&#39;&#39;
        API:
            floyd_warshall_get_cycle(self, distance, nextn, element = None)
        Description:
            Finds a negative cycle in the graph.
        Pre:
            (1) distance and nextn are outputs of floyd_warshall method.
            (2) The graph should have a negative cycle, , ie.
            distance[(i,i)] &lt; 0 for some node i.
        Return:
            Returns the list of nodes on the cycle. Ex: [i,j,k,...,r], where
            (i,j), (j,k) and (r,i) are some edges in the cycle.
        &#39;&#39;&#39;
        nl = self.get_node_list()
        if element is None:
            for i in nl:
                if distance[(i,i)] &lt; 0:
                    # graph has a cycle on the path from i to i.
                    element = i
                    break
            else:
                raise Exception(&#39;Graph does not have a negative cycle!&#39;)
        elif distance[(element,element)] &gt;= 0:
            raise Exception(&#39;Graph does not have a negative cycle that contains node &#39;+str(element)+&#39;!&#39;)
        # find the cycle on the path from i to i.
        cycle = [element]
        k = nextn[(element,element)]
        while k not in cycle:
            cycle.insert(1,k)
            k = nextn[(element,k)]
        if k==element:
            return cycle
        else:
            return self.floyd_warshall_get_cycle(distance, nextn, k)

    def find_cycle_capacity(self, cycle):
        &#39;&#39;&#39;
        API:
            find_cycle_capacity(self, cycle):
        Description:
            Finds capacity of the cycle input.
        Pre:
            (1) Arcs should have &#39;capacity&#39; attribute.
        Input:
            cycle: a list representing a cycle
        Return:
            Returns an integer number representing capacity of cycle.
        &#39;&#39;&#39;
        index = 0
        k = len(cycle)
        capacity = self.get_edge_attr(cycle[k-1], cycle[0], &#39;capacity&#39;)
        while index&lt;(k-1):
            i = cycle[index]
            j = cycle[index+1]
            capacity_ij = self.get_edge_attr(i, j, &#39;capacity&#39;)
            if capacity &gt; capacity_ij:
                capacity = capacity_ij
            index += 1
        return capacity

    def fifo_label_correcting(self, source):
        &#39;&#39;&#39;
        API:
            fifo_label_correcting(self, source)
        Description:
            finds shortest path from source to every other node. Returns
            predecessor dictionary. If graph has a negative cycle, detects it
            and returns to it.
        Pre:
            (1) &#39;cost&#39; attribute of arcs. It will be used to compute shortest
            path.
        Input:
            source: source node
        Post:
            Modifies &#39;distance&#39; attribute of nodes.
        Return:
            If there is no negative cycle returns to (True, pred), otherwise
            returns to (False, cycle) where pred is the predecessor dictionary
            and cycle is a list of nodes that represents cycle. It is in
            [n_1, n_2, ..., n_k] form where the cycle has k nodes.
        &#39;&#39;&#39;
        pred = {}
        self.get_node(source).set_attr(&#39;distance&#39;, 0)
        pred[source] = None
        for n in self.neighbors:
            if n!=source:
                self.get_node(n).set_attr(&#39;distance&#39;, &#39;inf&#39;)
        q = [source]
        while q:
            i = q[0]
            q = q[1:]
            for j in self.neighbors[i]:
                distance_j = self.get_node(j).get_attr(&#39;distance&#39;)
                distance_i = self.get_node(i).get_attr(&#39;distance&#39;)
                c_ij = self.get_edge_attr(i, j, &#39;cost&#39;)
                if distance_j &gt; distance_i + c_ij:
                    self.get_node(j).set_attr(&#39;distance&#39;, distance_i+c_ij)
                    if j in pred:
                        pred[j] = i
                        cycle = self.label_correcting_check_cycle(j, pred)
                        if cycle is not None:
                            return (False, cycle)
                    else:
                        pred[j] = i
                    if j not in q:
                        q.append(j)
        return (True, pred)

    def label_correcting_check_cycle(self, j, pred):
        &#39;&#39;&#39;
        API:
            label_correcting_check_cycle(self, j, pred)
        Description:
            Checks if predecessor dictionary has a cycle, j represents the node
            that predecessor is recently updated.
        Pre:
            (1) predecessor of source node should be None.
        Input:
            j: node that predecessor is recently updated.
            pred: predecessor dictionary
        Return:
            If there exists a cycle, returns the list that represents the
            cycle, otherwise it returns to None.
        &#39;&#39;&#39;
        labelled = {}
        for n in self.neighbors:
            labelled[n] = None
        current = j
        while current != None:
            if labelled[current]==j:
                cycle = self.label_correcting_get_cycle(j, pred)
                return cycle
            labelled[current] = j
            current = pred[current]
        return None

    def label_correcting_get_cycle(self, j, pred):
        &#39;&#39;&#39;
        API:
            label_correcting_get_cycle(self, labelled, pred)
        Description:
            In label correcting check cycle it is decided pred has a cycle and
            nodes in the cycle are labelled. We will create a list of nodes
            in the cycle using labelled and pred inputs.
        Pre:
            This method should be called from label_correcting_check_cycle(),
            unless you are sure about what you are doing.
        Input:
            j: Node that predecessor is recently updated. We know that it is
            in the cycle
            pred: Predecessor dictionary that contains a cycle
        Post:
            Returns a list of nodes that represents cycle. It is in
            [n_1, n_2, ..., n_k] form where the cycle has k nodes.
        &#39;&#39;&#39;
        cycle = []
        cycle.append(j)
        current = pred[j]
        while current!=j:
            cycle.append(current)
            current = pred[current]
        cycle.reverse()
        return cycle

    def augment_cycle(self, amount, cycle):
        &#39;&#39;&#39;
        API:
            augment_cycle(self, amount, cycle):
        Description:
            Augments &#39;amount&#39; unit of flow along cycle.
        Pre:
            Arcs should have &#39;flow&#39; attribute.
        Inputs:
            amount: An integer representing the amount to augment
            cycle: A list representing a cycle
        Post:
            Changes &#39;flow&#39; attributes of arcs.
        &#39;&#39;&#39;
        index = 0
        k = len(cycle)
        while index&lt;(k-1):
            i = cycle[index]
            j = cycle[index+1]
            if (i,j) in self.edge_attr:
                flow_ij = self.edge_attr[(i,j)][&#39;flow&#39;]
                self.edge_attr[(i,j)][&#39;flow&#39;] = flow_ij+amount
            else:
                flow_ji = self.edge_attr[(j,i)][&#39;flow&#39;]
                self.edge_attr[(j,i)][&#39;flow&#39;] = flow_ji-amount
            index += 1
        i = cycle[k-1]
        j = cycle[0]
        if (i,j) in self.edge_attr:
            flow_ij = self.edge_attr[(i,j)][&#39;flow&#39;]
            self.edge_attr[(i,j)][&#39;flow&#39;] = flow_ij+amount
        else:
            flow_ji = self.edge_attr[(j,i)][&#39;flow&#39;]
            self.edge_attr[(j,i)][&#39;flow&#39;] = flow_ji-amount

    def network_simplex(self, display, pivot, root):
        &#39;&#39;&#39;
        API:
            network_simplex(self, display, pivot, root)
        Description:
            Solves minimum cost feasible flow problem using network simplex
            algorithm. It is recommended to use min_cost_flow(algo=&#39;simplex&#39;)
            instead of using network_simplex() directly. Returns True when an
            optimal solution is found, returns False otherwise. &#39;flow&#39; attribute
            values of arcs should be considered as junk when returned False.
        Pre:
            (1) check Pre section of min_cost_flow()
        Input:
            pivot: specifies pivot rule. Check min_cost_flow()
            display: &#39;off&#39; for no display, &#39;matplotlib&#39; for live update of
            spanning tree.
            root: Root node for the underlying spanning trees that will be
            generated by network simplex algorthm.
        Post:
            (1) Changes &#39;flow&#39; attribute of edges.
        Return:
            Returns True when an optimal solution is found, returns
            False otherwise.
        &#39;&#39;&#39;
        # ==== determine an initial tree structure (T,L,U)
        # find a feasible flow
        if not self.find_feasible_flow():
            return False
        t = self.simplex_find_tree()
        self.set_display_mode(display)
        # mark spanning tree arcs
        self.simplex_mark_st_arcs(t)
        # display initial spanning tree
        t.simplex_redraw(display, root)
        t.set_display_mode(display)
        #t.display()
        self.display()
        # set predecessor, depth and thread indexes
        t.simplex_search(root, 1)
        # compute potentials
        self.simplex_compute_potentials(t, root)
        # while some nontree arc violates optimality conditions
        while not self.simplex_optimal(t):
            self.display()
            # select an entering arc (k,l)
            (k,l) = self.simplex_select_entering_arc(t, pivot)
            self.simplex_mark_entering_arc(k, l)
            self.display()
            # determine leaving arc
            ((p,q), capacity, cycle)=self.simplex_determine_leaving_arc(t,k,l)
            # mark leaving arc
            self.simplex_mark_leaving_arc(p, q)
            self.display()
            self.simplex_remove_arc(t, p, q, capacity, cycle)
            # display after arc removed
            self.display()
            self.simplex_mark_st_arcs(t)
            self.display()
            # set predecessor, depth and thread indexes
            t.simplex_redraw(display, root)
            #t.display()
            t.simplex_search(root, 1)
            # compute potentials
            self.simplex_compute_potentials(t, root)
        return True

    def simplex_mark_leaving_arc(self, p, q):
        &#39;&#39;&#39;
        API:
            simplex_mark_leving_arc(self, p, q)
        Description:
            Marks leaving arc.
        Input:
            p: tail of the leaving arc
            q: head of the leaving arc
        Post:
            Changes color attribute of leaving arc.
        &#39;&#39;&#39;
        self.set_edge_attr(p, q, &#39;color&#39;, &#39;red&#39;)

    def simplex_determine_leaving_arc(self, t, k, l):
        &#39;&#39;&#39;
        API:
            simplex_determine_leaving_arc(self, t, k, l)
        Description:
            Determines and returns the leaving arc.
        Input:
            t: current spanning tree solution.
            k: tail of the entering arc.
            l: head of the entering arc.
        Return:
            Returns the tuple that represents leaving arc, capacity of the
            cycle and cycle.
        &#39;&#39;&#39;
        # k,l are the first two elements of the cycle
        cycle = self.simplex_identify_cycle(t, k, l)
        flow_kl = self.get_edge_attr(k, l, &#39;flow&#39;)
        capacity_kl = self.get_edge_attr(k, l, &#39;capacity&#39;)
        min_capacity = capacity_kl
        # check if k,l is in U or L
        if flow_kl==capacity_kl:
            # l,k will be the last two elements
            cycle.reverse()
        n = len(cycle)
        index = 0
        # determine last blocking arc
        t.add_edge(k, l)
        tel = t.get_edge_list()
        while index &lt; (n-1):
            if (cycle[index], cycle[index+1]) in tel:
                flow = self.edge_attr[(cycle[index], cycle[index+1])][&#39;flow&#39;]
                capacity = \
                    self.edge_attr[(cycle[index],cycle[index+1])][&#39;capacity&#39;]
                if min_capacity &gt;= (capacity-flow):
                    candidate = (cycle[index], cycle[index+1])
                    min_capacity = capacity-flow
            else:
                flow = self.edge_attr[(cycle[index+1], cycle[index])][&#39;flow&#39;]
                if min_capacity &gt;= flow:
                    candidate = (cycle[index+1], cycle[index])
                    min_capacity = flow
            index += 1
        # check arc (cycle[n-1], cycle[0])
        if (cycle[n-1], cycle[0]) in tel:
            flow = self.edge_attr[(cycle[n-1], cycle[0])][&#39;flow&#39;]
            capacity = self.edge_attr[(cycle[n-1], cycle[0])][&#39;capacity&#39;]
            if min_capacity &gt;= (capacity-flow):
                candidate = (cycle[n-1], cycle[0])
                min_capacity = capacity-flow
        else:
            flow = self.edge_attr[(cycle[0], cycle[n-1])][&#39;flow&#39;]
            if min_capacity &gt;= flow:
                candidate = (cycle[0], cycle[n-1])
                min_capacity = flow
        return (candidate, min_capacity, cycle)

    def simplex_mark_entering_arc(self, k, l):
        &#39;&#39;&#39;
        API:
            simplex_mark_entering_arc(self, k, l)
        Description:
            Marks entering arc (k,l)
        Input:
            k: tail of the entering arc
            l: head of the entering arc
        Post:
            (1) color attribute of the arc (k,l)
        &#39;&#39;&#39;
        self.set_edge_attr(k, l, &#39;color&#39;, &#39;green&#39;)

    def simplex_mark_st_arcs(self, t):
        &#39;&#39;&#39;
        API:
            simplex_mark_st_arcs(self, t)
        Description:
            Marks spanning tree arcs.
            Case 1, Blue: Arcs that are at lower bound and in tree.
            Case 2, Red: Arcs that are at upper bound and in tree.
            Case 3, Green: Arcs that are between bounds are green.
            Case 4, Brown: Non-tree arcs at lower bound.
            Case 5, Violet: Non-tree arcs at upper bound.
        Input:
            t: t is the current spanning tree
        Post:
            (1) color attribute of edges.
        &#39;&#39;&#39;
        tel = list(t.edge_attr.keys())
        for e in self.get_edge_list():
            flow_e = self.edge_attr[e][&#39;flow&#39;]
            capacity_e = self.edge_attr[e][&#39;capacity&#39;]
            if e in tel:
                if flow_e == 0:
                    self.edge_attr[e][&#39;color&#39;] = &#39;blue&#39;
                elif flow_e == capacity_e:
                    self.edge_attr[e][&#39;color&#39;] = &#39;blue&#39;
                else:
                    self.edge_attr[e][&#39;color&#39;] = &#39;blue&#39;
            else:
                if flow_e == 0:
                    self.edge_attr[e][&#39;color&#39;] = &#39;black&#39;
                elif flow_e == capacity_e:
                    self.edge_attr[e][&#39;color&#39;] = &#39;black&#39;
                else:
                    msg = &#34;Arc is not in ST but has flow between bounds.&#34;
                    raise Exception(msg)

    def print_flow(self):
        &#39;&#39;&#39;
        API:
            print_flow(self)
        Description:
            Prints all positive flows to stdout. This method can be used for
            debugging purposes.
        &#39;&#39;&#39;
        print(&#39;printing current edge, flow, capacity&#39;)
        for e in self.edge_attr:
            if self.edge_attr[e][&#39;flow&#39;]!=0:
                print(e, str(self.edge_attr[e][&#39;flow&#39;]).ljust(4), end=&#39; &#39;)
                print(str(self.edge_attr[e][&#39;capacity&#39;]).ljust(4))

    def simplex_redraw(self, display, root):
        &#39;&#39;&#39;
        API:
            simplex_redraw(self, display, root)
        Description:
            Returns a new graph instance that is same as self but adds nodes
            and arcs in a way that the resulting tree will be displayed
            properly.
        Input:
            display: display mode
            root: root node in tree.
        Return:
            Returns a graph same as self.
        &#39;&#39;&#39;
        nl = self.get_node_list()
        el = self.get_edge_list()
        new = Graph(type=DIRECTED_GRAPH, layout=&#39;dot&#39;, display=display)
        pred_i = self.get_node(root).get_attr(&#39;pred&#39;)
        thread_i = self.get_node(root).get_attr(&#39;thread&#39;)
        depth_i = self.get_node(root).get_attr(&#39;depth&#39;)
        new.add_node(root, pred=pred_i, thread=thread_i, depth=depth_i)
        q = [root]
        visited = [root]
        while q:
            name = q.pop()
            visited.append(name)
            neighbors = self.neighbors[name] + self.in_neighbors[name]
            for n in neighbors:
                if n not in new.get_node_list():
                    pred_i = self.get_node(n).get_attr(&#39;pred&#39;)
                    thread_i = self.get_node(n).get_attr(&#39;thread&#39;)
                    depth_i = self.get_node(n).get_attr(&#39;depth&#39;)
                    new.add_node(n, pred=pred_i, thread=thread_i, depth=depth_i)
                if (name,n) in el:
                    if (name,n) not in new.edge_attr:
                        new.add_edge(name,n)
                else:
                    if (n,name) not in new.edge_attr:
                        new.add_edge(n,name)
                if n not in visited:
                    q.append(n)
        for e in el:
            flow = self.edge_attr[e][&#39;flow&#39;]
            capacity = self.edge_attr[e][&#39;capacity&#39;]
            cost = self.edge_attr[e][&#39;cost&#39;]
            new.edge_attr[e][&#39;flow&#39;] = flow
            new.edge_attr[e][&#39;capacity&#39;] = capacity
            new.edge_attr[e][&#39;cost&#39;] = cost
            new.edge_attr[e][&#39;label&#39;] =  &#34;%d/%d/%d&#34; %(flow,capacity,cost)
        return new

    def simplex_remove_arc(self, t, p, q, min_capacity, cycle):
        &#39;&#39;&#39;
        API:
            simplex_remove_arc(self, p, q, min_capacity, cycle)
        Description:
            Removes arc (p,q), updates t, updates flows, where (k,l) is
            the entering arc.
        Input:
            t: tree solution to be updated.
            p: tail of the leaving arc.
            q: head of the leaving arc.
            min_capacity: capacity of the cycle.
            cycle: cycle obtained when entering arc considered.
        Post:
            (1) updates t.
            (2) updates &#39;flow&#39; attributes.
        &#39;&#39;&#39;
        # augment min_capacity along cycle
        n = len(cycle)
        tel = list(t.edge_attr.keys())
        index = 0
        while index &lt; (n-1):
            if (cycle[index], cycle[index+1]) in tel:
                flow_e = self.edge_attr[(cycle[index], cycle[index+1])][&#39;flow&#39;]
                self.edge_attr[(cycle[index], cycle[index+1])][&#39;flow&#39;] =\
                    flow_e+min_capacity
            else:
                flow_e = self.edge_attr[(cycle[index+1], cycle[index])][&#39;flow&#39;]
                self.edge_attr[(cycle[index+1], cycle[index])][&#39;flow&#39;] =\
                    flow_e-min_capacity
            index += 1
        # augment arc cycle[n-1], cycle[0]
        if (cycle[n-1], cycle[0]) in tel:
            flow_e = self.edge_attr[(cycle[n-1], cycle[0])][&#39;flow&#39;]
            self.edge_attr[(cycle[n-1], cycle[0])][&#39;flow&#39;] =\
                flow_e+min_capacity
        else:
            flow_e = self.edge_attr[(cycle[0], cycle[n-1])][&#39;flow&#39;]
            self.edge_attr[(cycle[0], cycle[n-1])][&#39;flow&#39;] =\
                flow_e-min_capacity
        # remove leaving arc
        t.del_edge((p, q))
        # set label of removed arc
        flow_pq = self.get_edge_attr(p, q, &#39;flow&#39;)
        capacity_pq = self.get_edge_attr(p, q, &#39;capacity&#39;)
        cost_pq = self.get_edge_attr(p, q, &#39;cost&#39;)
        self.set_edge_attr(p, q, &#39;label&#39;,
                           &#34;%d/%d/%d&#34; %(flow_pq,capacity_pq,cost_pq))
        for e in t.edge_attr:
            flow = self.edge_attr[e][&#39;flow&#39;]
            capacity = self.edge_attr[e][&#39;capacity&#39;]
            cost = self.edge_attr[e][&#39;cost&#39;]
            t.edge_attr[e][&#39;flow&#39;] = flow
            t.edge_attr[e][&#39;capacity&#39;] = capacity
            t.edge_attr[e][&#39;cost&#39;] = cost
            t.edge_attr[e][&#39;label&#39;] = &#34;%d/%d/%d&#34; %(flow,capacity,cost)
            self.edge_attr[e][&#39;label&#39;] = &#34;%d/%d/%d&#34; %(flow,capacity,cost)

    def simplex_select_entering_arc(self, t, pivot):
        &#39;&#39;&#39;
        API:
            simplex_select_entering_arc(self, t, pivot)
        Description:
            Decides and returns entering arc using pivot rule.
        Input:
            t: current spanning tree solution
            pivot: May be one of the following; &#39;first_eligible&#39; or &#39;dantzig&#39;.
            &#39;dantzig&#39; is the default value.
        Return:
            Returns entering arc tuple (k,l)
        &#39;&#39;&#39;
        if pivot==&#39;dantzig&#39;:
            # pick the maximum violation
            candidate = {}
            for e in self.edge_attr:
                if e in t.edge_attr:
                    continue
                flow_ij = self.edge_attr[e][&#39;flow&#39;]
                potential_i = self.get_node(e[0]).get_attr(&#39;potential&#39;)
                potential_j = self.get_node(e[1]).get_attr(&#39;potential&#39;)
                capacity_ij = self.edge_attr[e][&#39;capacity&#39;]
                c_ij = self.edge_attr[e][&#39;cost&#39;]
                cpi_ij = c_ij - potential_i + potential_j
                if flow_ij==0:
                    if cpi_ij &lt; 0:
                        candidate[e] = cpi_ij
                elif flow_ij==capacity_ij:
                    if cpi_ij &gt; 0:
                        candidate[e] = cpi_ij
            for e in candidate:
                max_c = e
                max_v = abs(candidate[e])
                break
            for e in candidate:
                if max_v &lt; abs(candidate[e]):
                    max_c = e
                    max_v = abs(candidate[e])
        elif pivot==&#39;first_eligible&#39;:
            # pick the first eligible
            for e in self.edge_attr:
                if e in t.edge_attr:
                    continue
                flow_ij = self.edge_attr[e][&#39;flow&#39;]
                potential_i = self.get_node(e[0]).get_attr(&#39;potential&#39;)
                potential_j = self.get_node(e[1]).get_attr(&#39;potential&#39;)
                capacity_ij = self.edge_attr[e][&#39;capacity&#39;]
                c_ij = self.edge_attr[e][&#39;cost&#39;]
                cpi_ij = c_ij - potential_i + potential_j
                if flow_ij==0:
                    if cpi_ij &lt; 0:
                        max_c = e
                        max_v = abs(cpi_ij)
                elif flow_ij==capacity_ij:
                    if cpi_ij &gt; 0:
                        max_c = e
                        max_v = cpi_ij
        else:
            raise Exception(&#34;Unknown pivot rule.&#34;)
        return max_c

    def simplex_optimal(self, t):
        &#39;&#39;&#39;
        API:
            simplex_optimal(self, t)
        Description:
            Checks if the current solution is optimal, if yes returns True,
            False otherwise.
        Pre:
            &#39;flow&#39; attributes represents a solution.
        Input:
            t: Graph instance tat reperesents spanning tree solution.
        Return:
            Returns True if the current solution is optimal (optimality
            conditions are satisfied), else returns False
        &#39;&#39;&#39;
        for e in self.edge_attr:
            if e in t.edge_attr:
                continue
            flow_ij = self.edge_attr[e][&#39;flow&#39;]
            potential_i = self.get_node(e[0]).get_attr(&#39;potential&#39;)
            potential_j = self.get_node(e[1]).get_attr(&#39;potential&#39;)
            capacity_ij = self.edge_attr[e][&#39;capacity&#39;]
            c_ij = self.edge_attr[e][&#39;cost&#39;]
            cpi_ij = c_ij - potential_i + potential_j
            if flow_ij==0:
                if cpi_ij &lt; 0:
                    return False
            elif flow_ij==capacity_ij:
                if cpi_ij &gt; 0:
                    return False
        return True

    def simplex_find_tree(self):
        &#39;&#39;&#39;
        API:
            simplex_find_tree(self)
        Description:
            Assumes a feasible flow solution stored in &#39;flow&#39; attribute&#39;s of
            arcs and converts this solution to a feasible spanning tree
            solution.
        Pre:
            (1) &#39;flow&#39; attributes represents a feasible flow solution.
        Post:
            (1) &#39;flow&#39; attributes may change when eliminating cycles.
        Return:
            Return a Graph instance that is a spanning tree solution.
        &#39;&#39;&#39;
        # find a cycle
        solution_g = self.get_simplex_solution_graph()
        cycle = solution_g.simplex_find_cycle()
        while cycle is not None:
            # find amount to augment and direction
            amount = self.simplex_augment_cycle(cycle)
            # augment along the cycle
            self.augment_cycle(amount, cycle)
            # find a new cycle
            solution_g = self.get_simplex_solution_graph()
            cycle = solution_g.simplex_find_cycle()
        # check if the solution is connected
        while self.simplex_connect(solution_g):
            pass
        # add attributes
        for e in self.edge_attr:
            flow = self.edge_attr[e][&#39;flow&#39;]
            capacity = self.edge_attr[e][&#39;capacity&#39;]
            cost = self.edge_attr[e][&#39;cost&#39;]
            self.edge_attr[e][&#39;label&#39;] = &#34;%d/%d/%d&#34; %(flow,capacity,cost)
            if e in solution_g.edge_attr:
                solution_g.edge_attr[e][&#39;flow&#39;] = flow
                solution_g.edge_attr[e][&#39;capacity&#39;] = capacity
                solution_g.edge_attr[e][&#39;cost&#39;] = cost
                solution_g.edge_attr[e][&#39;label&#39;] = &#34;%d/%d/%d&#34; %(flow,capacity,cost)
        return solution_g

    def simplex_connect(self, solution_g):
        &#39;&#39;&#39;
        API:
            simplex_connect(self, solution_g)
        Description:
            At this point we assume that the solution does not have a cycle.
            We check if all the nodes are connected, if not we add an arc to
            solution_g that does not create a cycle and return True. Otherwise
            we do nothing and return False.
        Pre:
            (1) We assume there is no cycle in the solution.
        Input:
            solution_g: current spanning tree solution instance.
        Post:
            (1) solution_g is updated. An arc that does not create a cycle is
            added.
            (2) &#39;component&#39; attribute of nodes are changed.
        Return:
            Returns True if an arc is added, returns False otherwise.
        &#39;&#39;&#39;
        nl = solution_g.get_node_list()
        current = nl[0]
        pred = solution_g.simplex_search(current, current)
        separated = list(pred.keys())
        for n in nl:
            if solution_g.get_node(n).get_attr(&#39;component&#39;) != current:
                # find an arc from n to seperated
                for m in separated:
                    if (n,m) in self.edge_attr:
                        solution_g.add_edge(n,m)
                        return True
                    elif (m,n) in self.edge_attr:
                        solution_g.add_edge(m,n)
                        return True
        return False

    def simplex_search(self, source, component_nr):
        &#39;&#39;&#39;
        API:
            simplex_search(self, source, component_nr)
        Description:
            Searches graph starting from source. Its difference from usual
            search is we can also go backwards along an arc. When the graph
            is a spanning tree it computes predecessor, thread and depth
            indexes and stores them as node attributes. These values should be
            considered as junk when the graph is not a spanning tree.
        Input:
            source: source node
            component_nr: component number
        Post:
            (1) Sets the component number of all reachable nodes to component.
            Changes &#39;component&#39; attribute of nodes.
            (2) Sets &#39;pred&#39;, &#39;thread&#39; and &#39;depth&#39; attributes of nodes. These
            values are junk if the graph is not a tree.
        Return:
            Returns predecessor dictionary.
        &#39;&#39;&#39;
        q = [source]
        pred = {source:None}
        depth = {source:0}
        sequence = []
        for n in self.neighbors:
            self.get_node(n).set_attr(&#39;component&#39;, None)
        while q:
            current = q.pop()
            self.get_node(current).set_attr(&#39;component&#39;, component_nr)
            sequence.append(current)
            neighbors = self.in_neighbors[current] + self.neighbors[current]
            for n in neighbors:
                if n in pred:
                    continue
                self.get_node(n).set_attr(&#39;component&#39;, component_nr)
                pred[n] = current
                depth[n] = depth[current]+1
                q.append(n)
        for i in range(len(sequence)-1):
            self.get_node(sequence[i]).set_attr(&#39;thread&#39;, int(sequence[i+1]))
        self.get_node(sequence[-1]).set_attr(&#39;thread&#39;, int(sequence[0]))
        for n in pred:
            self.get_node(n).set_attr(&#39;pred&#39;, pred[n])
            self.get_node(n).set_attr(&#39;depth&#39;, depth[n])
        return pred

    def simplex_augment_cycle(self, cycle):
        &#39;&#39;&#39;
        API:
            simplex_augment_cycle(self, cycle)
        Description:
            Augments along the cycle to break it.
        Pre:
            &#39;flow&#39;, &#39;capacity&#39; attributes on arcs.
        Input:
            cycle: list representing a cycle in the solution
        Post:
            &#39;flow&#39; attribute will be modified.
        &#39;&#39;&#39;
        # find amount to augment
        index = 0
        k = len(cycle)
        el = list(self.edge_attr.keys())
        # check arc (cycle[k-1], cycle[0])
        if (cycle[k-1], cycle[0]) in el:
            min_capacity = self.edge_attr[(cycle[k-1], cycle[0])][&#39;capacity&#39;]-\
                              self.edge_attr[(cycle[k-1], cycle[0])][&#39;flow&#39;]
        else:
            min_capacity = self.edge_attr[(cycle[0], cycle[k-1])][&#39;flow&#39;]
        # check rest of the arcs in the cycle
        while index&lt;(k-1):
            i = cycle[index]
            j = cycle[index+1]
            if (i,j) in el:
                capacity_ij = self.edge_attr[(i,j)][&#39;capacity&#39;] -\
                              self.edge_attr[(i,j)][&#39;flow&#39;]
            else:
                capacity_ij = self.edge_attr[(j,i)][&#39;flow&#39;]
            if min_capacity &gt; capacity_ij:
                min_capacity = capacity_ij
            index += 1
        return min_capacity

    def simplex_find_cycle(self):
        &#39;&#39;&#39;
        API:
            simplex_find_cycle(self)
        Description:
            Returns a cycle (list of nodes) if the graph has one, returns None
            otherwise. Uses DFS. During DFS checks existence of arcs to lower
            depth regions. Note that direction of the arcs are not important.
        Return:
            Returns list of nodes that represents cycle. Returns None if the
            graph does not have any cycle.
        &#39;&#39;&#39;
        # make a dfs, if you identify an arc to a lower depth node we have a
        # cycle
        nl = self.get_node_list()
        q = [nl[0]]
        visited = []
        depth = {nl[0]:0}
        pred = {nl[0]:None}
        for n in nl:
            self.get_node(n).set_attr(&#39;component&#39;, None)
        component_nr = int(nl[0])
        self.get_node(nl[0]).set_attr(&#39;component&#39;, component_nr)
        while True:
            while q:
                current = q.pop()
                visited.append(current)
                neighbors = self.in_neighbors[current] +\
                    self.neighbors[current]
                for n in neighbors:
                    if n==pred[current]:
                        continue
                    self.get_node(n).set_attr(&#39;component&#39;, component_nr)
                    if n in depth:
                        # we have a cycle
                        cycle1 = []
                        cycle2 = []
                        temp = n
                        while temp is not None:
                            cycle1.append(temp)
                            temp = pred[temp]
                        temp = current
                        while temp is not None:
                            cycle2.append(temp)
                            temp = pred[temp]
                        cycle1.pop()
                        cycle1.reverse()
                        cycle2.extend(cycle1)
                        return cycle2
                    else:
                        pred[n] = current
                        depth[n] = depth[current] + 1
                    if n not in visited:
                        q.append(n)
            flag = False
            for n in nl:
                if self.get_node(n).get_attr(&#39;component&#39;) is None:
                    q.append(n)
                    depth = {n:0}
                    pred = {n:None}
                    visited = []
                    component_nr = int(n)
                    self.get_node(n).set_attr(&#39;component&#39;, component_nr)
                    flag = True
                    break
            if not flag:
                break
        return None

    def get_simplex_solution_graph(self):
        &#39;&#39;&#39;
        API:
            get_simplex_solution_graph(self):
        Description:
            Assumes a feasible flow solution stored in &#39;flow&#39; attribute&#39;s of
            arcs. Returns the graph with arcs that have flow between 0 and
            capacity.
        Pre:
            (1) &#39;flow&#39; attribute represents a feasible flow solution. See
            Pre section of min_cost_flow() for details.
        Return:
            Graph instance that only has the arcs that have flow strictly
            between 0 and capacity.
        &#39;&#39;&#39;
        simplex_g = Graph(type=DIRECTED_GRAPH)
        for i in self.neighbors:
            simplex_g.add_node(i)
        for e in self.edge_attr:
            flow_e = self.edge_attr[e][&#39;flow&#39;]
            capacity_e = self.edge_attr[e][&#39;capacity&#39;]
            if flow_e&gt;0 and flow_e&lt;capacity_e:
                simplex_g.add_edge(e[0], e[1])
        return simplex_g

    def simplex_compute_potentials(self, t, root):
        &#39;&#39;&#39;
        API:
            simplex_compute_potentials(self, t, root)
        Description:
            Computes node potentials for a minimum cost flow problem and stores
            them as node attribute &#39;potential&#39;. Based on pseudocode given in
            Network Flows by Ahuja et al.
        Pre:
            (1) Assumes a directed graph in which each arc has a &#39;cost&#39;
            attribute.
            (2) Uses &#39;thread&#39; and &#39;pred&#39; attributes of nodes.
        Input:
            t: Current spanning tree solution, its type is Graph.
            root: root node of the tree.
        Post:
            Keeps the node potentials as &#39;potential&#39; attribute.
        &#39;&#39;&#39;
        self.get_node(root).set_attr(&#39;potential&#39;, 0)
        j = t.get_node(root).get_attr(&#39;thread&#39;)
        while j is not root:
            i = t.get_node(j).get_attr(&#39;pred&#39;)
            potential_i = self.get_node(i).get_attr(&#39;potential&#39;)
            if (i,j) in self.edge_attr:
                c_ij = self.edge_attr[(i,j)][&#39;cost&#39;]
                self.get_node(j).set_attr(&#39;potential&#39;, potential_i-c_ij)
            if (j,i) in self.edge_attr:
                c_ji = self.edge_attr[(j,i)][&#39;cost&#39;]
                self.get_node(j).set_attr(&#39;potential&#39;, potential_i+c_ji)
            j = t.get_node(j).get_attr(&#39;thread&#39;)

    def simplex_identify_cycle(self, t, k, l):
        &#39;&#39;&#39;
        API:
            identify_cycle(self, t, k, l)
        Description:
            Identifies and returns to the pivot cycle, which is a list of
            nodes.
        Pre:
            (1) t is spanning tree solution, (k,l) is the entering arc.
        Input:
            t: current spanning tree solution
            k: tail of the entering arc
            l: head of the entering arc
        Returns:
            List of nodes in the cycle.
        &#39;&#39;&#39;
        i = k
        j = l
        cycle = []
        li = [k]
        lj = [j]
        while i is not j:
            depth_i = t.get_node(i).get_attr(&#39;depth&#39;)
            depth_j = t.get_node(j).get_attr(&#39;depth&#39;)
            if depth_i &gt; depth_j:
                i = t.get_node(i).get_attr(&#39;pred&#39;)
                li.append(i)
            elif depth_i &lt; depth_j:
                j = t.get_node(j).get_attr(&#39;pred&#39;)
                lj.append(j)
            else:
                i = t.get_node(i).get_attr(&#39;pred&#39;)
                li.append(i)
                j = t.get_node(j).get_attr(&#39;pred&#39;)
                lj.append(j)
        cycle.extend(lj)
        li.pop()
        li.reverse()
        cycle.extend(li)
        # l is beginning k is end
        return cycle

    def min_cost_flow(self, display = None, **args):
        &#39;&#39;&#39;
        API:
            min_cost_flow(self, display=&#39;off&#39;, **args)
        Description:
            Solves minimum cost flow problem using node/edge attributes with
            the algorithm specified.
        Pre:
            (1) Assumes a directed graph in which each arc has &#39;capacity&#39; and
            &#39;cost&#39; attributes.
            (2) Nodes should have &#39;demand&#39; attribute. This value should be
            positive for supply and negative for demand, and 0 for transhipment
            nodes.
            (3) The graph should be connected.
            (4) Assumes (i,j) and (j,i) does not exist together. Needed when
            solving max flow. (max flow problem is solved to get a feasible
            flow).
        Input:
            display: &#39;off&#39; for no display, &#39;matplotlib&#39; for live update of tree
            args: may have the following
                display: display method, if not given current mode (the one
                    specified by __init__ or set_display) will be used.
                algo: determines algorithm to use, can be one of the following
                    &#39;simplex&#39;: network simplex algorithm
                    &#39;cycle_canceling&#39;: cycle canceling algorithm
                    &#39;simplex&#39; is used if not given.
                    see Network Flows by Ahuja et al. for details of algorithms.
                pivot: valid if algo is &#39;simlex&#39;, determines pivoting rule for
                    simplex, may be one of the following; &#39;first_eligible&#39;,
                    &#39;dantzig&#39; or &#39;scaled&#39;.
                    &#39;dantzig&#39; is used if not given.
                    see Network Flows by Ahuja et al. for pivot rules.
                root: valid if algo is &#39;simlex&#39;, specifies the root node for
                    simplex algorithm. It is name of the one of the nodes. It
                    will be chosen randomly if not provided.
        Post:
            The &#39;flow&#39; attribute of each arc gives the optimal flows.
            &#39;distance&#39; attribute of the nodes are also changed during max flow
            solution process.
        Examples:
            g.min_cost_flow():
                solves minimum cost feasible flow problem using simplex
                algorithm with dantzig pivoting rule.
                See pre section for details.
            g.min_cost_flow(algo=&#39;cycle_canceling&#39;):
                solves minimum cost feasible flow problem using cycle canceling
                agorithm.
            g.min_cost_flow(algo=&#39;simplex&#39;, pivot=&#39;scaled&#39;):
                solves minimum cost feasible flow problem using network simplex
                agorithm with scaled pivot rule.
        &#39;&#39;&#39;
        if display is None:
            display = self.attr[&#39;display&#39;]
        if &#39;algo&#39; in args:
            algorithm = args[&#39;algo&#39;]
        else:
            algorithm = &#39;simplex&#39;
        if algorithm == &#39;simplex&#39;:
            if &#39;root&#39; in args:
                root = args[&#39;root&#39;]
            else:
                for k in self.neighbors:
                    root = k
                    break
            if &#39;pivot&#39; in args:
                if not self.network_simplex(display, args[&#39;pivot&#39;], root):
                    print(&#39;problem is infeasible&#39;)
            else:
                if not self.network_simplex(display, &#39;dantzig&#39;, root):
                    print(&#39;problem is infeasible&#39;)
        elif algorithm == &#39;cycle_canceling&#39;:
            if not self.cycle_canceling(display):
                print(&#39;problem is infeasible&#39;)
        else:
            print(args[&#39;algo&#39;], &#39;is not a defined algorithm. Exiting.&#39;)
            return

    def random(self, numnodes = 10, degree_range = (2, 4), length_range = (1, 10),
               density = None, edge_format = None, node_format = None,
               Euclidean = False, seedInput = 0, add_labels = True,
               parallel_allowed = False, node_selection = &#39;closest&#39;,
               scale = 10, scale_cost = 5):
        &#39;&#39;&#39;
        API:
            random(self, numnodes = 10, degree_range = None, length_range = None,
               density = None, edge_format = None, node_format = None,
               Euclidean = False, seedInput = 0)
        Description:
            Populates graph with random edges and nodes.
        Input:
            numnodes: Number of nodes to add.
            degree_range: A tuple that has lower and upper bounds of degree for
            a node.
            length_range: A tuple that has lower and upper bounds for &#39;cost&#39;
            attribute of edges.
            density: Density of edges, ie. 0.5 indicates a node will
            approximately have edge to half of the other nodes.
            edge_format: Dictionary that specifies attribute values for edges.
            node_format: Dictionary that specifies attribute values for nodes.
            Euclidean: Creates an Euclidean graph (Euclidean distance between
            nodes) if True.
            seedInput: Seed that will be used for random number generation.
        Pre:
            It is recommended to call this method on empty Graph objects.
        Post:
            Graph will be populated by nodes and edges.
        &#39;&#39;&#39;
        random.seed(seedInput)
        if edge_format == None:
            edge_format = {&#39;fontsize&#39;:10,
                           &#39;fontcolor&#39;:&#39;blue&#39;}
        if node_format == None:
            node_format = {&#39;height&#39;:0.5,
                           &#39;width&#39;:0.5,
                           &#39;fixedsize&#39;:&#39;true&#39;,
                           &#39;fontsize&#39;:10,
                           &#39;fontcolor&#39;:&#39;red&#39;,
                           &#39;shape&#39;:&#39;circle&#39;,
                           }
        if Euclidean == False:
            for m in range(numnodes):
                self.add_node(m, **node_format)
            if degree_range is not None and density is None:
                for m in range(numnodes):
                    degree = random.randint(degree_range[0], degree_range[1])
                    i = 0
                    while i &lt; degree:
                        n = random.randint(1, numnodes-1)
                        if (((m,n) not in self.edge_attr and m != n) and
                            (parallel_allowed or (n, m) not in self.edge_attr)):
                            if length_range is not None:
                                length = random.randint(length_range[0],
                                                        length_range[1])
                                self.add_edge(m, n, cost = length, **edge_format)
                                if add_labels:
                                    self.set_edge_attr(m, n, &#39;label&#39;, str(length))
                                else:
                                    self.add_edge(m, n, **edge_format)
                        i += 1
            elif density != None:
                for m in range(numnodes):
                    if self.graph_type == DIRECTED_GRAPH:
                        numnodes2 = numnodes
                    else:
                        numnodes2 = m
                    for n in range(numnodes2):
                        if ((parallel_allowed or (n, m) not in self.edge_attr)
                            and m != n):
                            if random.random() &lt; density:
                                if length_range is not None:
                                    length = random.randint(length_range[0],
                                                     length_range[1])
                                    self.add_edge(m, n, cost = length,
                                                  **edge_format)
                                    if add_labels:
                                        self.set_edge_attr(m, n, &#39;label&#39;, str(length))
                                else:
                                    self.add_edge(m, n, **edge_format)
            else:
                print(&#34;Must set either degree range or density&#34;)
        else:
            for m in range(numnodes):
                &#39;&#39;&#39; Assigns random coordinates (between 1 and 20) to the nodes
                &#39;&#39;&#39;
                x = random.random()*scale
                y = random.random()*scale
                self.add_node(m, locationx = x, locationy = y,
                              pos = &#39;&#34;&#39;+str(x) + &#34;,&#34; + str(y)+&#39;!&#34;&#39;,
                              **node_format)
            if degree_range is not None and density is None:
                for m in range(numnodes):
                    degree = random.randint(degree_range[0], degree_range[1])
                    i = 0
                    neighbors = []
                    if node_selection == &#39;random&#39;:
                        while i &lt; degree:
                            length = round((((self.get_node(n).get_attr(&#39;locationx&#39;) -
                                              self.get_node(m).get_attr(&#39;locationx&#39;)) ** 2 +
                                             (self.get_node(n).get_attr(&#39;locationy&#39;) -
                                              self.get_node(m).get_attr(&#39;locationy&#39;)) ** 2) ** 0.5)*scale_cost,
                                           0)
                            if (((m,n) not in self.edge_attr and m != n) and
                                (parallel_allowed or (n, m) not in self.edge_attr)):
                                neighbors.append(random.randint(0, numnodes-1))
                                self.add_edge(m, n, cost = int(length), **edge_format)
                                if add_labels:
                                    self.set_edge_attr(m, n, &#39;label&#39;, str(int(length)))
                                i += 1
                    elif node_selection == &#39;closest&#39;:
                        lengths = []
                        for n in range(numnodes):
                            lengths.append((n, round((((self.get_node(n).get_attr(&#39;locationx&#39;) -
                                                        self.get_node(m).get_attr(&#39;locationx&#39;)) ** 2 +
                                                       (self.get_node(n).get_attr(&#39;locationy&#39;) -
                                                        self.get_node(m).get_attr(&#39;locationy&#39;)) ** 2) ** 0.5)*scale_cost,
                                                     0)))
                        lengths.sort(key = lambda l : l[1])
                        for i in range(degree+1):
                            if not (lengths[i][0] == m or self.check_edge(m, lengths[i][0])):
                                self.add_edge(m, lengths[i][0], cost = int(lengths[i][1]), **edge_format)
                                if add_labels:
                                    self.set_edge_attr(m, lengths[i][0], &#39;label&#39;, str(int(lengths[i][1])))
                    else:
                        print(&#34;Unknown node selection rule...exiting&#34;)
                        return
            elif density != None:
                for m in range(numnodes):
                    if self.graph_type == DIRECTED_GRAPH:
                        numnodes2 = numnodes
                    else:
                        numnodes2 = m
                    for n in range(numnodes2):
                        if ((parallel_allowed or (n, m) not in self.edge_attr)
                            and m != n):
                            if random.random() &lt; density:
                                if length_range is None:
                                    &#39;&#39;&#39; calculates the euclidean norm and round it
                                    to an integer &#39;&#39;&#39;
                                    length = round((((self.get_node(n).get_attr(&#39;locationx&#39;) -
                                                      self.get_node(m).get_attr(&#39;locationx&#39;)) ** 2 +
                                                     (self.get_node(n).get_attr(&#39;locationy&#39;) -
                                                      self.get_node(m).get_attr(&#39;locationy&#39;)) ** 2) ** 0.5), 0)
                                    self.add_edge(m, n, cost = int(length), **edge_format)
                                    if add_labels:
                                        self.set_edge_attr(m, n, &#39;label&#39;, str(int(length)))
                                else:
                                    self.add_edge(m, n, **edge_format)
            else:
                print(&#34;Must set either degree range or density&#34;)

    def page_rank(self, damping_factor=0.85, max_iterations=100,
                  min_delta=0.00001):
        &#39;&#39;&#39;
        API:
            page_rank(self, damping_factor=0.85, max_iterations=100,
                  min_delta=0.00001)
        Description:
            Compute and return the page-rank of a directed graph.
            This function was originally taken from here and modified for this
            graph class: http://code.google.com/p/python-graph/source/browse/
            trunk/core/pygraph/algorithms/pagerank.py
        Input:
            damping_factor: Damping factor.
            max_iterations: Maximum number of iterations.
            min_delta: Smallest variation required to have a new iteration.
        Pre:
            Graph should be a directed graph.
        Return:
            Returns dictionary of page-ranks. Keys are node names, values are
            corresponding page-ranks.
        &#39;&#39;&#39;
        nodes = self.get_node_list()
        graph_size = len(nodes)
        if graph_size == 0:
            return {}
        #value for nodes without inbound links
        min_value = old_div((1.0-damping_factor),graph_size)
        # itialize the page rank dict with 1/N for all nodes
        pagerank = dict.fromkeys(nodes, old_div(1.0,graph_size))
        for _ in range(max_iterations):
            diff = 0 #total difference compared to last iteraction
            # computes each node PageRank based on inbound links
            for node in nodes:
                rank = min_value
                for referring_page in self.get_in_neighbors(node):
                    rank += (damping_factor * pagerank[referring_page] /
                             len(self.get_neighbors(referring_page)))
                diff += abs(pagerank[node] - rank)
                pagerank[node] = rank
            #stop if PageRank has converged
            if diff &lt; min_delta:
                break
        return pagerank

    def get_degrees(self):
        &#39;&#39;&#39;
        API:
            get_degree(self)
        Description:
            Returns degrees of nodes in dictionary format.
        Return:
            Returns a dictionary of node degrees. Keys are node names, values
            are corresponding degrees.
        &#39;&#39;&#39;
        degree = {}
        if self.attr[&#39;type&#39;] is not DIRECTED_GRAPH:
            for n in self.get_node_list():
                degree[n] = len(self.get_neighbors(n))
            return degree
        else:
            for n in self.get_node_list():
                degree[n] = (len(self.get_in_neighbors(n)) +
                             len(self.get_out_neighbors(n)))

    def get_in_degrees(self):
        &#39;&#39;&#39;
        API:
            get_degree(self)
        Description:
            Returns degrees of nodes in dictionary format.
        Return:
            Returns a dictionary of node degrees. Keys are node names, values
            are corresponding degrees.
        &#39;&#39;&#39;
        degree = {}
        if self.attr[&#39;type&#39;] is not DIRECTED_GRAPH:
            print(&#39;This function only works for directed graphs&#39;)
            return
        for n in self.get_node_list():
            degree[n] = len(self.get_in_neighbors(n))
        return degree

    def get_out_degrees(self):
        &#39;&#39;&#39;
        API:
            get_degree(self)
        Description:
            Returns degrees of nodes in dictionary format.
        Return:
            Returns a dictionary of node degrees. Keys are node names, values
            are corresponding degrees.
        &#39;&#39;&#39;
        degree = {}
        if self.attr[&#39;type&#39;] is not DIRECTED_GRAPH:
            print(&#39;This function only works for directed graphs&#39;)
            return
        for n in self.get_node_list():
            degree[n] = len(self.get_out_neighbors(n))
        return degree

    def get_diameter(self):
        &#39;&#39;&#39;
        API:
            get_diameter(self)
        Description:
            Returns diameter of the graph. Diameter is defined as follows.
            distance(n,m): shortest unweighted path from n to m
            eccentricity(n) = $\max _m distance(n,m)$
            diameter = $\min _n eccentricity(n) = \min _n \max _m distance(n,m)$
        Return:
            Returns diameter of the graph.
        &#39;&#39;&#39;

        if self.attr[&#39;type&#39;] is not UNDIRECTED_GRAPH:
            print(&#39;This function only works for undirected graphs&#39;)
            return
        diameter = &#39;infinity&#39;
        eccentricity_n = 0
        for n in self.get_node_list():
            for m in self.get_node_list():
                path_n_m = self.search(n, destination = m, algo = &#39;BFS&#39;)
                if path_n_m is None:
                    # this indicates there is no path from n to m, no diameter
                    # is defined, since the graph is not connected, return
                    # &#39;infinity&#39;
                    return &#39;infinity&#39;
                distance_n_m = len(path_n_m)-1
                if distance_n_m &gt; eccentricity_n:
                    eccentricity_n = distance_n_m
            if diameter == &#39;infinity&#39; or eccentricity_n &gt; diameter:
                diameter = eccentricity_n
        return diameter

    def create_cluster(self, node_list, cluster_attrs={}, node_attrs={}):
        &#39;&#39;&#39;
        API:
            create_cluster(self, node_list, cluster_attrs, node_attrs)
        Description:
            Creates a cluster from the node given in the node list.
        Input:
            node_list: List of nodes in the cluster.
            cluster_attrs: Dictionary of cluster attributes, see Dot language
            grammer documentation for details.
            node_attrs: Dictionary of node attributes. It will overwrite
            previous attributes of the nodes in the cluster.
        Post:
            A cluster will be created. Attributes of the nodes in the cluster
            may change.
        &#39;&#39;&#39;
        if &#39;name&#39; in cluster_attrs:
            if &#39;name&#39; in self.cluster:
                raise Exception(&#39;A cluster with name %s already exists!&#39; %cluster_attrs[&#39;name&#39;])
            else:
                name = cluster_attrs[&#39;name&#39;]
        else:
            name = &#39;c%d&#39; %self.attr[&#39;cluster_count&#39;]
            self.attr[&#39;cluster_count&#39;] += 1
            cluster_attrs[&#39;name&#39;] = name
        #cluster_attrs[&#39;name&#39;] =
        self.cluster[name] = {&#39;node_list&#39;:node_list,
                              &#39;attrs&#39;:copy.deepcopy(cluster_attrs),
                              &#39;node_attrs&#39;:copy.deepcopy(node_attrs)}


class DisjointSet(Graph):
    &#39;&#39;&#39;
    Disjoint set data structure. Inherits Graph class.
    &#39;&#39;&#39;
    def __init__(self, optimize = True, **attrs):
        &#39;&#39;&#39;
        API:
            __init__(self, optimize = True, **attrs):
        Description:
            Class constructor.
        Input:
            optimize: Optimizes find() if True.
            attrs: Graph attributes.
        Post:
            self.optimize will be updated.
        &#39;&#39;&#39;
        attrs[&#39;type&#39;] = DIRECTED_GRAPH
        Graph.__init__(self, **attrs)
        self.sizes = {}
        self.optimize = optimize

    def add(self, aList):
        &#39;&#39;&#39;
        API:
            add(self, aList)
        Description:
            Adds items in the list to the set.
        Input:
            aList: List of items.
        Post:
            self.sizes will be updated.
        &#39;&#39;&#39;
        self.add_node(aList[0])
        for i in range(1, len(aList)):
            self.add_edge(aList[i], aList[0])
        self.sizes[aList[0]] = len(aList)

    def union(self, i, j):
        &#39;&#39;&#39;
        API:
            union(self, i, j):
        Description:
            Finds sets of i and j and unites them.
        Input:
            i: Item.
            j: Item.
        Post:
            self.sizes will be updated.
        &#39;&#39;&#39;
        roots = (self.find(i), self.find(j))
        if roots[0] == roots[1]:
            return False
        if self.sizes[roots[0]] &lt;= self.sizes[roots[1]] or not self.optimize:
            self.add_edge(roots[0], roots[1])
            self.sizes[roots[1]] += self.sizes[roots[0]]
            return True
        else:
            self.add_edge(roots[1], roots[0])
            self.sizes[roots[0]] += self.sizes[roots[1]]
            return True

    def find(self, i):
        &#39;&#39;&#39;
        API:
            find(self, i)
        Description:
            Returns root of set that has i.
        Input:
            i: Item.
        Return:
            Returns root of set that has i.
        &#39;&#39;&#39;
        current = i
        edge_list = []
        while len(self.get_neighbors(current)) != 0:
            successor = self.get_neighbors(current)[0]
            edge_list.append((current, successor))
            current = successor
        if self.optimize:
            for e in edge_list:
                if e[1] != current:
                    self.del_edge((e[0], e[1]))
                    self.add_edge(e[0], current)
        return current


if __name__ == &#39;__main__&#39;:
    G = Graph(type = UNDIRECTED_GRAPH, splines = &#39;true&#39;, K = 1.5)
    #G.random(numnodes = 20, Euclidean = True, seedInput = 11,
    #         add_labels = False,
    #         scale = 10,
    #         scale_cost = 10,
    #         #degree_range = (2, 4),
    #         #length_range = (1, 10)
    #         )
    #page_ranks = sorted(G.page_rank().iteritems(), key=operator.itemgetter(1))
    #page_ranks.reverse()
    #for i in page_ranks:
    #    print i    #G = Graph(type = UNDIRECTED_GRAPH, splines = &#39;true&#39;, K = 1.5)
    G.random(numnodes = 10, Euclidean = True, seedInput = 13,
             add_labels = True,
             scale = 10,
             scale_cost = 10,
             #degree_range = (2, 4),
             #length_range = (1, 10)
             )
    G.set_display_mode(&#39;matplotlib&#39;)
    G.display()
    #G.dfs(0)
    G.search(0, display = &#39;matplotlib&#39;, algo = &#39;Prim&#39;)
    #G.minimum_spanning_tree_kruskal()</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="coinor.gimpy.graph.handle_close"><code class="name flex">
<span>def <span class="ident">handle_close</span></span>(<span>evt)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def handle_close(evt):
    print(&#39;Figure closed. Exiting!&#39;)
    plt.close(&#39;all&#39;)</code></pre>
</details>
</dd>
</dl>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="coinor.gimpy.graph.DisjointSet"><code class="flex name class">
<span>class <span class="ident">DisjointSet</span></span>
<span>(</span><span>optimize=True, **attrs)</span>
</code></dt>
<dd>
<div class="desc"><p>Disjoint set data structure. Inherits Graph class.</p>
<h2 id="api">Api</h2>
<p><strong>init</strong>(self, optimize = True, **attrs):</p>
<h2 id="description">Description</h2>
<p>Class constructor.</p>
<h2 id="input">Input</h2>
<p>optimize: Optimizes find() if True.
attrs: Graph attributes.</p>
<h2 id="post">Post</h2>
<p>self.optimize will be updated.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class DisjointSet(Graph):
    &#39;&#39;&#39;
    Disjoint set data structure. Inherits Graph class.
    &#39;&#39;&#39;
    def __init__(self, optimize = True, **attrs):
        &#39;&#39;&#39;
        API:
            __init__(self, optimize = True, **attrs):
        Description:
            Class constructor.
        Input:
            optimize: Optimizes find() if True.
            attrs: Graph attributes.
        Post:
            self.optimize will be updated.
        &#39;&#39;&#39;
        attrs[&#39;type&#39;] = DIRECTED_GRAPH
        Graph.__init__(self, **attrs)
        self.sizes = {}
        self.optimize = optimize

    def add(self, aList):
        &#39;&#39;&#39;
        API:
            add(self, aList)
        Description:
            Adds items in the list to the set.
        Input:
            aList: List of items.
        Post:
            self.sizes will be updated.
        &#39;&#39;&#39;
        self.add_node(aList[0])
        for i in range(1, len(aList)):
            self.add_edge(aList[i], aList[0])
        self.sizes[aList[0]] = len(aList)

    def union(self, i, j):
        &#39;&#39;&#39;
        API:
            union(self, i, j):
        Description:
            Finds sets of i and j and unites them.
        Input:
            i: Item.
            j: Item.
        Post:
            self.sizes will be updated.
        &#39;&#39;&#39;
        roots = (self.find(i), self.find(j))
        if roots[0] == roots[1]:
            return False
        if self.sizes[roots[0]] &lt;= self.sizes[roots[1]] or not self.optimize:
            self.add_edge(roots[0], roots[1])
            self.sizes[roots[1]] += self.sizes[roots[0]]
            return True
        else:
            self.add_edge(roots[1], roots[0])
            self.sizes[roots[0]] += self.sizes[roots[1]]
            return True

    def find(self, i):
        &#39;&#39;&#39;
        API:
            find(self, i)
        Description:
            Returns root of set that has i.
        Input:
            i: Item.
        Return:
            Returns root of set that has i.
        &#39;&#39;&#39;
        current = i
        edge_list = []
        while len(self.get_neighbors(current)) != 0:
            successor = self.get_neighbors(current)[0]
            edge_list.append((current, successor))
            current = successor
        if self.optimize:
            for e in edge_list:
                if e[1] != current:
                    self.del_edge((e[0], e[1]))
                    self.add_edge(e[0], current)
        return current</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="coinor.gimpy.graph.Graph" href="#coinor.gimpy.graph.Graph">Graph</a></li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="coinor.gimpy.graph.DisjointSet.add"><code class="name flex">
<span>def <span class="ident">add</span></span>(<span>self, aList)</span>
</code></dt>
<dd>
<div class="desc"><h2 id="api">Api</h2>
<p>add(self, aList)</p>
<h2 id="description">Description</h2>
<p>Adds items in the list to the set.</p>
<h2 id="input">Input</h2>
<p>aList: List of items.</p>
<h2 id="post">Post</h2>
<p>self.sizes will be updated.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def add(self, aList):
    &#39;&#39;&#39;
    API:
        add(self, aList)
    Description:
        Adds items in the list to the set.
    Input:
        aList: List of items.
    Post:
        self.sizes will be updated.
    &#39;&#39;&#39;
    self.add_node(aList[0])
    for i in range(1, len(aList)):
        self.add_edge(aList[i], aList[0])
    self.sizes[aList[0]] = len(aList)</code></pre>
</details>
</dd>
<dt id="coinor.gimpy.graph.DisjointSet.find"><code class="name flex">
<span>def <span class="ident">find</span></span>(<span>self, i)</span>
</code></dt>
<dd>
<div class="desc"><h2 id="api">Api</h2>
<p>find(self, i)</p>
<h2 id="description">Description</h2>
<p>Returns root of set that has i.</p>
<h2 id="input">Input</h2>
<p>i: Item.</p>
<h2 id="return">Return</h2>
<p>Returns root of set that has i.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def find(self, i):
    &#39;&#39;&#39;
    API:
        find(self, i)
    Description:
        Returns root of set that has i.
    Input:
        i: Item.
    Return:
        Returns root of set that has i.
    &#39;&#39;&#39;
    current = i
    edge_list = []
    while len(self.get_neighbors(current)) != 0:
        successor = self.get_neighbors(current)[0]
        edge_list.append((current, successor))
        current = successor
    if self.optimize:
        for e in edge_list:
            if e[1] != current:
                self.del_edge((e[0], e[1]))
                self.add_edge(e[0], current)
    return current</code></pre>
</details>
</dd>
<dt id="coinor.gimpy.graph.DisjointSet.union"><code class="name flex">
<span>def <span class="ident">union</span></span>(<span>self, i, j)</span>
</code></dt>
<dd>
<div class="desc"><h2 id="api">Api</h2>
<p>union(self, i, j):</p>
<h2 id="description">Description</h2>
<p>Finds sets of i and j and unites them.</p>
<h2 id="input">Input</h2>
<p>i: Item.
j: Item.</p>
<h2 id="post">Post</h2>
<p>self.sizes will be updated.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def union(self, i, j):
    &#39;&#39;&#39;
    API:
        union(self, i, j):
    Description:
        Finds sets of i and j and unites them.
    Input:
        i: Item.
        j: Item.
    Post:
        self.sizes will be updated.
    &#39;&#39;&#39;
    roots = (self.find(i), self.find(j))
    if roots[0] == roots[1]:
        return False
    if self.sizes[roots[0]] &lt;= self.sizes[roots[1]] or not self.optimize:
        self.add_edge(roots[0], roots[1])
        self.sizes[roots[1]] += self.sizes[roots[0]]
        return True
    else:
        self.add_edge(roots[1], roots[0])
        self.sizes[roots[0]] += self.sizes[roots[1]]
        return True</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="coinor.gimpy.graph.Graph" href="#coinor.gimpy.graph.Graph">Graph</a></b></code>:
<ul class="hlist">
<li><code><a title="coinor.gimpy.graph.Graph.add_edge" href="#coinor.gimpy.graph.Graph.add_edge">add_edge</a></code></li>
<li><code><a title="coinor.gimpy.graph.Graph.add_node" href="#coinor.gimpy.graph.Graph.add_node">add_node</a></code></li>
<li><code><a title="coinor.gimpy.graph.Graph.augment_cycle" href="#coinor.gimpy.graph.Graph.augment_cycle">augment_cycle</a></code></li>
<li><code><a title="coinor.gimpy.graph.Graph.bfs" href="#coinor.gimpy.graph.Graph.bfs">bfs</a></code></li>
<li><code><a title="coinor.gimpy.graph.Graph.check_edge" href="#coinor.gimpy.graph.Graph.check_edge">check_edge</a></code></li>
<li><code><a title="coinor.gimpy.graph.Graph.create" href="#coinor.gimpy.graph.Graph.create">create</a></code></li>
<li><code><a title="coinor.gimpy.graph.Graph.create_cluster" href="#coinor.gimpy.graph.Graph.create_cluster">create_cluster</a></code></li>
<li><code><a title="coinor.gimpy.graph.Graph.create_residual_graph" href="#coinor.gimpy.graph.Graph.create_residual_graph">create_residual_graph</a></code></li>
<li><code><a title="coinor.gimpy.graph.Graph.cycle_canceling" href="#coinor.gimpy.graph.Graph.cycle_canceling">cycle_canceling</a></code></li>
<li><code><a title="coinor.gimpy.graph.Graph.del_edge" href="#coinor.gimpy.graph.Graph.del_edge">del_edge</a></code></li>
<li><code><a title="coinor.gimpy.graph.Graph.del_node" href="#coinor.gimpy.graph.Graph.del_node">del_node</a></code></li>
<li><code><a title="coinor.gimpy.graph.Graph.dfs" href="#coinor.gimpy.graph.Graph.dfs">dfs</a></code></li>
<li><code><a title="coinor.gimpy.graph.Graph.display" href="#coinor.gimpy.graph.Graph.display">display</a></code></li>
<li><code><a title="coinor.gimpy.graph.Graph.edge_to_string" href="#coinor.gimpy.graph.Graph.edge_to_string">edge_to_string</a></code></li>
<li><code><a title="coinor.gimpy.graph.Graph.fifo_label_correcting" href="#coinor.gimpy.graph.Graph.fifo_label_correcting">fifo_label_correcting</a></code></li>
<li><code><a title="coinor.gimpy.graph.Graph.find_cycle_capacity" href="#coinor.gimpy.graph.Graph.find_cycle_capacity">find_cycle_capacity</a></code></li>
<li><code><a title="coinor.gimpy.graph.Graph.find_feasible_flow" href="#coinor.gimpy.graph.Graph.find_feasible_flow">find_feasible_flow</a></code></li>
<li><code><a title="coinor.gimpy.graph.Graph.floyd_warshall" href="#coinor.gimpy.graph.Graph.floyd_warshall">floyd_warshall</a></code></li>
<li><code><a title="coinor.gimpy.graph.Graph.floyd_warshall_get_cycle" href="#coinor.gimpy.graph.Graph.floyd_warshall_get_cycle">floyd_warshall_get_cycle</a></code></li>
<li><code><a title="coinor.gimpy.graph.Graph.floyd_warshall_get_path" href="#coinor.gimpy.graph.Graph.floyd_warshall_get_path">floyd_warshall_get_path</a></code></li>
<li><code><a title="coinor.gimpy.graph.Graph.get_degrees" href="#coinor.gimpy.graph.Graph.get_degrees">get_degrees</a></code></li>
<li><code><a title="coinor.gimpy.graph.Graph.get_diameter" href="#coinor.gimpy.graph.Graph.get_diameter">get_diameter</a></code></li>
<li><code><a title="coinor.gimpy.graph.Graph.get_edge_attr" href="#coinor.gimpy.graph.Graph.get_edge_attr">get_edge_attr</a></code></li>
<li><code><a title="coinor.gimpy.graph.Graph.get_edge_cost" href="#coinor.gimpy.graph.Graph.get_edge_cost">get_edge_cost</a></code></li>
<li><code><a title="coinor.gimpy.graph.Graph.get_edge_list" href="#coinor.gimpy.graph.Graph.get_edge_list">get_edge_list</a></code></li>
<li><code><a title="coinor.gimpy.graph.Graph.get_edge_num" href="#coinor.gimpy.graph.Graph.get_edge_num">get_edge_num</a></code></li>
<li><code><a title="coinor.gimpy.graph.Graph.get_in_degrees" href="#coinor.gimpy.graph.Graph.get_in_degrees">get_in_degrees</a></code></li>
<li><code><a title="coinor.gimpy.graph.Graph.get_in_neighbors" href="#coinor.gimpy.graph.Graph.get_in_neighbors">get_in_neighbors</a></code></li>
<li><code><a title="coinor.gimpy.graph.Graph.get_layout" href="#coinor.gimpy.graph.Graph.get_layout">get_layout</a></code></li>
<li><code><a title="coinor.gimpy.graph.Graph.get_negative_cycle" href="#coinor.gimpy.graph.Graph.get_negative_cycle">get_negative_cycle</a></code></li>
<li><code><a title="coinor.gimpy.graph.Graph.get_neighbors" href="#coinor.gimpy.graph.Graph.get_neighbors">get_neighbors</a></code></li>
<li><code><a title="coinor.gimpy.graph.Graph.get_node" href="#coinor.gimpy.graph.Graph.get_node">get_node</a></code></li>
<li><code><a title="coinor.gimpy.graph.Graph.get_node_attr" href="#coinor.gimpy.graph.Graph.get_node_attr">get_node_attr</a></code></li>
<li><code><a title="coinor.gimpy.graph.Graph.get_node_list" href="#coinor.gimpy.graph.Graph.get_node_list">get_node_list</a></code></li>
<li><code><a title="coinor.gimpy.graph.Graph.get_node_num" href="#coinor.gimpy.graph.Graph.get_node_num">get_node_num</a></code></li>
<li><code><a title="coinor.gimpy.graph.Graph.get_out_degrees" href="#coinor.gimpy.graph.Graph.get_out_degrees">get_out_degrees</a></code></li>
<li><code><a title="coinor.gimpy.graph.Graph.get_out_neighbors" href="#coinor.gimpy.graph.Graph.get_out_neighbors">get_out_neighbors</a></code></li>
<li><code><a title="coinor.gimpy.graph.Graph.get_simplex_solution_graph" href="#coinor.gimpy.graph.Graph.get_simplex_solution_graph">get_simplex_solution_graph</a></code></li>
<li><code><a title="coinor.gimpy.graph.Graph.label_components" href="#coinor.gimpy.graph.Graph.label_components">label_components</a></code></li>
<li><code><a title="coinor.gimpy.graph.Graph.label_correcting_check_cycle" href="#coinor.gimpy.graph.Graph.label_correcting_check_cycle">label_correcting_check_cycle</a></code></li>
<li><code><a title="coinor.gimpy.graph.Graph.label_correcting_get_cycle" href="#coinor.gimpy.graph.Graph.label_correcting_get_cycle">label_correcting_get_cycle</a></code></li>
<li><code><a title="coinor.gimpy.graph.Graph.label_strong_component" href="#coinor.gimpy.graph.Graph.label_strong_component">label_strong_component</a></code></li>
<li><code><a title="coinor.gimpy.graph.Graph.max_flow" href="#coinor.gimpy.graph.Graph.max_flow">max_flow</a></code></li>
<li><code><a title="coinor.gimpy.graph.Graph.max_flow_preflowpush" href="#coinor.gimpy.graph.Graph.max_flow_preflowpush">max_flow_preflowpush</a></code></li>
<li><code><a title="coinor.gimpy.graph.Graph.min_cost_flow" href="#coinor.gimpy.graph.Graph.min_cost_flow">min_cost_flow</a></code></li>
<li><code><a title="coinor.gimpy.graph.Graph.minimum_spanning_tree_kruskal" href="#coinor.gimpy.graph.Graph.minimum_spanning_tree_kruskal">minimum_spanning_tree_kruskal</a></code></li>
<li><code><a title="coinor.gimpy.graph.Graph.minimum_spanning_tree_prim" href="#coinor.gimpy.graph.Graph.minimum_spanning_tree_prim">minimum_spanning_tree_prim</a></code></li>
<li><code><a title="coinor.gimpy.graph.Graph.network_simplex" href="#coinor.gimpy.graph.Graph.network_simplex">network_simplex</a></code></li>
<li><code><a title="coinor.gimpy.graph.Graph.page_rank" href="#coinor.gimpy.graph.Graph.page_rank">page_rank</a></code></li>
<li><code><a title="coinor.gimpy.graph.Graph.print_flow" href="#coinor.gimpy.graph.Graph.print_flow">print_flow</a></code></li>
<li><code><a title="coinor.gimpy.graph.Graph.process_edge_dijkstra" href="#coinor.gimpy.graph.Graph.process_edge_dijkstra">process_edge_dijkstra</a></code></li>
<li><code><a title="coinor.gimpy.graph.Graph.process_edge_flow" href="#coinor.gimpy.graph.Graph.process_edge_flow">process_edge_flow</a></code></li>
<li><code><a title="coinor.gimpy.graph.Graph.process_edge_prim" href="#coinor.gimpy.graph.Graph.process_edge_prim">process_edge_prim</a></code></li>
<li><code><a title="coinor.gimpy.graph.Graph.process_edge_search" href="#coinor.gimpy.graph.Graph.process_edge_search">process_edge_search</a></code></li>
<li><code><a title="coinor.gimpy.graph.Graph.process_node_search" href="#coinor.gimpy.graph.Graph.process_node_search">process_node_search</a></code></li>
<li><code><a title="coinor.gimpy.graph.Graph.random" href="#coinor.gimpy.graph.Graph.random">random</a></code></li>
<li><code><a title="coinor.gimpy.graph.Graph.relabel" href="#coinor.gimpy.graph.Graph.relabel">relabel</a></code></li>
<li><code><a title="coinor.gimpy.graph.Graph.search" href="#coinor.gimpy.graph.Graph.search">search</a></code></li>
<li><code><a title="coinor.gimpy.graph.Graph.set_display_mode" href="#coinor.gimpy.graph.Graph.set_display_mode">set_display_mode</a></code></li>
<li><code><a title="coinor.gimpy.graph.Graph.set_edge_attr" href="#coinor.gimpy.graph.Graph.set_edge_attr">set_edge_attr</a></code></li>
<li><code><a title="coinor.gimpy.graph.Graph.set_layout" href="#coinor.gimpy.graph.Graph.set_layout">set_layout</a></code></li>
<li><code><a title="coinor.gimpy.graph.Graph.set_node_attr" href="#coinor.gimpy.graph.Graph.set_node_attr">set_node_attr</a></code></li>
<li><code><a title="coinor.gimpy.graph.Graph.show_flow" href="#coinor.gimpy.graph.Graph.show_flow">show_flow</a></code></li>
<li><code><a title="coinor.gimpy.graph.Graph.simplex_augment_cycle" href="#coinor.gimpy.graph.Graph.simplex_augment_cycle">simplex_augment_cycle</a></code></li>
<li><code><a title="coinor.gimpy.graph.Graph.simplex_compute_potentials" href="#coinor.gimpy.graph.Graph.simplex_compute_potentials">simplex_compute_potentials</a></code></li>
<li><code><a title="coinor.gimpy.graph.Graph.simplex_connect" href="#coinor.gimpy.graph.Graph.simplex_connect">simplex_connect</a></code></li>
<li><code><a title="coinor.gimpy.graph.Graph.simplex_determine_leaving_arc" href="#coinor.gimpy.graph.Graph.simplex_determine_leaving_arc">simplex_determine_leaving_arc</a></code></li>
<li><code><a title="coinor.gimpy.graph.Graph.simplex_find_cycle" href="#coinor.gimpy.graph.Graph.simplex_find_cycle">simplex_find_cycle</a></code></li>
<li><code><a title="coinor.gimpy.graph.Graph.simplex_find_tree" href="#coinor.gimpy.graph.Graph.simplex_find_tree">simplex_find_tree</a></code></li>
<li><code><a title="coinor.gimpy.graph.Graph.simplex_identify_cycle" href="#coinor.gimpy.graph.Graph.simplex_identify_cycle">simplex_identify_cycle</a></code></li>
<li><code><a title="coinor.gimpy.graph.Graph.simplex_mark_entering_arc" href="#coinor.gimpy.graph.Graph.simplex_mark_entering_arc">simplex_mark_entering_arc</a></code></li>
<li><code><a title="coinor.gimpy.graph.Graph.simplex_mark_leaving_arc" href="#coinor.gimpy.graph.Graph.simplex_mark_leaving_arc">simplex_mark_leaving_arc</a></code></li>
<li><code><a title="coinor.gimpy.graph.Graph.simplex_mark_st_arcs" href="#coinor.gimpy.graph.Graph.simplex_mark_st_arcs">simplex_mark_st_arcs</a></code></li>
<li><code><a title="coinor.gimpy.graph.Graph.simplex_optimal" href="#coinor.gimpy.graph.Graph.simplex_optimal">simplex_optimal</a></code></li>
<li><code><a title="coinor.gimpy.graph.Graph.simplex_redraw" href="#coinor.gimpy.graph.Graph.simplex_redraw">simplex_redraw</a></code></li>
<li><code><a title="coinor.gimpy.graph.Graph.simplex_remove_arc" href="#coinor.gimpy.graph.Graph.simplex_remove_arc">simplex_remove_arc</a></code></li>
<li><code><a title="coinor.gimpy.graph.Graph.simplex_search" href="#coinor.gimpy.graph.Graph.simplex_search">simplex_search</a></code></li>
<li><code><a title="coinor.gimpy.graph.Graph.simplex_select_entering_arc" href="#coinor.gimpy.graph.Graph.simplex_select_entering_arc">simplex_select_entering_arc</a></code></li>
<li><code><a title="coinor.gimpy.graph.Graph.strong_connect" href="#coinor.gimpy.graph.Graph.strong_connect">strong_connect</a></code></li>
<li><code><a title="coinor.gimpy.graph.Graph.tarjan" href="#coinor.gimpy.graph.Graph.tarjan">tarjan</a></code></li>
<li><code><a title="coinor.gimpy.graph.Graph.to_string" href="#coinor.gimpy.graph.Graph.to_string">to_string</a></code></li>
<li><code><a title="coinor.gimpy.graph.Graph.write" href="#coinor.gimpy.graph.Graph.write">write</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="coinor.gimpy.graph.Graph"><code class="flex name class">
<span>class <span class="ident">Graph</span></span>
<span>(</span><span>**attr)</span>
</code></dt>
<dd>
<div class="desc"><p>Graph class, implemented using adjacency list. See GIMPy README for more
information.</p>
<p>API: <strong>init</strong>(self, **attrs)
Description:
Graph class constructor. Sets attributes using argument.</p>
<h2 id="input">Input</h2>
<p>**attrs: Graph attributes.</p>
<h2 id="post">Post</h2>
<p>Sets following attributes using **attrs; self.attr,
self.graph_type. Creates following initial attributes;
self.neighbors, self.in_neighbors, self.nodes, self.out_neighbors,
self.cluster</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Graph(object):
    &#39;&#39;&#39;
    Graph class, implemented using adjacency list. See GIMPy README for more
    information.
    &#39;&#39;&#39;
    def __init__(self, **attr):
        &#39;&#39;&#39;
        API: __init__(self, **attrs)
        Description:
        Graph class constructor. Sets attributes using argument.
        Input:
            **attrs: Graph attributes.
        Post:
            Sets following attributes using **attrs; self.attr,
            self.graph_type. Creates following initial attributes;
            self.neighbors, self.in_neighbors, self.nodes, self.out_neighbors,
            self.cluster
        &#39;&#39;&#39;
        # graph attributes
        self.attr = copy.deepcopy(DEFAULT_GRAPH_ATTRIBUTES)
        # set attributes using constructor
        for a in attr:
            self.attr[a] = attr[a]
        # set name
        if &#39;name&#39; in self.attr:
            self.name = self.attr[&#39;name&#39;]
        else:
            self.name = &#39;G&#39;
        # edge attributes
        self.edge_attr = dict()
        # we treat type attribute and keep it in a separate class attribute
        if &#39;type&#39; in self.attr:
            self.graph_type = self.attr[&#39;type&#39;]
        else:
            self.graph_type = UNDIRECTED_GRAPH
        # adjacency list of nodes, it is a dictionary of lists
        self.neighbors = {}
        # if the graph is undirected we do not need in_neighbor
        if self.graph_type is DIRECTED_GRAPH:
            self.in_neighbors = {}
        self.nodes = {}
        self.edge_connect_symbol = EDGE_CONNECT_SYMBOL[self.graph_type]
        self.out_neighbors = self.neighbors
        if &#39;display&#39; not in self.attr:
            self.attr[&#39;display&#39;]=&#39;off&#39;
        if &#39;layout&#39; not in self.attr:
            self.attr[&#39;layout&#39;] = &#39;fdp&#39;
        self.attr[&#39;cluster_count&#39;] = 0
        self.cluster = {}

    def __repr__(self):
        &#39;&#39;&#39;
        API: __repr__(self)
        Description:
        Returns string representation of the graph.
        Return:
            String representation of the graph.
        &#39;&#39;&#39;
        data = str()
        for n in self.nodes:
            data += str(n)
            data += &#39; -&gt; &#39;
            data += self.neighbors[n].__repr__()
            data += &#39;\n&#39;
        data = data[:-1]
        return data

    def __contains__(self, item):
        &#39;&#39;&#39;
        API: __contains__(self, item)
        Description:
        Return true if item is in graph. item can be a node name or a tuple
        that represents an edge.
        Return:
            True if item is in graph.
        &#39;&#39;&#39;
        if isinstance(item, tuple):
            name1 = item[0]
            name2 = item[1]
            if self.graph_type is DIRECTED_GRAPH:
                return (name1, name2) in self.edge_attr
            else:
                return ((name1, name2) in self.edge_attr or
                        (name2, name1) in self.edge_attr)
        else:
            return item in self.nodes

    def add_node(self, name, **attr):
        &#39;&#39;&#39;
        API: add_node(self, name, **attr)
        Description:
        Adds node to the graph.
        Pre:
            Graph should not contain a node with this name. We do not allow
            multiple nodes with the same name.
        Input:
            name: Name of the node.
            attr: Node attributes.
        Post:
            self.neighbors, self.nodes and self.in_neighbors are updated.
        Return:
            Node (a Node class instance) added to the graph.
        &#39;&#39;&#39;
        if name in self.neighbors:
            raise MultipleNodeException
        self.neighbors[name] = list()
        if self.graph_type is DIRECTED_GRAPH:
            self.in_neighbors[name] = list()
        self.nodes[name] = Node(name, **attr)
        return self.nodes[name]

    def del_node(self, name):
        &#39;&#39;&#39;
        API: del_node(self, name)
        Description:
        Removes node from Graph.
        Input:
            name: Name of the node.
        Pre:
            Graph should contain a node with this name.
        Post:
            self.neighbors, self.nodes and self.in_neighbors are updated.
        &#39;&#39;&#39;
        if name not in self.neighbors:
            raise Exception(&#39;Node %s does not exist!&#39; %str(name))
        for n in self.neighbors[name]:
            del self.edge_attr[(name, n)]
            if self.graph_type == UNDIRECTED_GRAPH:
                self.neighbors[n].remove(name)
            else:
                self.in_neighbors[n].remove(name)
        if self.graph_type is DIRECTED_GRAPH:
            for n in self.in_neighbors[name]:
                del self.edge_attr[(n, name)]
                self.neighbors[n].remove(name)
        del self.neighbors[name]
        del self.in_neighbors[name]
        del self.nodes[name]

    def add_edge(self, name1, name2, **attr):
        &#39;&#39;&#39;
        API: add_edge(self, name1, name2, **attr)
        Description:
        Adds edge to the graph. Sets edge attributes using attr argument.
        Input:
            name1: Name of the source node (if directed).
            name2: Name of the sink node (if directed).
            attr: Edge attributes.
        Pre:
            Graph should not already contain this edge. We do not allow
            multiple edges with same source and sink nodes.
        Post:
            self.edge_attr is updated.
            self.neighbors, self.nodes and self.in_neighbors are updated if
            graph was missing at least one of the nodes.
        &#39;&#39;&#39;
        if (name1, name2) in self.edge_attr:
            raise MultipleEdgeException
        if self.graph_type is UNDIRECTED_GRAPH and (name2,name1) in self.edge_attr:
            raise MultipleEdgeException
        self.edge_attr[(name1,name2)] = copy.deepcopy(DEFAULT_EDGE_ATTRIBUTES)
        for a in attr:
            self.edge_attr[(name1,name2)][a] = attr[a]
        if name1 not in self.nodes:
            self.add_node(name1)
        if name2 not in self.nodes:
            self.add_node(name2)
        self.neighbors[name1].append(name2)
        if self.graph_type is UNDIRECTED_GRAPH:
            self.neighbors[name2].append(name1)
        else:
            self.in_neighbors[name2].append(name1)

    def del_edge(self, e):
        &#39;&#39;&#39;
        API: del_edge(self, e)
        Description:
        Removes edge from graph.
        Input:
            e: Tuple that represents edge, in (source,sink) form.
        Pre:
            Graph should contain this edge.
        Post:
            self.edge_attr, self.neighbors and self.in_neighbors are updated.
        &#39;&#39;&#39;
        if self.graph_type is DIRECTED_GRAPH:
            try:
                del self.edge_attr[e]
            except KeyError:
                raise Exception(&#39;Edge %s does not exists!&#39; %str(e))
            self.neighbors[e[0]].remove(e[1])
            self.in_neighbors[e[1]].remove(e[0])
        else:
            try:
                del self.edge_attr[e]
            except KeyError:
                try:
                    del self.edge_attr[(e[1],e[0])]
                except KeyError:
                    raise Exception(&#39;Edge %s does not exists!&#39; %str(e))
            self.neighbors[e[0]].remove(e[1])
            self.neighbors[e[1]].remove(e[0])

    def get_node(self, name):
        &#39;&#39;&#39;
        API: get_node(self, name)
        Description:
        Returns node object with the provided name.
        Input:
            name: Name of the node.
        Return:
            Returns node object if node exists, returns None otherwise.
        &#39;&#39;&#39;
        if name in self.nodes:
            return self.nodes[name]
        else:
            return None

    def get_edge_cost(self, edge):
        &#39;&#39;&#39;
        API: get_edge_cost(self, edge)
        Description:
        Returns cost attr of edge, required for minimum_spanning_tree_kruskal().
        Input:
            edge: Tuple that represents edge, in (source,sink) form.
        Return:
            Returns cost attribute value of the edge.
        &#39;&#39;&#39;
        return self.get_edge_attr(edge[0], edge[1], &#39;cost&#39;)

    def check_edge(self, name1, name2):
        &#39;&#39;&#39;
        API: check_edge(self, name1, name2)
        Description:
        Return True if edge exists, False otherwise.
        Input:
            name1: name of the source node.
            name2: name of the sink node.
        Return:
            Returns True if edge exists, False otherwise.
        &#39;&#39;&#39;
        if self.graph_type is DIRECTED_GRAPH:
            return (name1, name2) in self.edge_attr
        else:
            return ((name1, name2) in self.edge_attr or
                    (name2, name1) in self.edge_attr)

    def get_node_list(self):
        &#39;&#39;&#39;
        API: get_node_list(self)
        Description:
        Returns node list.
        Return:
            List of nodes.
        &#39;&#39;&#39;
        return list(self.neighbors.keys())

    def get_edge_list(self):
        &#39;&#39;&#39;
        API: get_edge_list(self)
        Description:
        Returns edge list.
        Return:
            List of edges, edges are tuples and in (source,sink) format.
        &#39;&#39;&#39;
        return list(self.edge_attr.keys())

    def get_node_num(self):
        &#39;&#39;&#39;
        API: get_node_num(self)
        Description:
        Returns number of nodes.
        Return:
            Number of nodes.
        &#39;&#39;&#39;
        return len(self.neighbors)

    def get_edge_num(self):
        &#39;&#39;&#39;
        API: get_edge_num(self)
        Description:
        Returns number of edges.
        Return:
            Number of edges.
        &#39;&#39;&#39;
        return len(self.edge_attr)

    def get_node_attr(self, name, attr):
        &#39;&#39;&#39;
        API: get_node_attr(self, name, attr)
        Description:
        Returns attribute attr of given node.
        Input:
            name: Name of node.
            attr: Attribute of node.
        Pre:
            Graph should have this node.
        Return:
            Value of node attribute attr.
        &#39;&#39;&#39;
        return self.get_node(name).get_attr(attr)

    def get_edge_attr(self, n, m, attr):
        &#39;&#39;&#39;
        API: get_edge_attr(self, n, m, attr)
        Description:
        Returns attribute attr of edge (n,m).
        Input:
            n: Source node name.
            m: Sink node name.
            attr: Attribute of edge.
        Pre:
            Graph should have this edge.
        Return:
            Value of edge attribute attr.
        &#39;&#39;&#39;
        if self.graph_type is DIRECTED_GRAPH:
            return self.edge_attr[(n,m)][attr]
        else:
            try:
                return self.edge_attr[(n,m)][attr]
            except KeyError:
                return self.edge_attr[(m,n)][attr]

    def set_node_attr(self, name, attr, value):
        &#39;&#39;&#39;
        API: set_node_attr(self, name, attr)
        Description:
        Sets attr attribute of node named name to value.
        Input:
            name: Name of node.
            attr: Attribute of node to set.
        Pre:
            Graph should have this node.
        Post:
            Node attribute will be updated.
        &#39;&#39;&#39;
        self.get_node(name).set_attr(attr, value)

    def set_edge_attr(self, n, m, attr, value):
        &#39;&#39;&#39;
        API: set_edge_attr(self, n, m, attr, value)
        Description:
        Sets attr attribute of edge (n,m) to value.
        Input:
            n: Source node name.
            m: Sink node name.
            attr: Attribute of edge to set.
            value: New value of attribute.
        Pre:
            Graph should have this edge.
        Post:
            Edge attribute will be updated.
        &#39;&#39;&#39;
        if self.graph_type is DIRECTED_GRAPH:
            self.edge_attr[(n,m)][attr] = value
        else:
            try:
                self.edge_attr[(n,m)][attr] = value
            except KeyError:
                self.edge_attr[(m,n)][attr] = value

    def get_neighbors(self, name):
        &#39;&#39;&#39;
        API: get_neighbors(self, name)
        Description:
        Returns list of neighbors of given node.
        Input:
            name: Node name.
        Pre:
            Graph should have this node.
        Return:
            List of neighbor node names.
        &#39;&#39;&#39;
        return self.neighbors[name]

    def get_in_neighbors(self, name):
        &#39;&#39;&#39;
        API: get_in_neighbors(self, name)
        Description:
        Returns list of in neighbors of given node.
        Input:
            name: Node name.
        Pre:
            Graph should have this node.
        Return:
            List of in-neighbor node names.
        &#39;&#39;&#39;
        return self.in_neighbors[name]

    def get_out_neighbors(self, name):
        &#39;&#39;&#39;
        API: get_out_neighbors(self, name)
        Description:
        Returns list of out-neighbors of given node.
        Input:
            name: Node name.
        Pre:
            Graph should have this node.
        Return:
            List of out-neighbor node names.
        &#39;&#39;&#39;
        return self.neighbors[name]

    def edge_to_string(self, e):
        &#39;&#39;&#39;
        API: edge_to_string(self, e)
        Description:
        Return string that represents edge e in dot language.
        Input:
            e: Edge tuple in (source,sink) format.
        Pre:
            Graph should have this edge.
        Return:
            String that represents given edge.
        &#39;&#39;&#39;
        edge = list()
        edge.append(quote_if_necessary(str(e[0])))
        edge.append(self.edge_connect_symbol)
        edge.append(quote_if_necessary(str(e[1])))
        # return if there is nothing in self.edge_attr[e]
        if len(self.edge_attr[e]) == 0:
            return &#39;&#39;.join(edge)
        edge.append(&#39;  [&#39;)
        for a in self.edge_attr[e]:
            edge.append(a)
            edge.append(&#39;=&#39;)
            edge.append(quote_if_necessary(str(self.edge_attr[e][a])))
            edge.append(&#39;, &#39;)
        edge = edge[:-1]
        edge.append(&#39;]&#39;)
        return &#39;&#39;.join(edge)

    def to_string(self):
        &#39;&#39;&#39;
        API: to_string(self)
        Description:
        This method is based on pydot Graph class with the same name.
        Returns a string representation of the graph in dot language.
        It will return the graph and all its subelements in string form.
        Return:
            String that represents graph in dot language.
        &#39;&#39;&#39;
        graph = list()
        processed_edges = {}
        graph.append(&#39;%s %s {\n&#39; %(self.graph_type, self.name))
        for a in self.attr:
            if a not in GRAPH_ATTRIBUTES:
                continue
            val = self.attr[a]
            if val is not None:
                graph.append( &#39;%s=%s&#39; % (a, quote_if_necessary(val)) )
            else:
                graph.append(a)
            graph.append( &#39;;\n&#39; )
        # clusters
        for c in self.cluster:
            graph.append(&#39;subgraph cluster_%s {\n&#39; %c)
            for a in self.cluster[c][&#39;attrs&#39;]:
                if a==&#39;label&#39;:
                    graph.append(a+&#39;=&#39;+quote_if_necessary(self.cluster[c][&#39;attrs&#39;][a])+&#39;;\n&#39;)
                    continue
                graph.append(a+&#39;=&#39;+self.cluster[c][&#39;attrs&#39;][a]+&#39;;\n&#39;)
            if len(self.cluster[c][&#39;node_attrs&#39;])!=0:
                graph.append(&#39;node [&#39;)
            for a in self.cluster[c][&#39;node_attrs&#39;]:
                graph.append(a+&#39;=&#39;+self.cluster[c][&#39;node_attrs&#39;][a])
                graph.append(&#39;,&#39;)
            if len(self.cluster[c][&#39;node_attrs&#39;])!=0:
                graph.pop()
                graph.append(&#39;];\n&#39;)
            # process cluster nodes
            for n in self.cluster[c][&#39;node_list&#39;]:
                data = self.get_node(n).to_string()
                graph.append(data + &#39;;\n&#39;)
            # process cluster edges
            for n in self.cluster[c][&#39;node_list&#39;]:
                for m in self.cluster[c][&#39;node_list&#39;]:
                    if self.check_edge(n,m):
                        data = self.edge_to_string((n,m))
                        graph.append(data + &#39;;\n&#39;)
                        processed_edges[(n,m)]=None
            graph.append(&#39;}\n&#39;)
        # process remaining (non-cluster) nodes
        for n in self.neighbors:
            for c in self.cluster:
                if n in self.cluster[c][&#39;node_list&#39;]:
                    break
            else:
                data = self.get_node(n).to_string()
                graph.append(data + &#39;;\n&#39;)
        # process edges
        for e in self.edge_attr:
            if e in processed_edges:
                continue
            data = self.edge_to_string(e)
            graph.append(data + &#39;;\n&#39;)
        graph.append( &#39;}\n&#39; )
        return &#39;&#39;.join(graph)

    def label_components(self, display = None):
        &#39;&#39;&#39;
        API: label_components(self, display=None)
        Description:
        This method labels the nodes of an undirected graph with component
        numbers so that each node has the same label as all nodes in the
        same component. It will display the algortihm if display argument is
        provided.
        Input:
            display: display method.
        Pre:
            self.graph_type should be UNDIRECTED_GRAPH.
        Post:
            Nodes will have &#39;component&#39; attribute that will have component
            number as value.
        &#39;&#39;&#39;
        if self.graph_type == DIRECTED_GRAPH:
            raise Exception(&#34;label_components only works for &#34;,
                            &#34;undirected graphs&#34;)
        self.num_components = 0
        for n in self.get_node_list():
            self.get_node(n).set_attr(&#39;component&#39;, None)
        for n in self.neighbors:
            self.get_node(n).set_attr(&#39;label&#39;, &#39;-&#39;)
        for n in self.get_node_list():
            if self.get_node(n).get_attr(&#39;component&#39;) == None:
                self.search(n, display=display,
                            component=self.num_components, algo=&#39;DFS&#39;)
                self.num_components += 1

    def tarjan(self):
        &#39;&#39;&#39;
        API: tarjan(self)
        Description:
        Implements Tarjan&#39;s algorithm for determining strongly connected set of
        nodes.
        Pre:
            self.graph_type should be DIRECTED_GRAPH.
        Post:
            Nodes will have &#39;component&#39; attribute that will have component
            number as value. Changes &#39;index&#39; attribute of nodes.
        &#39;&#39;&#39;
        index = 0
        component = 0
        q = []
        for n in self.get_node_list():
            if self.get_node_attr(n, &#39;index&#39;) is None:
                index, component = self.strong_connect(q, n, index, component)

    def strong_connect(self, q, node, index, component):
        &#39;&#39;&#39;
        API: strong_connect (self, q, node, index, component)
        Description:
        Used by tarjan method. This method should not be called directly by
        user.
        Input:
            q: Node list.
            node: Node that is being connected to nodes in q.
            index: Index used by tarjan method.
            component: Current component number.
        Pre:
            Should be called by tarjan and itself (recursive) only.
        Post:
            Nodes will have &#39;component&#39; attribute that will have component
            number as value. Changes &#39;index&#39; attribute of nodes.
        Return:
            Returns new index and component numbers.
        &#39;&#39;&#39;
        self.set_node_attr(node, &#39;index&#39;, index)
        self.set_node_attr(node, &#39;lowlink&#39;, index)
        index += 1
        q.append(node)
        for m in self.get_neighbors(node):
            if self.get_node_attr(m, &#39;index&#39;) is None:
                index, component = self.strong_connect(q, m, index, component)
                self.set_node_attr(node, &#39;lowlink&#39;,
                                   min([self.get_node_attr(node, &#39;lowlink&#39;),
                                        self.get_node_attr(m, &#39;lowlink&#39;)]))
            elif m in q:
                self.set_node_attr(node, &#39;lowlink&#39;,
                                   min([self.get_node_attr(node, &#39;lowlink&#39;),
                                        self.get_node_attr(m, &#39;index&#39;)]))
        if self.get_node_attr(node, &#39;lowlink&#39;) == self.get_node_attr(node, &#39;index&#39;):
            m = q.pop()
            self.set_node_attr(m, &#39;component&#39;, component)
            while (node!=m):
                m = q.pop()
                self.set_node_attr(m, &#39;component&#39;, component)
            component += 1
            self.num_components = component

        return (index, component)

    def label_strong_component(self):
        &#39;&#39;&#39;
        API: label_strong_component(self)
        Description:
        This method labels the nodes of a directed graph with component
        numbers so that each node has the same label as all nodes in the
        same component.
        Pre:
            self.graph_type should be DIRECTED_GRAPH.
        Post:
            Nodes will have &#39;component&#39; attribute that will have component
            number as value. Changes &#39;index&#39; attribute of nodes.
        &#39;&#39;&#39;
        self.num_components = 0
        self.tarjan()

    def dfs(self, root, disc_count = 0, finish_count = 1, component = None,
            transpose = False, display = None, pred = None):
        &#39;&#39;&#39;
        API: dfs(self, root, disc_count = 0, finish_count = 1, component=None,
            transpose=False)
        Description:
        Make a depth-first search starting from node with name root.
        Input:
            root: Starting node name.
            disc_count: Discovery time.
            finish_count: Finishing time.
            component: component number.
            transpose: Goes in the reverse direction along edges if transpose
            is True.
        Post:
            Nodes will have &#39;component&#39; attribute that will have component
            number as value. Updates &#39;disc_time&#39; and &#39;finish_time&#39; attributes
            of nodes which represents discovery time and finishing time.
        Return:
            Returns a tuple that has discovery time and finish time of the
            last node in the following form (disc_time,finish_time).
        &#39;&#39;&#39;
        if pred == None:
            pred = {}
        if display == None:
            display = self.attr[&#39;display&#39;]
        else:
            self.set_display_mode(display)
        neighbors = self.neighbors
        if self.graph_type == DIRECTED_GRAPH and transpose:
            neighbors = self.in_neighbors
        self.get_node(root).set_attr(&#39;component&#39;, component)
        disc_count += 1
        self.get_node(root).set_attr(&#39;disc_time&#39;, disc_count)
        self.get_node(root).set_attr(&#39;label&#39;, str(disc_count)+&#39;,-&#39;)
        self.get_node(root).set_attr(&#39;color&#39;, &#39;blue&#39;)
        if root in pred:
            self.set_edge_attr(pred[root], root, &#39;color&#39;, &#39;green&#39;)
        self.display()
        if transpose:
            fTime = []
            for n in neighbors[root]:
                fTime.append((n,self.get_node(n).get_attr(&#39;finish_time&#39;)))
            neighbor_list = sorted(fTime, key=operator.itemgetter(1))
            neighbor_list = list(t[0] for t in neighbor_list)
            neighbor_list.reverse()
        else:
            neighbor_list = neighbors[root]
        for i in neighbor_list:
            if not transpose:
                if self.get_node(i).get_attr(&#39;disc_time&#39;) is None:
                    pred[i] = root
                    disc_count, finish_count = self.dfs(i, disc_count,
                                                        finish_count,
                                                        component, transpose,
                                                        pred = pred)
            else:
                if self.get_node(i).get_attr(&#39;component&#39;) is None:
                    disc_count, finish_count = self.dfs(i, disc_count,
                                                        finish_count,
                                                        component, transpose,
                                                        pred = pred)
        self.get_node(root).set_attr(&#39;finish_time&#39;, finish_count)
        d_time = self.get_node(root).get_attr(&#39;disc_time&#39;)
        label = &#39;&#34;&#39; + str(d_time) + &#39;,&#39; + str(finish_count) + &#39;&#34;&#39;
        self.get_node(root).set_attr(&#39;label&#39;, label)
        self.get_node(root).set_attr(&#39;color&#39;, &#39;green&#39;)
        self.display()
        finish_count += 1
        return disc_count, finish_count

    def bfs(self, root, display = None, component = None):
        &#39;&#39;&#39;
        API: bfs(self, root, display = None, component=None)
        Description:
        Make a breadth-first search starting from node with name root.
        Input:
            root: Starting node name.
            display: display method.
            component: component number.
        Post:
            Nodes will have &#39;component&#39; attribute that will have component
            number as value.
        &#39;&#39;&#39;
        self.search(root, display = display, component = component, q = Queue())

    def search(self, source, destination = None, display = None,
               component = None, q = None,
               algo = &#39;DFS&#39;, reverse = False, **kargs):
        &#39;&#39;&#39;
        API: search(self, source, destination = None, display = None,
               component = None, q = Stack(),
               algo = &#39;DFS&#39;, reverse = False, **kargs)
        Description:
        Generic search method. Changes behavior (dfs,bfs,dijkstra,prim)
        according to algo argument.
        if destination is not specified:
           This method determines all nodes reachable from &#34;source&#34; ie. creates
           precedence tree and returns it (dictionary).
        if destionation is given:
           If there exists a path from &#34;source&#34; to &#34;destination&#34; it will return
           list of the nodes is this path. If there is no such path, it will
           return the precedence tree constructed from source (dictionary).
        Optionally, it marks all nodes reachable from &#34;source&#34; with a component
        number. The variable &#34;q&#34; determines the order in which the nodes are
        searched.
        Input:
            source: Search starts from node with this name.
            destination: Destination node name.
            display: Display method.
            algo: Algortihm that specifies search. Available algortihms are
            &#39;DFS&#39;, &#39;BFS&#39;, &#39;Dijkstra&#39; and &#39;Prim&#39;.
            reverse: Search goes in reverse arc directions if True.
            kargs: Additional keyword arguments.
        Post:
            Nodes will have &#39;component&#39; attribute that will have component
            number as value (if component argument provided). Color attribute
            of nodes and edges may change.
        Return:
            Returns predecessor tree in dictionary form if destination is
            not specified, returns list of node names in the path from source
            to destionation if destionation is specified and there is a path.
            If there is no path returns predecessor tree in dictionary form.
            See description section.
        &#39;&#39;&#39;
        if display == None:
            display = self.attr[&#39;display&#39;]
        else:
            self.set_display_mode(display)
        if algo == &#39;DFS&#39;:
            if q is None:
                q = Stack()
            self.get_node(source).set_attr(&#39;component&#39;, component)
        elif algo == &#39;BFS&#39; or algo == &#39;UnweightedSPT&#39;:
            if q is None:
                q = Queue()
            self.get_node(source).set_attr(&#39;component&#39;, component)
        elif algo == &#39;Dijkstra&#39; or algo == &#39;Prim&#39;:
            if q is None:
                q = PriorityQueue()
        else:
            print(&#34;Unknown search algorithm...exiting&#34;)
            return
        neighbors = self.neighbors
        if self.graph_type == DIRECTED_GRAPH and reverse:
            neighbors = self.in_neighbors
        for i in self.get_node_list():
            self.get_node(i).set_attr(&#39;label&#39;, &#39;-&#39;)
            self.get_node(i).attr.pop(&#39;priority&#39;, None)
            self.get_node(i).set_attr(&#39;distance&#39;, None)
            self.get_node(i).set_attr(&#39;color&#39;, &#39;black&#39;)
            for j in neighbors[i]:
                if reverse:
                    self.set_edge_attr(j, i, &#39;color&#39;, &#39;black&#39;)
                else:
                    self.set_edge_attr(i, j, &#39;color&#39;, &#39;black&#39;)
        self.display()
        pred = {}
        self.process_edge_search(None, source, pred, q, component, algo,
                                 **kargs)
        found = True
        if source != destination:
            found = False
        while not q.isEmpty() and not found:
            current = q.peek()
            if self.get_node(current).get_attr(&#39;color&#39;) == &#39;green&#39;:
                q.remove(current)
                continue
            self.process_node_search(current, q, **kargs)
            self.get_node(current).set_attr(&#39;color&#39;, &#39;blue&#39;)
            if current != source:
                if reverse:
                    self.set_edge_attr(current, pred[current], &#39;color&#39;, &#39;green&#39;)
                else:
                    self.set_edge_attr(pred[current], current, &#39;color&#39;, &#39;green&#39;)
            if current == destination:
                found = True
                break
            self.display()
            for n in neighbors[current]:
                if self.get_node(n).get_attr(&#39;color&#39;) != &#39;green&#39;:
                    if reverse:
                        self.set_edge_attr(n, current, &#39;color&#39;, &#39;yellow&#39;)
                    else:
                        self.set_edge_attr(current, n, &#39;color&#39;, &#39;yellow&#39;)
                    self.display()
                    self.process_edge_search(current, n, pred, q, component,
                                             algo, **kargs)
                    if reverse:
                        self.set_edge_attr(n, current, &#39;color&#39;, &#39;black&#39;)
                    else:
                        self.set_edge_attr(current, n, &#39;color&#39;, &#39;black&#39;)
            q.remove(current)
            self.get_node(current).set_attr(&#39;color&#39;, &#39;green&#39;)
            self.display()
        if found:
            path = [destination]
            current = destination
            while current != source:
                path.insert(0, pred[current])
                current = pred[current]
            return path
        if destination == None:
            return pred
        else:
            return None

    def process_node_search(self, node, q, **kwargs):
        &#39;&#39;&#39;
        API: process_node_search(self, node, q, **kwargs)
        Description:
        Used by search() method. Process nodes along the search. Should not be
        called by user directly.
        Input:
            node: Name of the node being processed.
            q: Queue data structure.
            kwargs: Keyword arguments.
        Post:
            &#39;priority&#39; attribute of the node may get updated.
        &#39;&#39;&#39;
        if isinstance(q, PriorityQueue):
            self.get_node(node).set_attr(&#39;priority&#39;, q.get_priority(node))

    def process_edge_dijkstra(self, current, neighbor, pred, q, component):
        &#39;&#39;&#39;
        API: process_edge_dijkstra(self, current, neighbor, pred, q, component)
        Description:
        Used by search() method if the algo argument is &#39;Dijkstra&#39;. Processes
        edges along Dijkstra&#39;s algorithm. User does not need to call this
        method directly.
        Input:
            current: Name of the current node.
            neighbor: Name of the neighbor node.
            pred: Predecessor tree.
            q: Data structure that holds nodes to be processed in a queue.
            component: component number.
        Post:
            &#39;color&#39; attribute of nodes and edges may change.
        &#39;&#39;&#39;
        if current is None:
            self.get_node(neighbor).set_attr(&#39;color&#39;, &#39;red&#39;)
            self.get_node(neighbor).set_attr(&#39;label&#39;, 0)
            q.push(neighbor, 0)
            self.display()
            self.get_node(neighbor).set_attr(&#39;color&#39;, &#39;black&#39;)
            return
        new_estimate = (q.get_priority(current) +
                        self.get_edge_attr(current, neighbor, &#39;cost&#39;))
        if neighbor not in pred or new_estimate &lt; q.get_priority(neighbor):
            pred[neighbor] = current
            self.get_node(neighbor).set_attr(&#39;color&#39;, &#39;red&#39;)
            self.get_node(neighbor).set_attr(&#39;label&#39;, new_estimate)
            q.push(neighbor, new_estimate)
            self.display()
            self.get_node(neighbor).set_attr(&#39;color&#39;, &#39;black&#39;)

    def process_edge_prim(self, current, neighbor, pred, q, component):
        &#39;&#39;&#39;
        API: process_edge_prim(self, current, neighbor, pred, q, component)
        Description:
        Used by search() method if the algo argument is &#39;Prim&#39;. Processes
        edges along Prim&#39;s algorithm. User does not need to call this method
        directly.
        Input:
            current: Name of the current node.
            neighbor: Name of the neighbor node.
            pred: Predecessor tree.
            q: Data structure that holds nodes to be processed in a queue.
            component: component number.
        Post:
            &#39;color&#39; attribute of nodes and edges may change.
        &#39;&#39;&#39;
        if current is None:
            self.get_node(neighbor).set_attr(&#39;color&#39;, &#39;red&#39;)
            self.get_node(neighbor).set_attr(&#39;label&#39;, 0)
            q.push(neighbor, 0)
            self.display()
            self.get_node(neighbor).set_attr(&#39;color&#39;, &#39;black&#39;)
            return
        new_estimate = self.get_edge_attr(current, neighbor, &#39;cost&#39;)
        if not neighbor in pred or new_estimate &lt; q.get_priority(neighbor):
            pred[neighbor] = current
            self.get_node(neighbor).set_attr(&#39;color&#39;, &#39;red&#39;)
            self.get_node(neighbor).set_attr(&#39;label&#39;, new_estimate)
            q.push(neighbor, new_estimate)
            self.display()
            self.get_node(neighbor).set_attr(&#39;color&#39;, &#39;black&#39;)

    def process_edge_search(self, current, neighbor, pred, q, component, algo,
                            **kargs):
        &#39;&#39;&#39;
        API: process_edge_search(self, current, neighbor, pred, q, component,
                                 algo, **kargs)
        Description:
        Used by search() method. Processes edges according to the underlying
        algortihm. User does not need to call this method directly.
        Input:
            current: Name of the current node.
            neighbor: Name of the neighbor node.
            pred: Predecessor tree.
            q: Data structure that holds nodes to be processed in a queue.
            component: component number.
            algo: Search algorithm. See search() documentation.
            kwargs: Keyword arguments.
        Post:
            &#39;color&#39;, &#39;distance&#39;, &#39;component&#39; attribute of nodes and edges may
            change.
        &#39;&#39;&#39;
        if algo == &#39;Dijkstra&#39;:
            return self.process_edge_dijkstra(current, neighbor, pred, q,
                                              component)
        if algo == &#39;Prim&#39;:
            return self.process_edge_prim(current, neighbor, pred, q,
                                          component)
        neighbor_node = self.get_node(neighbor)
        if current == None:
            neighbor_node.set_attr(&#39;distance&#39;, 0)
            if isinstance(q, PriorityQueue):
                q.push(neighbor, 0)
            else:
                q.push(neighbor)
            if component != None:
                neighbor_node.set_attr(&#39;component&#39;, component)
                neighbor_node.set_attr(&#39;label&#39;, component)
            else:
                neighbor_node.set_attr(&#39;label&#39;, 0)
            return
        if isinstance(q, PriorityQueue):
            current_priority = q.get_priority(neighbor)
            if algo == &#39;UnweightedSPT&#39; or algo == &#39;BFS&#39;:
                priority = self.get_node(current).get_attr(&#39;distance&#39;) + 1
            if algo == &#39;DFS&#39;:
                priority = -self.get_node(current).get_attr(&#39;distance&#39;) - 1
            if current_priority is not None and priority &gt;= current_priority:
                return
            q.push(neighbor, priority)
            if algo == &#39;UnweightedSPT&#39; or algo == &#39;BFS&#39;:
                neighbor_node.set_attr(&#39;distance&#39;, priority)
            if algo == &#39;DFS&#39;:
                neighbor_node.set_attr(&#39;depth&#39;, -priority)
        else:
            distance = self.get_node(current).get_attr(&#39;distance&#39;) + 1
            if ((algo == &#39;UnweightedSPT&#39; or algo == &#39;BFS&#39;) and
                neighbor_node.get_attr(&#39;distance&#39;) is not None):
                return
            neighbor_node.set_attr(&#39;distance&#39;, distance)
            neighbor_node.set_attr(&#39;label&#39;, str(distance))
            q.push(neighbor)
        pred[neighbor] = current
        neighbor_node.set_attr(&#39;color&#39;, &#39;red&#39;)
        if component != None:
            neighbor_node.set_attr(&#39;component&#39;, component)
            neighbor_node.set_attr(&#39;label&#39;, component)
        self.display()

    def minimum_spanning_tree_prim(self, source, display = None,
                                   q = PriorityQueue()):
        &#39;&#39;&#39;
        API: minimum_spanning_tree_prim(self, source, display = None,
                                        q = PriorityQueue())
        Description:
        Determines a minimum spanning tree of all nodes reachable
        from source using Prim&#39;s Algorithm.
        Input:
            source: Name of source node.
            display: Display method.
            q: Data structure that holds nodes to be processed in a queue.
        Post:
            &#39;color&#39;, &#39;distance&#39;, &#39;component&#39; attribute of nodes and edges may
            change.
        Return:
            Returns predecessor tree in dictionary format.
        &#39;&#39;&#39;
        if display == None:
            display = self.attr[&#39;display&#39;]
        else:
            self.set_display_mode(display)
        if isinstance(q, PriorityQueue):
            addToQ = q.push
            removeFromQ = q.pop
            peek = q.peek
            isEmpty = q.isEmpty
        neighbors = self.get_neighbors
        pred = {}
        addToQ(source)
        done = False
        while not isEmpty() and not done:
            current = removeFromQ()
            self.set_node_attr(current, &#39;color&#39;, &#39;blue&#39;)
            if current != source:
                self.set_edge_attr(pred[current], current, &#39;color&#39;, &#39;green&#39;)
            self.display()
            for n in neighbors(current):
                if self.get_node_attr(n, &#39;color&#39;) != &#39;green&#39;:
                    self.set_edge_attr(current, n, &#39;color&#39;, &#39;yellow&#39;)
                    self.display()
                    new_estimate = self.get_edge_attr(current, n, &#39;cost&#39;)
                    if not n in pred or new_estimate &lt; peek(n)[0]:
                        pred[n] = current
                        self.set_node_attr(n, &#39;color&#39;, &#39;red&#39;)
                        self.set_node_attr(n, &#39;label&#39;, new_estimate)
                        addToQ(n, new_estimate)
                        self.display()
                        self.set_node_attr(n, &#39;color&#39;, &#39;black&#39;)
                    self.set_edge_attr(current, n, &#39;color&#39;, &#39;black&#39;)
            self.set_node_attr(current, &#39;color&#39;, &#39;green&#39;)
            self.display()
        return pred

    def minimum_spanning_tree_kruskal(self, display = None, components = None):
        &#39;&#39;&#39;
        API: minimum_spanning_tree_kruskal(self, display = None,
                                           components = None)
        Description:
        Determines a minimum spanning tree using Kruskal&#39;s Algorithm.
        Input:
            display: Display method.
            component: component number.
        Post:
            &#39;color&#39; attribute of nodes and edges may change.
        Return:
            Returns list of edges where edges are tuples in (source,sink)
            format.
        &#39;&#39;&#39;
        if display == None:
            display = self.attr[&#39;display&#39;]
        else:
            self.set_display_mode(display)
        if components is None:
            components = DisjointSet(display = display, layout = &#39;dot&#39;,
                                     optimize = False)
        sorted_edge_list = sorted(self.get_edge_list(), key=self.get_edge_cost)
        edges = []
        for n in self.get_node_list():
            components.add([n])
        components.display()
        for e in sorted_edge_list:
            if len(edges) == len(self.get_node_list()) - 1:
                break
            self.set_edge_attr(e[0], e[1], &#39;color&#39;, &#39;yellow&#39;)
            self.display()
            if components.union(e[0], e[1]):
                self.set_edge_attr(e[0], e[1], &#39;color&#39;, &#39;green&#39;)
                self.display()
                edges.append(e)
            else:
                self.set_edge_attr(e[0], e[1], &#39;color&#39;, &#39;black&#39;)
                self.display()
            components.display()
        return edges

    def max_flow_preflowpush(self, source, sink, algo = &#39;FIFO&#39;, display = None):
        &#39;&#39;&#39;
        API: max_flow_preflowpush(self, source, sink, algo = &#39;FIFO&#39;,
                                  display = None)
        Description:
        Finds maximum flow from source to sink by a depth-first search based
        augmenting path algorithm.
        Pre:
             Assumes a directed graph in which each arc has a &#39;capacity&#39;
             attribute and for which there does does not exist both arcs (i,j)
             and (j,i) for any pair of nodes i and j.
        Input:
            source: Source node name.
            sink: Sink node name.
            algo: Algorithm choice, &#39;FIFO&#39;, &#39;SAP&#39; or &#39;HighestLabel&#39;.
            display: display method.
        Post:
            The &#39;flow&#39; attribute of each arc gives a maximum flow.
        &#39;&#39;&#39;
        if display == None:
            display = self.attr[&#39;display&#39;]
        else:
            self.set_display_mode(display)
        nl = self.get_node_list()
        # set excess of all nodes to 0
        for n in nl:
            self.set_node_attr(n, &#39;excess&#39;, 0)
        # set flow of all edges to 0
        for e in self.edge_attr:
            self.edge_attr[e][&#39;flow&#39;] = 0
            if &#39;capacity&#39; in self.edge_attr[e]:
                capacity = self.edge_attr[e][&#39;capacity&#39;]
                self.edge_attr[e][&#39;label&#39;] = str(capacity)+&#39;/0&#39;
            else:
                self.edge_attr[e][&#39;capacity&#39;] = INF
                self.edge_attr[e][&#39;label&#39;] = &#39;INF/0&#39;
        self.display()
        self.set_display_mode(&#39;off&#39;)
        self.search(sink, algo = &#39;UnweightedSPT&#39;, reverse = True)
        self.set_display_mode(display)
        disconnect = False
        for n in nl:
            if self.get_node_attr(n, &#39;distance&#39;) is None:
                disconnect = True
                self.set_node_attr(n, &#39;distance&#39;,
                                   2*len(nl) + 1)
        if disconnect:
            print(&#39;Warning: graph contains nodes not connected to the sink...&#39;)
        if algo == &#39;FIFO&#39;:
            q = Queue()
        elif algo == &#39;SAP&#39;:
            q = Stack()
        elif algo == &#39;HighestLabel&#39;:
            q = PriorityQueue()
        for n in self.get_neighbors(source):
            capacity = self.get_edge_attr(source, n, &#39;capacity&#39;)
            self.set_edge_attr(source, n, &#39;flow&#39;, capacity)
            self.set_node_attr(n, &#39;excess&#39;, capacity)
            excess = self.get_node_attr(source, &#39;excess&#39;)
            self.set_node_attr(source, &#39;excess&#39;, excess - capacity)
            if algo == &#39;FIFO&#39; or algo == &#39;SAP&#39;:
                q.push(n)
            elif algo == &#39;HighestLabel&#39;:
                q.push(n, -1)
        self.set_node_attr(source, &#39;distance&#39;, len(nl))
        self.show_flow()
        while not q.isEmpty():
            relabel = True
            current = q.peek()
            neighbors = (self.get_neighbors(current) +
                         self.get_in_neighbors(current))
            for n in neighbors:
                pushed = self.process_edge_flow(source, sink, current, n, algo,
                                                q)
                if pushed:
                    self.show_flow()
                    if algo == &#39;FIFO&#39;:
                        &#39;&#39;&#39;With FIFO, we need to add the neighbors to the queue
                        before the current is added back in or the nodes will
                        be out of order
                        &#39;&#39;&#39;
                        if q.peek(n) is None and n != source and n != sink:
                            q.push(n)
                        &#39;&#39;&#39;Keep pushing while there is excess&#39;&#39;&#39;
                        if self.get_node_attr(current, &#39;excess&#39;) &gt; 0:
                            continue
                    &#39;&#39;&#39;If we were able to push, then there we should not
                    relabel
                    &#39;&#39;&#39;
                    relabel = False
                    break
            q.remove(current)
            if current != sink:
                if relabel:
                    self.relabel(current)
                    self.show_flow()
                if self.get_node_attr(current, &#39;excess&#39;) &gt; 0:
                    if algo == &#39;FIFO&#39; or algo == &#39;SAP&#39;:
                        q.push(current)
                    elif algo == &#39;HighestLabel&#39;:
                        q.push(current, -self.get_node_attr(current,
                                                            &#39;distance&#39;))
            if pushed and q.peek(n) is None and n != source:
                if algo == &#39;SAP&#39;:
                    q.push(n)
                elif algo == &#39;HighestLabel&#39;:
                    q.push(n, -self.get_node_attr(n, &#39;distance&#39;))

    def process_edge_flow(self, source, sink, i, j, algo, q):
        &#39;&#39;&#39;
        API: process_edge_flow(self, source, sink, i, j, algo, q)
        Description:
        Used by by max_flow_preflowpush() method. Processes edges along
        prefolow push.
        Input:
            source: Source node name of flow graph.
            sink: Sink node name of flow graph.
            i: Source node in the processed edge (tail of arc).
            j: Sink node in the processed edge (head of arc).
        Post:
            The &#39;flow&#39; and &#39;excess&#39; attributes of nodes may get updated.
        Return:
            Returns False if residual capacity is 0, True otherwise.
        &#39;&#39;&#39;
        if (self.get_node_attr(i, &#39;distance&#39;) !=
            self.get_node_attr(j, &#39;distance&#39;) + 1):
            return False
        if (i, j) in self.edge_attr:
            edge = (i, j)
            capacity = self.get_edge_attr(i, j, &#39;capacity&#39;)
            mult = 1
        else:
            edge = (j, i)
            capacity = 0
            mult = -1
        flow = mult*self.edge_attr[edge][&#39;flow&#39;]
        residual_capacity = capacity - flow
        if residual_capacity == 0:
            return False
        excess_i = self.get_node_attr(i, &#39;excess&#39;)
        excess_j = self.get_node_attr(j, &#39;excess&#39;)
        push_amount = min(excess_i, residual_capacity)
        self.edge_attr[edge][&#39;flow&#39;] = mult*(flow + push_amount)
        self.set_node_attr(i, &#39;excess&#39;, excess_i - push_amount)
        self.set_node_attr(j, &#39;excess&#39;, excess_j + push_amount)
        return True

    def relabel(self, i):
        &#39;&#39;&#39;
        API: relabel(self, i)
        Description:
        Used by max_flow_preflowpush() method for relabelling node i.
        Input:
            i: Node that is being relabelled.
        Post:
            &#39;distance&#39; attribute of node i is updated.
        &#39;&#39;&#39;
        min_distance = 2*len(self.get_node_list()) + 1
        for j in self.get_neighbors(i):
            if (self.get_node_attr(j, &#39;distance&#39;) &lt; min_distance and
                (self.get_edge_attr(i, j, &#39;flow&#39;) &lt;
                 self.get_edge_attr(i, j, &#39;capacity&#39;))):
                min_distance = self.get_node_attr(j, &#39;distance&#39;)
        for j in self.get_in_neighbors(i):
            if (self.get_node_attr(j, &#39;distance&#39;) &lt; min_distance and
                self.get_edge_attr(j, i, &#39;flow&#39;) &gt; 0):
                min_distance = self.get_node_attr(j, &#39;distance&#39;)
        self.set_node_attr(i, &#39;distance&#39;, min_distance + 1)

    def show_flow(self):
        &#39;&#39;&#39;
        API: relabel(self, i)
        Description:
        Used by max_flow_preflowpush() method for display purposed.
        Post:
            &#39;color&#39; and &#39;label&#39; attribute of edges/nodes are updated.
        &#39;&#39;&#39;
        for n in self.get_node_list():
            excess = self.get_node_attr(n, &#39;excess&#39;)
            distance = self.get_node_attr(n, &#39;distance&#39;)
            self.set_node_attr(n, &#39;label&#39;, str(excess)+&#39;/&#39;+str(distance))
            for neighbor in self.get_neighbors(n):
                capacity = self.get_edge_attr(n, neighbor, &#39;capacity&#39;)
                flow = self.get_edge_attr(n, neighbor, &#39;flow&#39;)
                if capacity == INF:
                    self.set_edge_attr(n, neighbor, &#39;label&#39;,
                                       &#39;INF&#39;+&#39;/&#39;+str(flow))
                else:
                    self.set_edge_attr(n, neighbor, &#39;label&#39;,
                                       str(capacity)+&#39;/&#39;+str(flow))
                if capacity == flow:
                    self.set_edge_attr(n, neighbor, &#39;color&#39;, &#39;red&#39;)
                elif flow &gt; 0:
                    self.set_edge_attr(n, neighbor, &#39;color&#39;, &#39;green&#39;)
                else:
                    self.set_edge_attr(n, neighbor, &#39;color&#39;, &#39;black&#39;)
        self.display()

    def create_residual_graph(self):
        &#39;&#39;&#39;
        API: create_residual_graph(self)
        Description:
        Creates and returns residual graph, which is a Graph instance
        itself.
        Pre:
            (1) Arcs should have &#39;flow&#39;, &#39;capacity&#39; and &#39;cost&#39; attribute
            (2) Graph should be a directed graph
        Return:
            Returns residual graph, which is a Graph instance.
        &#39;&#39;&#39;
        if self.graph_type is UNDIRECTED_GRAPH:
            raise Exception(&#39;residual graph is defined for directed graphs.&#39;)
        residual_g = Graph(type = DIRECTED_GRAPH)
        for e in self.get_edge_list():
            capacity_e = self.get_edge_attr(e[0], e[1], &#39;capacity&#39;)
            flow_e = self.get_edge_attr(e[0], e[1], &#39;flow&#39;)
            cost_e = self.get_edge_attr(e[0], e[1], &#39;cost&#39;)
            if flow_e &gt; 0:
                residual_g.add_edge(e[1], e[0], cost=-1*cost_e,
                                    capacity=flow_e)
            if capacity_e - flow_e &gt; 0:
                residual_g.add_edge(e[0], e[1], cost=cost_e,
                                    capacity=capacity_e-flow_e)
        return residual_g

    def cycle_canceling(self, display):
        &#39;&#39;&#39;
        API:
            cycle_canceling(self, display)
        Description:
            Solves minimum cost feasible flow problem using cycle canceling
            algorithm. Returns True when an optimal solution is found, returns
            False otherwise. &#39;flow&#39; attribute values of arcs should be
            considered as junk when returned False.
        Input:
            display: Display method.
        Pre:
            (1) Arcs should have &#39;capacity&#39; and &#39;cost&#39; attribute.
            (2) Nodes should have &#39;demand&#39; attribute, this value should be
            positive if the node is a supply node, negative if it is demand
            node and 0 if it is transhipment node.
            (3) graph should not have node &#39;s&#39; and &#39;t&#39;.
        Post:
            Changes &#39;flow&#39; attributes of arcs.
        Return:
            Returns True when an optimal solution is found, returns False
            otherwise.
        &#39;&#39;&#39;
        # find a feasible solution to flow problem
        if not self.find_feasible_flow():
            return False
        # create residual graph
        residual_g = self.create_residual_graph()
        # identify a negative cycle in residual graph
        ncycle = residual_g.get_negative_cycle()
        # loop while residual graph has a negative cycle
        while ncycle is not None:
            # find capacity of cycle
            cap = residual_g.find_cycle_capacity(ncycle)
            # augment capacity amount along the cycle
            self.augment_cycle(cap, ncycle)
            # create residual graph
            residual_g = self.create_residual_graph()
            # identify next negative cycle
            ncycle = residual_g.get_negative_cycle()
        return True

    def find_feasible_flow(self):
        &#39;&#39;&#39;
        API:
            find_feasible_flow(self)
        Description:
            Solves feasible flow problem, stores solution in &#39;flow&#39; attribute
            or arcs. This method is used to get an initial feasible flow for
            simplex and cycle canceling algorithms. Uses max_flow() method.
            Other max flow methods can also be used. Returns True if a feasible
            flow is found, returns False, if the problem is infeasible. When
            the problem is infeasible &#39;flow&#39; attributes of arcs should be
            considered as junk.
        Pre:
            (1) &#39;capacity&#39; attribute of arcs
            (2) &#39;demand&#39; attribute of nodes
        Post:
            Keeps solution in &#39;flow&#39; attribute of arcs.
        Return:
            Returns True if a feasible flow is found, returns False, if the
            problem is infeasible
        &#39;&#39;&#39;
        # establish a feasible flow in the network, to do this add nodes s and
        # t and solve a max flow problem.
        nl = self.get_node_list()
        for i in nl:
            b_i = self.get_node(i).get_attr(&#39;demand&#39;)
            if b_i &gt; 0:
                # i is a supply node, add (s,i) arc
                self.add_edge(&#39;s&#39;, i, capacity=b_i)
            elif b_i &lt; 0:
                # i is a demand node, add (i,t) arc
                self.add_edge(i, &#39;t&#39;, capacity=-1*b_i)
        # solve max flow on this modified graph
        self.max_flow(&#39;s&#39;, &#39;t&#39;, &#39;off&#39;)
        # check if all demand is satisfied, i.e. the min cost problem is
        # feasible or not
        for i in self.neighbors[&#39;s&#39;]:
            flow = self.get_edge_attr(&#39;s&#39;, i, &#39;flow&#39;)
            capacity = self.get_edge_attr(&#39;s&#39;, i, &#39;capacity&#39;)
            if flow != capacity:
                self.del_node(&#39;s&#39;)
                self.del_node(&#39;t&#39;)
                return False
        # remove node &#39;s&#39; and node &#39;t&#39;
        self.del_node(&#39;s&#39;)
        self.del_node(&#39;t&#39;)
        return True

    def get_layout(self):
        &#39;&#39;&#39;
        API:
            get_layout(self)
        Description:
        Returns layout attribute of the graph.
        Return:
            Returns layout attribute of the graph.
        &#39;&#39;&#39;
        return self.attr[&#39;layout&#39;]

    def set_layout(self, value):
        &#39;&#39;&#39;
        API:
            set_layout(self, value)
        Description:
        Sets layout attribute of the graph to value.
        Input:
            value: New value of the layout.
        &#39;&#39;&#39;
        self.attr[&#39;layout&#39;]=value
        if value == &#39;dot2tex&#39;:
            self.attr[&#39;d2tgraphstyle&#39;] = &#39;every text node part/.style={align=center}&#39;

    def write(self, file_obj, layout = None, format=&#39;png&#39;):
        &#39;&#39;&#39;
        API:
            write(self, basename = &#39;graph&#39;, layout = None, format=&#39;png&#39;)
        Description:
        Writes graph to dist using layout and format.
        Input:
            basename: name of the file that will be written.
            layout: Dot layout for generating graph image.
            format: Image format, all format supported by Dot are wellcome.
        Post:
            File will be written to disk.
        &#39;&#39;&#39;
        if layout == None:
            layout = self.get_layout()
        if format == &#39;dot&#39;:
            file_obj.write(bytearray(self.to_string(), &#39;utf8&#39;))
        else:
            out = self.create(layout, format)
            if (out != None):
                file_obj.write(out)

    def create(self, layout, format, **args):
        &#39;&#39;&#39;
        API:
            create(self, layout, format, **args)
        Description:
            Returns postscript representation of graph.
        Input:
            layout: Dot layout for generating graph image.
            format: Image format, all format supported by Dot are wellcome.
        Return:
            Returns postscript representation of graph.
        &#39;&#39;&#39;
        tmp_fd, tmp_name = tempfile.mkstemp()
        tmp_file = os.fdopen(tmp_fd, &#39;w&#39;)
        tmp_file.write(self.to_string())
        tmp_file.close()
        try:
            p = subprocess.run([layout, &#39;-T&#39;+format, tmp_name],
                               capture_output = True)
        except OSError:
            print(&#39;&#39;&#39;Graphviz executable not found.
Graphviz must be installed and in your search path.
Please visit http://www.graphviz.org/ for information on installation.
After installation, ensure that the PATH variable is properly set.&#39;&#39;&#39;)
            return None

        
        p.check_returncode()

        os.remove(tmp_name)
            
        if p.stderr:
            print(p.stderr)
        return p.stdout

    def display(self, highlight = None, basename = &#39;graph&#39;, format = &#39;png&#39;,
                pause = False, wait_for_click = True):
        &#39;&#39;&#39;
        API:
            display(self, highlight = None, basename = &#39;graph&#39;, format = &#39;png&#39;,
                pause = True)
        Description:
            Displays graph according to the arguments provided.
            Current display modes: &#39;off&#39;, &#39;file&#39;, &#39;PIL&#39;, &#39;matplotlib&#39;, &#39;xdot&#39;,
            &#39;svg&#39;
            Current layout modes: Layouts provided by graphviz (&#39;dot&#39;, &#39;fdp&#39;,
            &#39;circo&#39;, etc.) and &#39;dot2tex&#39;.
            Current formats: Formats provided by graphviz (&#39;ps&#39;, &#39;pdf&#39;, &#39;png&#39;,
            etc.)
        Input:
            highlight: List of nodes to be highlighted.
            basename: File name. It will be used if display mode is &#39;file&#39;.
            format: Image format, all format supported by Dot are wellcome.
            pause: If display is &#39;matplotlib&#39;, window will remain open until closed.
            wait_for_click: If display is &#39;matplotlib&#39;, setting to True will 
            wait for a button click before proceeding. This is useful when 
            animating an algorithm. 
        Post:
            A display window will pop up or a file will be written depending
            on display mode.
        &#39;&#39;&#39;
        if self.attr[&#39;display&#39;] == &#39;off&#39;:
            return
        if highlight != None:
            for n in highlight:
                if not isinstance(n, Node):
                    n = self.get_node(n)
                n.set_attr(&#39;color&#39;, &#39;red&#39;)
        if self.get_layout() == &#39;dot2tex&#39;:
            if self.attr[&#39;display&#39;] != &#39;file&#39;:
                self.attr[&#39;display&#39;] = &#39;file&#39;
                print(&#34;Warning: Dot2tex layout can only be used with display mode &#39;file&#39;&#34;)
                print(&#34;         Automatically changing setting&#34;)
        if self.attr[&#39;display&#39;] == &#39;file&#39;:
            if self.get_layout() == &#39;dot2tex&#39;:
                try:
                    if DOT2TEX_INSTALLED:
                        if format != &#39;pdf&#39; or format != &#39;ps&#39;:
                            print(&#34;Dot2tex only supports pdf and ps formats, falling back to pdf&#34;)
                            format = &#39;pdf&#39;
                        self.set_layout(&#39;dot&#39;)
                        tex = dot2tex.dot2tex(self.to_string(), autosize=True, texmode = &#39;math&#39;, template = DOT2TEX_TEMPLATE)
                    else:
                        print(&#34;Error: Dot2tex not installed.&#34;)
                except:
                    try:
                        self.set_layout(&#39;dot&#39;)
                        with open(basename+&#39;.dot&#39;, &#34;w+b&#34;) as f:
                            self.write(f, self.get_layout(), &#39;dot&#39;)
                            p = subprocess.call([&#39;dot2tex&#39;, &#39;-t math&#39;,
                                                 basename + &#39;.dot&#39;])
                    except:
                        print(&#34;There was an error running dot2tex.&#34;)
                with open(basename+&#39;.tex&#39;, &#39;w&#39;) as f:
                    f.write(tex)
                try: 
                    subprocess.call([&#39;latex&#39;, basename])
                    if format == &#39;ps&#39;:
                        subprocess.call([&#39;dvips&#39;, basename])
                    elif format == &#39;pdf&#39;:
                        subprocess.call([&#39;pdflatex&#39;, basename])
                    self.set_layout(&#39;dot2tex&#39;)
                except:
                    print(&#34;There was an error runing latex. Is it installed?&#34;)
            else:
                with open(basename+&#39;.&#39;+format, &#34;w+b&#34;) as f:
                    self.write(f, self.get_layout(), format)
            return
        elif self.attr[&#39;display&#39;] == &#39;PIL&#39;:
            if PIL_INSTALLED:
                tmp_fd, tmp_name = tempfile.mkstemp()
                tmp_file = os.fdopen(tmp_fd, &#39;w+b&#39;)
                self.write(tmp_file, self.get_layout(), format)
                tmp_file.close()
                im = PIL_Image.open(tmp_name)
                im.show()
                os.remove(tmp_name)
            else:
                print(&#39;Error: PIL not installed. Display disabled.&#39;)
                self.attr[&#39;display&#39;] = &#39;off&#39;
        elif self.attr[&#39;display&#39;] == &#39;matplotlib&#39;:
            if MATPLOTLIB_INSTALLED and PIL_INSTALLED:
                tmp_fd, tmp_name = tempfile.mkstemp()
                tmp_file = os.fdopen(tmp_fd, &#39;w+b&#39;)
                self.write(tmp_file, self.get_layout(), format)
                tmp_file.close()
                im = PIL_Image.open(tmp_name)
                fig = plt.figure(1)
                fig.canvas.mpl_connect(&#39;close_event&#39;, handle_close)
                plt.clf()
                plt.axis(&#39;off&#39;)
                plt.imshow(im, interpolation=&#39;bilinear&#39; #resample=True
                           #extent = (0, 100, 0, 100)
                )
                if wait_for_click == True:
                    plt.draw()
                    try:
                        if plt.waitforbuttonpress(timeout = 10000):
                            plt.close()
                            exit()
                    except:
                        exit()
                else:
                    plt.show(block=pause)
                im.close()
                os.remove(tmp_name)
            else:
                print(&#39;Warning: Either matplotlib or Pillow is not installed. Display disabled.&#39;)
                self.attr[&#39;display&#39;] = &#39;off&#39;
        elif self.attr[&#39;display&#39;] == &#39;xdot&#39;:
            if XDOT_INSTALLED:
                window = xdot.DotWindow()
                window.set_dotcode(self.to_string())
                window.connect(&#39;destroy&#39;, gtk.main_quit)
                gtk.main()
            else:
                print(&#39;Error: xdot not installed. Display disabled.&#39;)
                self.attr[&#39;display&#39;] = &#39;off&#39;
        else:
            print(&#34;Unknown display mode: &#34;, end=&#39; &#39;)
            print(self.attr[&#39;display&#39;])
        if highlight != None:
            for n in highlight:
                if not isinstance(n, Node):
                    n = self.get_node(n)
                n.set_attr(&#39;color&#39;, &#39;black&#39;)

    def set_display_mode(self, value):
        &#39;&#39;&#39;
        API:
            set_display_mode(self, value)
        Description:
            Sets display mode to value.
        Input:
            value: New display mode.
        Post:
            Display mode attribute of graph is updated.
        &#39;&#39;&#39;
        self.attr[&#39;display&#39;] = value

    def max_flow(self, source, sink, display = None, algo = &#39;DFS&#39;):
        &#39;&#39;&#39;
        API: max_flow(self, source, sink, display=None)
        Description:
        Finds maximum flow from source to sink by a depth-first search based
        augmenting path algorithm.
        Pre:
            Assumes a directed graph in which each arc has a &#39;capacity&#39;
            attribute and for which there does does not exist both arcs (i,j)
            and (j, i) for any pair of nodes i and j.
        Input:
            source: Source node name.
            sink: Sink node name.
            display: Display mode.
        Post:
            The &#39;flow&#34; attribute of each arc gives a maximum flow.
        &#39;&#39;&#39;
        if display is not None:
            old_display =  self.attr[&#39;display&#39;]
            self.attr[&#39;display&#39;] = display
        nl = self.get_node_list()
        # set flow of all edges to 0
        for e in self.edge_attr:
            self.edge_attr[e][&#39;flow&#39;] = 0
            if &#39;capacity&#39; in self.edge_attr[e]:
                capacity = self.edge_attr[e][&#39;capacity&#39;]
                self.edge_attr[e][&#39;label&#39;] = str(capacity)+&#39;/0&#39;
            else:
                self.edge_attr[e][&#39;capacity&#39;] = INF
                self.edge_attr[e][&#39;label&#39;] = &#39;INF/0&#39;
        while True:
            # find an augmenting path from source to sink using DFS
            if algo == &#39;DFS&#39;:
                q = Stack()
            elif algo == &#39;BFS&#39;:
                q = Queue()
            q.push(source)
            pred = {source:None}
            explored = [source]
            for n in nl:
                self.get_node(n).set_attr(&#39;color&#39;, &#39;black&#39;)
            for e in self.edge_attr:
                if self.edge_attr[e][&#39;flow&#39;] == 0:
                    self.edge_attr[e][&#39;color&#39;] = &#39;black&#39;
                elif self.edge_attr[e][&#39;flow&#39;]==self.edge_attr[e][&#39;capacity&#39;]:
                    self.edge_attr[e][&#39;color&#39;] = &#39;red&#39;
                else:
                    self.edge_attr[e][&#39;color&#39;] = &#39;green&#39;
            self.display()
            while not q.isEmpty():
                current = q.peek()
                q.remove(current)
                if current == sink:
                    break
                out_neighbor = self.neighbors[current]
                in_neighbor = self.in_neighbors[current]
                neighbor = out_neighbor+in_neighbor
                for m in neighbor:
                    if m in explored:
                        continue
                    self.get_node(m).set_attr(&#39;color&#39;, &#39;yellow&#39;)
                    if m in out_neighbor:
                        self.set_edge_attr(current, m, &#39;color&#39;, &#39;yellow&#39;)
                        available_capacity = (
                            self.get_edge_attr(current, m, &#39;capacity&#39;)-
                            self.get_edge_attr(current, m, &#39;flow&#39;))
                    else:
                        self.set_edge_attr(m, current, &#39;color&#39;, &#39;yellow&#39;)
                        available_capacity=self.get_edge_attr(m, current, &#39;flow&#39;)
                    self.display()
                    if available_capacity &gt; 0:
                        self.get_node(m).set_attr(&#39;color&#39;, &#39;blue&#39;)
                        if m in out_neighbor:
                            self.set_edge_attr(current, m, &#39;color&#39;, &#39;blue&#39;)
                        else:
                            self.set_edge_attr(m, current, &#39;color&#39;, &#39;blue&#39;)
                        explored.append(m)
                        pred[m] = current
                        q.push(m)
                    else:
                        self.get_node(m).set_attr(&#39;color&#39;, &#39;black&#39;)
                        if m in out_neighbor:
                            if (self.get_edge_attr(current, m, &#39;flow&#39;) ==
                                self.get_edge_attr(current, m, &#39;capacity&#39;)):
                                self.set_edge_attr(current, m, &#39;color&#39;, &#39;red&#39;)
                            elif self.get_edge_attr(current, m, &#39;flow&#39;) == 0:
                                self.set_edge_attr(current, m, &#39;color&#39;, &#39;black&#39;)
                            #else:
                            #    self.set_edge_attr(current, m, &#39;color&#39;, &#39;green&#39;)
                        else:
                            if (self.get_edge_attr(m, current, &#39;flow&#39;) ==
                                self.get_edge_attr(m, current, &#39;capacity&#39;)):
                                self.set_edge_attr(m, current, &#39;color&#39;, &#39;red&#39;)
                            elif self.get_edge_attr(m, current, &#39;flow&#39;) == 0:
                                self.set_edge_attr(m, current, &#39;color&#39;, &#39;black&#39;)
                            #else:
                            #    self.set_edge_attr(m, current, &#39;color&#39;, &#39;green&#39;)
                    self.display()
            # if no path with positive capacity from source sink exists, stop
            if sink not in pred:
                break
            # find capacity of the path
            current = sink
            min_capacity = &#39;infinite&#39;
            while True:
                m = pred[current]
                if (m,current) in self.edge_attr:
                    arc_capacity = self.edge_attr[(m, current)][&#39;capacity&#39;]
                    flow = self.edge_attr[(m, current)][&#39;flow&#39;]
                    potential = arc_capacity-flow
                    if min_capacity == &#39;infinite&#39;:
                        min_capacity = potential
                    elif min_capacity &gt; potential:
                        min_capacity = potential
                else:
                    potential = self.edge_attr[(current, m)][&#39;flow&#39;]
                    if min_capacity == &#39;infinite&#39;:
                        min_capacity = potential
                    elif min_capacity &gt; potential:
                        min_capacity = potential
                if m == source:
                    break
                current = m
            # update flows on the path
            current = sink
            while True:
                m = pred[current]
                if (m, current) in self.edge_attr:
                    flow = self.edge_attr[(m, current)][&#39;flow&#39;]
                    capacity = self.edge_attr[(m, current)][&#39;capacity&#39;]
                    new_flow = flow+min_capacity
                    self.edge_attr[(m, current)][&#39;flow&#39;] = new_flow
                    if capacity == INF:
                        self.edge_attr[(m, current)][&#39;label&#39;] = \
                            &#39;INF&#39; + &#39;/&#39;+str(new_flow)
                    else:
                        self.edge_attr[(m, current)][&#39;label&#39;] = \
                            str(capacity)+&#39;/&#39;+str(new_flow)
                    if new_flow==capacity:
                        self.edge_attr[(m, current)][&#39;color&#39;] = &#39;red&#39;
                    else:
                        self.edge_attr[(m, current)][&#39;color&#39;] = &#39;green&#39;
                    self.display()
                else:
                    flow = self.edge_attr[(current, m)][&#39;flow&#39;]
                    capacity = self.edge_attr[(current, m)][&#39;capacity&#39;]
                    new_flow = flow-min_capacity
                    self.edge_attr[(current, m)][&#39;flow&#39;] = new_flow
                    if capacity == INF:
                        self.edge_attr[(current, m)][&#39;label&#39;] = \
                            &#39;INF&#39; + &#39;/&#39;+str(new_flow)
                    else:
                        self.edge_attr[(current, m)][&#39;label&#39;] = \
                            str(capacity)+&#39;/&#39;+str(new_flow)
                    if new_flow==0:
                        self.edge_attr[(current, m)][&#39;color&#39;] = &#39;red&#39;
                    else:
                        self.edge_attr[(current, m)][&#39;color&#39;] = &#39;green&#39;
                    self.display()
                if m == source:
                    break
                current = m
        if display is not None:
            self.attr[&#39;display&#39;] = old_display

    def get_negative_cycle(self):
        &#39;&#39;&#39;
        API:
            get_negative_cycle(self)
        Description:
            Finds and returns negative cost cycle using &#39;cost&#39; attribute of
            arcs. Return value is a list of nodes representing cycle it is in
            the following form; n_1-n_2-...-n_k, when the cycle has k nodes.
        Pre:
            Arcs should have &#39;cost&#39; attribute.
        Return:
            Returns a list of nodes in the cycle if a negative cycle exists,
            returns None otherwise.
        &#39;&#39;&#39;
        nl = self.get_node_list()
        i = nl[0]
        (valid, distance, nextn) = self.floyd_warshall()
        if not valid:
            cycle = self.floyd_warshall_get_cycle(distance, nextn)
            return cycle
        else:
            return None

    def floyd_warshall(self):
        &#39;&#39;&#39;
        API:
            floyd_warshall(self)
        Description:
            Finds all pair shortest paths and stores it in a list of lists.
            This is possible if the graph does not have negative cycles. It will
            return a tuple with 3 elements. The first element indicates whether
            the graph has a negative cycle. It is true if the graph does not
            have a negative cycle, ie. distances found are valid shortest
            distances. The second element is a dictionary of shortest distances
            between nodes. Keys are tuple of node pairs ie. (i,j). The third
            element is a dictionary that helps to retrieve the shortest path
            between nodes. Then return value can be represented as (validity,
            distance, nextn) where nextn is the dictionary to retrieve paths.
            distance and nextn can be used as inputs to other methods to get
            shortest path between nodes.
        Pre:
            Arcs should have &#39;cost&#39; attribute.
        Return:
            Returns (validity, distance, nextn). The distances are valid if
            validity is True.
        &#39;&#39;&#39;
        nl = self.get_node_list()
        el = self.get_edge_list()
        # initialize distance
        distance = {}
        for i in nl:
            for j in nl:
                distance[(i,j)] = &#39;infinity&#39;
        for i in nl:
            distance[(i,i)] = 0
        for e in el:
            distance[(e[0],e[1])] = self.get_edge_cost(e)
        # == end of distance initialization
        # initialize next
        nextn = {}
        for i in nl:
            for j in nl:
                if i==j or distance[(i,j)]==&#39;infinity&#39;:
                    nextn[(i,j)] = None
                else:
                    nextn[(i,j)] = i
        # == end of next initialization
        # compute shortest distance
        for k in nl:
            for i in nl:
                for j in nl:
                    if distance[(i,k)]==&#39;infinity&#39; or distance[(k,j)]==&#39;infinity&#39;:
                        continue
                    elif distance[(i,j)]==&#39;infinity&#39;:
                        distance[(i,j)] = distance[(i,k)] + distance[(k,j)]
                        nextn[(i,j)] = nextn[(k,j)]
                    elif distance[(i,j)] &gt; distance[(i,k)] + distance[(k,j)]:
                        distance[(i,j)] = distance[(i,k)] + distance[(k,j)]
                        nextn[(i,j)] = nextn[(k,j)]
        # == end of compute shortest distance
        # check if graph has negative cycles
        for i in nl:
            if distance[(i,i)] &lt; 0:
                # shortest distances are not valid
                # graph has negative cycle
                return (False, distance, nextn)
        return (True, distance, nextn)

    def floyd_warshall_get_path(self, distance, nextn, i, j):
        &#39;&#39;&#39;
        API:
            floyd_warshall_get_path(self, distance, nextn, i, j):
        Description:
            Finds shortest path between i and j using distance and nextn
            dictionaries.
        Pre:
            (1) distance and nextn are outputs of floyd_warshall method.
            (2) The graph does not have a negative cycle, , ie.
            distance[(i,i)] &gt;=0 for all node i.
        Return:
            Returns the list of nodes on the path from i to j, ie. [i,...,j]
        &#39;&#39;&#39;
        if distance[(i,j)]==&#39;infinity&#39;:
            return None
        k = nextn[(i,j)]
        path = self.floyd_warshall_get_path
        if i==k:
            return [i, j]
        else:
            return path(distance, nextn, i,k) + [k] + path(distance, nextn, k,j)

    def floyd_warshall_get_cycle(self, distance, nextn, element = None):
        &#39;&#39;&#39;
        API:
            floyd_warshall_get_cycle(self, distance, nextn, element = None)
        Description:
            Finds a negative cycle in the graph.
        Pre:
            (1) distance and nextn are outputs of floyd_warshall method.
            (2) The graph should have a negative cycle, , ie.
            distance[(i,i)] &lt; 0 for some node i.
        Return:
            Returns the list of nodes on the cycle. Ex: [i,j,k,...,r], where
            (i,j), (j,k) and (r,i) are some edges in the cycle.
        &#39;&#39;&#39;
        nl = self.get_node_list()
        if element is None:
            for i in nl:
                if distance[(i,i)] &lt; 0:
                    # graph has a cycle on the path from i to i.
                    element = i
                    break
            else:
                raise Exception(&#39;Graph does not have a negative cycle!&#39;)
        elif distance[(element,element)] &gt;= 0:
            raise Exception(&#39;Graph does not have a negative cycle that contains node &#39;+str(element)+&#39;!&#39;)
        # find the cycle on the path from i to i.
        cycle = [element]
        k = nextn[(element,element)]
        while k not in cycle:
            cycle.insert(1,k)
            k = nextn[(element,k)]
        if k==element:
            return cycle
        else:
            return self.floyd_warshall_get_cycle(distance, nextn, k)

    def find_cycle_capacity(self, cycle):
        &#39;&#39;&#39;
        API:
            find_cycle_capacity(self, cycle):
        Description:
            Finds capacity of the cycle input.
        Pre:
            (1) Arcs should have &#39;capacity&#39; attribute.
        Input:
            cycle: a list representing a cycle
        Return:
            Returns an integer number representing capacity of cycle.
        &#39;&#39;&#39;
        index = 0
        k = len(cycle)
        capacity = self.get_edge_attr(cycle[k-1], cycle[0], &#39;capacity&#39;)
        while index&lt;(k-1):
            i = cycle[index]
            j = cycle[index+1]
            capacity_ij = self.get_edge_attr(i, j, &#39;capacity&#39;)
            if capacity &gt; capacity_ij:
                capacity = capacity_ij
            index += 1
        return capacity

    def fifo_label_correcting(self, source):
        &#39;&#39;&#39;
        API:
            fifo_label_correcting(self, source)
        Description:
            finds shortest path from source to every other node. Returns
            predecessor dictionary. If graph has a negative cycle, detects it
            and returns to it.
        Pre:
            (1) &#39;cost&#39; attribute of arcs. It will be used to compute shortest
            path.
        Input:
            source: source node
        Post:
            Modifies &#39;distance&#39; attribute of nodes.
        Return:
            If there is no negative cycle returns to (True, pred), otherwise
            returns to (False, cycle) where pred is the predecessor dictionary
            and cycle is a list of nodes that represents cycle. It is in
            [n_1, n_2, ..., n_k] form where the cycle has k nodes.
        &#39;&#39;&#39;
        pred = {}
        self.get_node(source).set_attr(&#39;distance&#39;, 0)
        pred[source] = None
        for n in self.neighbors:
            if n!=source:
                self.get_node(n).set_attr(&#39;distance&#39;, &#39;inf&#39;)
        q = [source]
        while q:
            i = q[0]
            q = q[1:]
            for j in self.neighbors[i]:
                distance_j = self.get_node(j).get_attr(&#39;distance&#39;)
                distance_i = self.get_node(i).get_attr(&#39;distance&#39;)
                c_ij = self.get_edge_attr(i, j, &#39;cost&#39;)
                if distance_j &gt; distance_i + c_ij:
                    self.get_node(j).set_attr(&#39;distance&#39;, distance_i+c_ij)
                    if j in pred:
                        pred[j] = i
                        cycle = self.label_correcting_check_cycle(j, pred)
                        if cycle is not None:
                            return (False, cycle)
                    else:
                        pred[j] = i
                    if j not in q:
                        q.append(j)
        return (True, pred)

    def label_correcting_check_cycle(self, j, pred):
        &#39;&#39;&#39;
        API:
            label_correcting_check_cycle(self, j, pred)
        Description:
            Checks if predecessor dictionary has a cycle, j represents the node
            that predecessor is recently updated.
        Pre:
            (1) predecessor of source node should be None.
        Input:
            j: node that predecessor is recently updated.
            pred: predecessor dictionary
        Return:
            If there exists a cycle, returns the list that represents the
            cycle, otherwise it returns to None.
        &#39;&#39;&#39;
        labelled = {}
        for n in self.neighbors:
            labelled[n] = None
        current = j
        while current != None:
            if labelled[current]==j:
                cycle = self.label_correcting_get_cycle(j, pred)
                return cycle
            labelled[current] = j
            current = pred[current]
        return None

    def label_correcting_get_cycle(self, j, pred):
        &#39;&#39;&#39;
        API:
            label_correcting_get_cycle(self, labelled, pred)
        Description:
            In label correcting check cycle it is decided pred has a cycle and
            nodes in the cycle are labelled. We will create a list of nodes
            in the cycle using labelled and pred inputs.
        Pre:
            This method should be called from label_correcting_check_cycle(),
            unless you are sure about what you are doing.
        Input:
            j: Node that predecessor is recently updated. We know that it is
            in the cycle
            pred: Predecessor dictionary that contains a cycle
        Post:
            Returns a list of nodes that represents cycle. It is in
            [n_1, n_2, ..., n_k] form where the cycle has k nodes.
        &#39;&#39;&#39;
        cycle = []
        cycle.append(j)
        current = pred[j]
        while current!=j:
            cycle.append(current)
            current = pred[current]
        cycle.reverse()
        return cycle

    def augment_cycle(self, amount, cycle):
        &#39;&#39;&#39;
        API:
            augment_cycle(self, amount, cycle):
        Description:
            Augments &#39;amount&#39; unit of flow along cycle.
        Pre:
            Arcs should have &#39;flow&#39; attribute.
        Inputs:
            amount: An integer representing the amount to augment
            cycle: A list representing a cycle
        Post:
            Changes &#39;flow&#39; attributes of arcs.
        &#39;&#39;&#39;
        index = 0
        k = len(cycle)
        while index&lt;(k-1):
            i = cycle[index]
            j = cycle[index+1]
            if (i,j) in self.edge_attr:
                flow_ij = self.edge_attr[(i,j)][&#39;flow&#39;]
                self.edge_attr[(i,j)][&#39;flow&#39;] = flow_ij+amount
            else:
                flow_ji = self.edge_attr[(j,i)][&#39;flow&#39;]
                self.edge_attr[(j,i)][&#39;flow&#39;] = flow_ji-amount
            index += 1
        i = cycle[k-1]
        j = cycle[0]
        if (i,j) in self.edge_attr:
            flow_ij = self.edge_attr[(i,j)][&#39;flow&#39;]
            self.edge_attr[(i,j)][&#39;flow&#39;] = flow_ij+amount
        else:
            flow_ji = self.edge_attr[(j,i)][&#39;flow&#39;]
            self.edge_attr[(j,i)][&#39;flow&#39;] = flow_ji-amount

    def network_simplex(self, display, pivot, root):
        &#39;&#39;&#39;
        API:
            network_simplex(self, display, pivot, root)
        Description:
            Solves minimum cost feasible flow problem using network simplex
            algorithm. It is recommended to use min_cost_flow(algo=&#39;simplex&#39;)
            instead of using network_simplex() directly. Returns True when an
            optimal solution is found, returns False otherwise. &#39;flow&#39; attribute
            values of arcs should be considered as junk when returned False.
        Pre:
            (1) check Pre section of min_cost_flow()
        Input:
            pivot: specifies pivot rule. Check min_cost_flow()
            display: &#39;off&#39; for no display, &#39;matplotlib&#39; for live update of
            spanning tree.
            root: Root node for the underlying spanning trees that will be
            generated by network simplex algorthm.
        Post:
            (1) Changes &#39;flow&#39; attribute of edges.
        Return:
            Returns True when an optimal solution is found, returns
            False otherwise.
        &#39;&#39;&#39;
        # ==== determine an initial tree structure (T,L,U)
        # find a feasible flow
        if not self.find_feasible_flow():
            return False
        t = self.simplex_find_tree()
        self.set_display_mode(display)
        # mark spanning tree arcs
        self.simplex_mark_st_arcs(t)
        # display initial spanning tree
        t.simplex_redraw(display, root)
        t.set_display_mode(display)
        #t.display()
        self.display()
        # set predecessor, depth and thread indexes
        t.simplex_search(root, 1)
        # compute potentials
        self.simplex_compute_potentials(t, root)
        # while some nontree arc violates optimality conditions
        while not self.simplex_optimal(t):
            self.display()
            # select an entering arc (k,l)
            (k,l) = self.simplex_select_entering_arc(t, pivot)
            self.simplex_mark_entering_arc(k, l)
            self.display()
            # determine leaving arc
            ((p,q), capacity, cycle)=self.simplex_determine_leaving_arc(t,k,l)
            # mark leaving arc
            self.simplex_mark_leaving_arc(p, q)
            self.display()
            self.simplex_remove_arc(t, p, q, capacity, cycle)
            # display after arc removed
            self.display()
            self.simplex_mark_st_arcs(t)
            self.display()
            # set predecessor, depth and thread indexes
            t.simplex_redraw(display, root)
            #t.display()
            t.simplex_search(root, 1)
            # compute potentials
            self.simplex_compute_potentials(t, root)
        return True

    def simplex_mark_leaving_arc(self, p, q):
        &#39;&#39;&#39;
        API:
            simplex_mark_leving_arc(self, p, q)
        Description:
            Marks leaving arc.
        Input:
            p: tail of the leaving arc
            q: head of the leaving arc
        Post:
            Changes color attribute of leaving arc.
        &#39;&#39;&#39;
        self.set_edge_attr(p, q, &#39;color&#39;, &#39;red&#39;)

    def simplex_determine_leaving_arc(self, t, k, l):
        &#39;&#39;&#39;
        API:
            simplex_determine_leaving_arc(self, t, k, l)
        Description:
            Determines and returns the leaving arc.
        Input:
            t: current spanning tree solution.
            k: tail of the entering arc.
            l: head of the entering arc.
        Return:
            Returns the tuple that represents leaving arc, capacity of the
            cycle and cycle.
        &#39;&#39;&#39;
        # k,l are the first two elements of the cycle
        cycle = self.simplex_identify_cycle(t, k, l)
        flow_kl = self.get_edge_attr(k, l, &#39;flow&#39;)
        capacity_kl = self.get_edge_attr(k, l, &#39;capacity&#39;)
        min_capacity = capacity_kl
        # check if k,l is in U or L
        if flow_kl==capacity_kl:
            # l,k will be the last two elements
            cycle.reverse()
        n = len(cycle)
        index = 0
        # determine last blocking arc
        t.add_edge(k, l)
        tel = t.get_edge_list()
        while index &lt; (n-1):
            if (cycle[index], cycle[index+1]) in tel:
                flow = self.edge_attr[(cycle[index], cycle[index+1])][&#39;flow&#39;]
                capacity = \
                    self.edge_attr[(cycle[index],cycle[index+1])][&#39;capacity&#39;]
                if min_capacity &gt;= (capacity-flow):
                    candidate = (cycle[index], cycle[index+1])
                    min_capacity = capacity-flow
            else:
                flow = self.edge_attr[(cycle[index+1], cycle[index])][&#39;flow&#39;]
                if min_capacity &gt;= flow:
                    candidate = (cycle[index+1], cycle[index])
                    min_capacity = flow
            index += 1
        # check arc (cycle[n-1], cycle[0])
        if (cycle[n-1], cycle[0]) in tel:
            flow = self.edge_attr[(cycle[n-1], cycle[0])][&#39;flow&#39;]
            capacity = self.edge_attr[(cycle[n-1], cycle[0])][&#39;capacity&#39;]
            if min_capacity &gt;= (capacity-flow):
                candidate = (cycle[n-1], cycle[0])
                min_capacity = capacity-flow
        else:
            flow = self.edge_attr[(cycle[0], cycle[n-1])][&#39;flow&#39;]
            if min_capacity &gt;= flow:
                candidate = (cycle[0], cycle[n-1])
                min_capacity = flow
        return (candidate, min_capacity, cycle)

    def simplex_mark_entering_arc(self, k, l):
        &#39;&#39;&#39;
        API:
            simplex_mark_entering_arc(self, k, l)
        Description:
            Marks entering arc (k,l)
        Input:
            k: tail of the entering arc
            l: head of the entering arc
        Post:
            (1) color attribute of the arc (k,l)
        &#39;&#39;&#39;
        self.set_edge_attr(k, l, &#39;color&#39;, &#39;green&#39;)

    def simplex_mark_st_arcs(self, t):
        &#39;&#39;&#39;
        API:
            simplex_mark_st_arcs(self, t)
        Description:
            Marks spanning tree arcs.
            Case 1, Blue: Arcs that are at lower bound and in tree.
            Case 2, Red: Arcs that are at upper bound and in tree.
            Case 3, Green: Arcs that are between bounds are green.
            Case 4, Brown: Non-tree arcs at lower bound.
            Case 5, Violet: Non-tree arcs at upper bound.
        Input:
            t: t is the current spanning tree
        Post:
            (1) color attribute of edges.
        &#39;&#39;&#39;
        tel = list(t.edge_attr.keys())
        for e in self.get_edge_list():
            flow_e = self.edge_attr[e][&#39;flow&#39;]
            capacity_e = self.edge_attr[e][&#39;capacity&#39;]
            if e in tel:
                if flow_e == 0:
                    self.edge_attr[e][&#39;color&#39;] = &#39;blue&#39;
                elif flow_e == capacity_e:
                    self.edge_attr[e][&#39;color&#39;] = &#39;blue&#39;
                else:
                    self.edge_attr[e][&#39;color&#39;] = &#39;blue&#39;
            else:
                if flow_e == 0:
                    self.edge_attr[e][&#39;color&#39;] = &#39;black&#39;
                elif flow_e == capacity_e:
                    self.edge_attr[e][&#39;color&#39;] = &#39;black&#39;
                else:
                    msg = &#34;Arc is not in ST but has flow between bounds.&#34;
                    raise Exception(msg)

    def print_flow(self):
        &#39;&#39;&#39;
        API:
            print_flow(self)
        Description:
            Prints all positive flows to stdout. This method can be used for
            debugging purposes.
        &#39;&#39;&#39;
        print(&#39;printing current edge, flow, capacity&#39;)
        for e in self.edge_attr:
            if self.edge_attr[e][&#39;flow&#39;]!=0:
                print(e, str(self.edge_attr[e][&#39;flow&#39;]).ljust(4), end=&#39; &#39;)
                print(str(self.edge_attr[e][&#39;capacity&#39;]).ljust(4))

    def simplex_redraw(self, display, root):
        &#39;&#39;&#39;
        API:
            simplex_redraw(self, display, root)
        Description:
            Returns a new graph instance that is same as self but adds nodes
            and arcs in a way that the resulting tree will be displayed
            properly.
        Input:
            display: display mode
            root: root node in tree.
        Return:
            Returns a graph same as self.
        &#39;&#39;&#39;
        nl = self.get_node_list()
        el = self.get_edge_list()
        new = Graph(type=DIRECTED_GRAPH, layout=&#39;dot&#39;, display=display)
        pred_i = self.get_node(root).get_attr(&#39;pred&#39;)
        thread_i = self.get_node(root).get_attr(&#39;thread&#39;)
        depth_i = self.get_node(root).get_attr(&#39;depth&#39;)
        new.add_node(root, pred=pred_i, thread=thread_i, depth=depth_i)
        q = [root]
        visited = [root]
        while q:
            name = q.pop()
            visited.append(name)
            neighbors = self.neighbors[name] + self.in_neighbors[name]
            for n in neighbors:
                if n not in new.get_node_list():
                    pred_i = self.get_node(n).get_attr(&#39;pred&#39;)
                    thread_i = self.get_node(n).get_attr(&#39;thread&#39;)
                    depth_i = self.get_node(n).get_attr(&#39;depth&#39;)
                    new.add_node(n, pred=pred_i, thread=thread_i, depth=depth_i)
                if (name,n) in el:
                    if (name,n) not in new.edge_attr:
                        new.add_edge(name,n)
                else:
                    if (n,name) not in new.edge_attr:
                        new.add_edge(n,name)
                if n not in visited:
                    q.append(n)
        for e in el:
            flow = self.edge_attr[e][&#39;flow&#39;]
            capacity = self.edge_attr[e][&#39;capacity&#39;]
            cost = self.edge_attr[e][&#39;cost&#39;]
            new.edge_attr[e][&#39;flow&#39;] = flow
            new.edge_attr[e][&#39;capacity&#39;] = capacity
            new.edge_attr[e][&#39;cost&#39;] = cost
            new.edge_attr[e][&#39;label&#39;] =  &#34;%d/%d/%d&#34; %(flow,capacity,cost)
        return new

    def simplex_remove_arc(self, t, p, q, min_capacity, cycle):
        &#39;&#39;&#39;
        API:
            simplex_remove_arc(self, p, q, min_capacity, cycle)
        Description:
            Removes arc (p,q), updates t, updates flows, where (k,l) is
            the entering arc.
        Input:
            t: tree solution to be updated.
            p: tail of the leaving arc.
            q: head of the leaving arc.
            min_capacity: capacity of the cycle.
            cycle: cycle obtained when entering arc considered.
        Post:
            (1) updates t.
            (2) updates &#39;flow&#39; attributes.
        &#39;&#39;&#39;
        # augment min_capacity along cycle
        n = len(cycle)
        tel = list(t.edge_attr.keys())
        index = 0
        while index &lt; (n-1):
            if (cycle[index], cycle[index+1]) in tel:
                flow_e = self.edge_attr[(cycle[index], cycle[index+1])][&#39;flow&#39;]
                self.edge_attr[(cycle[index], cycle[index+1])][&#39;flow&#39;] =\
                    flow_e+min_capacity
            else:
                flow_e = self.edge_attr[(cycle[index+1], cycle[index])][&#39;flow&#39;]
                self.edge_attr[(cycle[index+1], cycle[index])][&#39;flow&#39;] =\
                    flow_e-min_capacity
            index += 1
        # augment arc cycle[n-1], cycle[0]
        if (cycle[n-1], cycle[0]) in tel:
            flow_e = self.edge_attr[(cycle[n-1], cycle[0])][&#39;flow&#39;]
            self.edge_attr[(cycle[n-1], cycle[0])][&#39;flow&#39;] =\
                flow_e+min_capacity
        else:
            flow_e = self.edge_attr[(cycle[0], cycle[n-1])][&#39;flow&#39;]
            self.edge_attr[(cycle[0], cycle[n-1])][&#39;flow&#39;] =\
                flow_e-min_capacity
        # remove leaving arc
        t.del_edge((p, q))
        # set label of removed arc
        flow_pq = self.get_edge_attr(p, q, &#39;flow&#39;)
        capacity_pq = self.get_edge_attr(p, q, &#39;capacity&#39;)
        cost_pq = self.get_edge_attr(p, q, &#39;cost&#39;)
        self.set_edge_attr(p, q, &#39;label&#39;,
                           &#34;%d/%d/%d&#34; %(flow_pq,capacity_pq,cost_pq))
        for e in t.edge_attr:
            flow = self.edge_attr[e][&#39;flow&#39;]
            capacity = self.edge_attr[e][&#39;capacity&#39;]
            cost = self.edge_attr[e][&#39;cost&#39;]
            t.edge_attr[e][&#39;flow&#39;] = flow
            t.edge_attr[e][&#39;capacity&#39;] = capacity
            t.edge_attr[e][&#39;cost&#39;] = cost
            t.edge_attr[e][&#39;label&#39;] = &#34;%d/%d/%d&#34; %(flow,capacity,cost)
            self.edge_attr[e][&#39;label&#39;] = &#34;%d/%d/%d&#34; %(flow,capacity,cost)

    def simplex_select_entering_arc(self, t, pivot):
        &#39;&#39;&#39;
        API:
            simplex_select_entering_arc(self, t, pivot)
        Description:
            Decides and returns entering arc using pivot rule.
        Input:
            t: current spanning tree solution
            pivot: May be one of the following; &#39;first_eligible&#39; or &#39;dantzig&#39;.
            &#39;dantzig&#39; is the default value.
        Return:
            Returns entering arc tuple (k,l)
        &#39;&#39;&#39;
        if pivot==&#39;dantzig&#39;:
            # pick the maximum violation
            candidate = {}
            for e in self.edge_attr:
                if e in t.edge_attr:
                    continue
                flow_ij = self.edge_attr[e][&#39;flow&#39;]
                potential_i = self.get_node(e[0]).get_attr(&#39;potential&#39;)
                potential_j = self.get_node(e[1]).get_attr(&#39;potential&#39;)
                capacity_ij = self.edge_attr[e][&#39;capacity&#39;]
                c_ij = self.edge_attr[e][&#39;cost&#39;]
                cpi_ij = c_ij - potential_i + potential_j
                if flow_ij==0:
                    if cpi_ij &lt; 0:
                        candidate[e] = cpi_ij
                elif flow_ij==capacity_ij:
                    if cpi_ij &gt; 0:
                        candidate[e] = cpi_ij
            for e in candidate:
                max_c = e
                max_v = abs(candidate[e])
                break
            for e in candidate:
                if max_v &lt; abs(candidate[e]):
                    max_c = e
                    max_v = abs(candidate[e])
        elif pivot==&#39;first_eligible&#39;:
            # pick the first eligible
            for e in self.edge_attr:
                if e in t.edge_attr:
                    continue
                flow_ij = self.edge_attr[e][&#39;flow&#39;]
                potential_i = self.get_node(e[0]).get_attr(&#39;potential&#39;)
                potential_j = self.get_node(e[1]).get_attr(&#39;potential&#39;)
                capacity_ij = self.edge_attr[e][&#39;capacity&#39;]
                c_ij = self.edge_attr[e][&#39;cost&#39;]
                cpi_ij = c_ij - potential_i + potential_j
                if flow_ij==0:
                    if cpi_ij &lt; 0:
                        max_c = e
                        max_v = abs(cpi_ij)
                elif flow_ij==capacity_ij:
                    if cpi_ij &gt; 0:
                        max_c = e
                        max_v = cpi_ij
        else:
            raise Exception(&#34;Unknown pivot rule.&#34;)
        return max_c

    def simplex_optimal(self, t):
        &#39;&#39;&#39;
        API:
            simplex_optimal(self, t)
        Description:
            Checks if the current solution is optimal, if yes returns True,
            False otherwise.
        Pre:
            &#39;flow&#39; attributes represents a solution.
        Input:
            t: Graph instance tat reperesents spanning tree solution.
        Return:
            Returns True if the current solution is optimal (optimality
            conditions are satisfied), else returns False
        &#39;&#39;&#39;
        for e in self.edge_attr:
            if e in t.edge_attr:
                continue
            flow_ij = self.edge_attr[e][&#39;flow&#39;]
            potential_i = self.get_node(e[0]).get_attr(&#39;potential&#39;)
            potential_j = self.get_node(e[1]).get_attr(&#39;potential&#39;)
            capacity_ij = self.edge_attr[e][&#39;capacity&#39;]
            c_ij = self.edge_attr[e][&#39;cost&#39;]
            cpi_ij = c_ij - potential_i + potential_j
            if flow_ij==0:
                if cpi_ij &lt; 0:
                    return False
            elif flow_ij==capacity_ij:
                if cpi_ij &gt; 0:
                    return False
        return True

    def simplex_find_tree(self):
        &#39;&#39;&#39;
        API:
            simplex_find_tree(self)
        Description:
            Assumes a feasible flow solution stored in &#39;flow&#39; attribute&#39;s of
            arcs and converts this solution to a feasible spanning tree
            solution.
        Pre:
            (1) &#39;flow&#39; attributes represents a feasible flow solution.
        Post:
            (1) &#39;flow&#39; attributes may change when eliminating cycles.
        Return:
            Return a Graph instance that is a spanning tree solution.
        &#39;&#39;&#39;
        # find a cycle
        solution_g = self.get_simplex_solution_graph()
        cycle = solution_g.simplex_find_cycle()
        while cycle is not None:
            # find amount to augment and direction
            amount = self.simplex_augment_cycle(cycle)
            # augment along the cycle
            self.augment_cycle(amount, cycle)
            # find a new cycle
            solution_g = self.get_simplex_solution_graph()
            cycle = solution_g.simplex_find_cycle()
        # check if the solution is connected
        while self.simplex_connect(solution_g):
            pass
        # add attributes
        for e in self.edge_attr:
            flow = self.edge_attr[e][&#39;flow&#39;]
            capacity = self.edge_attr[e][&#39;capacity&#39;]
            cost = self.edge_attr[e][&#39;cost&#39;]
            self.edge_attr[e][&#39;label&#39;] = &#34;%d/%d/%d&#34; %(flow,capacity,cost)
            if e in solution_g.edge_attr:
                solution_g.edge_attr[e][&#39;flow&#39;] = flow
                solution_g.edge_attr[e][&#39;capacity&#39;] = capacity
                solution_g.edge_attr[e][&#39;cost&#39;] = cost
                solution_g.edge_attr[e][&#39;label&#39;] = &#34;%d/%d/%d&#34; %(flow,capacity,cost)
        return solution_g

    def simplex_connect(self, solution_g):
        &#39;&#39;&#39;
        API:
            simplex_connect(self, solution_g)
        Description:
            At this point we assume that the solution does not have a cycle.
            We check if all the nodes are connected, if not we add an arc to
            solution_g that does not create a cycle and return True. Otherwise
            we do nothing and return False.
        Pre:
            (1) We assume there is no cycle in the solution.
        Input:
            solution_g: current spanning tree solution instance.
        Post:
            (1) solution_g is updated. An arc that does not create a cycle is
            added.
            (2) &#39;component&#39; attribute of nodes are changed.
        Return:
            Returns True if an arc is added, returns False otherwise.
        &#39;&#39;&#39;
        nl = solution_g.get_node_list()
        current = nl[0]
        pred = solution_g.simplex_search(current, current)
        separated = list(pred.keys())
        for n in nl:
            if solution_g.get_node(n).get_attr(&#39;component&#39;) != current:
                # find an arc from n to seperated
                for m in separated:
                    if (n,m) in self.edge_attr:
                        solution_g.add_edge(n,m)
                        return True
                    elif (m,n) in self.edge_attr:
                        solution_g.add_edge(m,n)
                        return True
        return False

    def simplex_search(self, source, component_nr):
        &#39;&#39;&#39;
        API:
            simplex_search(self, source, component_nr)
        Description:
            Searches graph starting from source. Its difference from usual
            search is we can also go backwards along an arc. When the graph
            is a spanning tree it computes predecessor, thread and depth
            indexes and stores them as node attributes. These values should be
            considered as junk when the graph is not a spanning tree.
        Input:
            source: source node
            component_nr: component number
        Post:
            (1) Sets the component number of all reachable nodes to component.
            Changes &#39;component&#39; attribute of nodes.
            (2) Sets &#39;pred&#39;, &#39;thread&#39; and &#39;depth&#39; attributes of nodes. These
            values are junk if the graph is not a tree.
        Return:
            Returns predecessor dictionary.
        &#39;&#39;&#39;
        q = [source]
        pred = {source:None}
        depth = {source:0}
        sequence = []
        for n in self.neighbors:
            self.get_node(n).set_attr(&#39;component&#39;, None)
        while q:
            current = q.pop()
            self.get_node(current).set_attr(&#39;component&#39;, component_nr)
            sequence.append(current)
            neighbors = self.in_neighbors[current] + self.neighbors[current]
            for n in neighbors:
                if n in pred:
                    continue
                self.get_node(n).set_attr(&#39;component&#39;, component_nr)
                pred[n] = current
                depth[n] = depth[current]+1
                q.append(n)
        for i in range(len(sequence)-1):
            self.get_node(sequence[i]).set_attr(&#39;thread&#39;, int(sequence[i+1]))
        self.get_node(sequence[-1]).set_attr(&#39;thread&#39;, int(sequence[0]))
        for n in pred:
            self.get_node(n).set_attr(&#39;pred&#39;, pred[n])
            self.get_node(n).set_attr(&#39;depth&#39;, depth[n])
        return pred

    def simplex_augment_cycle(self, cycle):
        &#39;&#39;&#39;
        API:
            simplex_augment_cycle(self, cycle)
        Description:
            Augments along the cycle to break it.
        Pre:
            &#39;flow&#39;, &#39;capacity&#39; attributes on arcs.
        Input:
            cycle: list representing a cycle in the solution
        Post:
            &#39;flow&#39; attribute will be modified.
        &#39;&#39;&#39;
        # find amount to augment
        index = 0
        k = len(cycle)
        el = list(self.edge_attr.keys())
        # check arc (cycle[k-1], cycle[0])
        if (cycle[k-1], cycle[0]) in el:
            min_capacity = self.edge_attr[(cycle[k-1], cycle[0])][&#39;capacity&#39;]-\
                              self.edge_attr[(cycle[k-1], cycle[0])][&#39;flow&#39;]
        else:
            min_capacity = self.edge_attr[(cycle[0], cycle[k-1])][&#39;flow&#39;]
        # check rest of the arcs in the cycle
        while index&lt;(k-1):
            i = cycle[index]
            j = cycle[index+1]
            if (i,j) in el:
                capacity_ij = self.edge_attr[(i,j)][&#39;capacity&#39;] -\
                              self.edge_attr[(i,j)][&#39;flow&#39;]
            else:
                capacity_ij = self.edge_attr[(j,i)][&#39;flow&#39;]
            if min_capacity &gt; capacity_ij:
                min_capacity = capacity_ij
            index += 1
        return min_capacity

    def simplex_find_cycle(self):
        &#39;&#39;&#39;
        API:
            simplex_find_cycle(self)
        Description:
            Returns a cycle (list of nodes) if the graph has one, returns None
            otherwise. Uses DFS. During DFS checks existence of arcs to lower
            depth regions. Note that direction of the arcs are not important.
        Return:
            Returns list of nodes that represents cycle. Returns None if the
            graph does not have any cycle.
        &#39;&#39;&#39;
        # make a dfs, if you identify an arc to a lower depth node we have a
        # cycle
        nl = self.get_node_list()
        q = [nl[0]]
        visited = []
        depth = {nl[0]:0}
        pred = {nl[0]:None}
        for n in nl:
            self.get_node(n).set_attr(&#39;component&#39;, None)
        component_nr = int(nl[0])
        self.get_node(nl[0]).set_attr(&#39;component&#39;, component_nr)
        while True:
            while q:
                current = q.pop()
                visited.append(current)
                neighbors = self.in_neighbors[current] +\
                    self.neighbors[current]
                for n in neighbors:
                    if n==pred[current]:
                        continue
                    self.get_node(n).set_attr(&#39;component&#39;, component_nr)
                    if n in depth:
                        # we have a cycle
                        cycle1 = []
                        cycle2 = []
                        temp = n
                        while temp is not None:
                            cycle1.append(temp)
                            temp = pred[temp]
                        temp = current
                        while temp is not None:
                            cycle2.append(temp)
                            temp = pred[temp]
                        cycle1.pop()
                        cycle1.reverse()
                        cycle2.extend(cycle1)
                        return cycle2
                    else:
                        pred[n] = current
                        depth[n] = depth[current] + 1
                    if n not in visited:
                        q.append(n)
            flag = False
            for n in nl:
                if self.get_node(n).get_attr(&#39;component&#39;) is None:
                    q.append(n)
                    depth = {n:0}
                    pred = {n:None}
                    visited = []
                    component_nr = int(n)
                    self.get_node(n).set_attr(&#39;component&#39;, component_nr)
                    flag = True
                    break
            if not flag:
                break
        return None

    def get_simplex_solution_graph(self):
        &#39;&#39;&#39;
        API:
            get_simplex_solution_graph(self):
        Description:
            Assumes a feasible flow solution stored in &#39;flow&#39; attribute&#39;s of
            arcs. Returns the graph with arcs that have flow between 0 and
            capacity.
        Pre:
            (1) &#39;flow&#39; attribute represents a feasible flow solution. See
            Pre section of min_cost_flow() for details.
        Return:
            Graph instance that only has the arcs that have flow strictly
            between 0 and capacity.
        &#39;&#39;&#39;
        simplex_g = Graph(type=DIRECTED_GRAPH)
        for i in self.neighbors:
            simplex_g.add_node(i)
        for e in self.edge_attr:
            flow_e = self.edge_attr[e][&#39;flow&#39;]
            capacity_e = self.edge_attr[e][&#39;capacity&#39;]
            if flow_e&gt;0 and flow_e&lt;capacity_e:
                simplex_g.add_edge(e[0], e[1])
        return simplex_g

    def simplex_compute_potentials(self, t, root):
        &#39;&#39;&#39;
        API:
            simplex_compute_potentials(self, t, root)
        Description:
            Computes node potentials for a minimum cost flow problem and stores
            them as node attribute &#39;potential&#39;. Based on pseudocode given in
            Network Flows by Ahuja et al.
        Pre:
            (1) Assumes a directed graph in which each arc has a &#39;cost&#39;
            attribute.
            (2) Uses &#39;thread&#39; and &#39;pred&#39; attributes of nodes.
        Input:
            t: Current spanning tree solution, its type is Graph.
            root: root node of the tree.
        Post:
            Keeps the node potentials as &#39;potential&#39; attribute.
        &#39;&#39;&#39;
        self.get_node(root).set_attr(&#39;potential&#39;, 0)
        j = t.get_node(root).get_attr(&#39;thread&#39;)
        while j is not root:
            i = t.get_node(j).get_attr(&#39;pred&#39;)
            potential_i = self.get_node(i).get_attr(&#39;potential&#39;)
            if (i,j) in self.edge_attr:
                c_ij = self.edge_attr[(i,j)][&#39;cost&#39;]
                self.get_node(j).set_attr(&#39;potential&#39;, potential_i-c_ij)
            if (j,i) in self.edge_attr:
                c_ji = self.edge_attr[(j,i)][&#39;cost&#39;]
                self.get_node(j).set_attr(&#39;potential&#39;, potential_i+c_ji)
            j = t.get_node(j).get_attr(&#39;thread&#39;)

    def simplex_identify_cycle(self, t, k, l):
        &#39;&#39;&#39;
        API:
            identify_cycle(self, t, k, l)
        Description:
            Identifies and returns to the pivot cycle, which is a list of
            nodes.
        Pre:
            (1) t is spanning tree solution, (k,l) is the entering arc.
        Input:
            t: current spanning tree solution
            k: tail of the entering arc
            l: head of the entering arc
        Returns:
            List of nodes in the cycle.
        &#39;&#39;&#39;
        i = k
        j = l
        cycle = []
        li = [k]
        lj = [j]
        while i is not j:
            depth_i = t.get_node(i).get_attr(&#39;depth&#39;)
            depth_j = t.get_node(j).get_attr(&#39;depth&#39;)
            if depth_i &gt; depth_j:
                i = t.get_node(i).get_attr(&#39;pred&#39;)
                li.append(i)
            elif depth_i &lt; depth_j:
                j = t.get_node(j).get_attr(&#39;pred&#39;)
                lj.append(j)
            else:
                i = t.get_node(i).get_attr(&#39;pred&#39;)
                li.append(i)
                j = t.get_node(j).get_attr(&#39;pred&#39;)
                lj.append(j)
        cycle.extend(lj)
        li.pop()
        li.reverse()
        cycle.extend(li)
        # l is beginning k is end
        return cycle

    def min_cost_flow(self, display = None, **args):
        &#39;&#39;&#39;
        API:
            min_cost_flow(self, display=&#39;off&#39;, **args)
        Description:
            Solves minimum cost flow problem using node/edge attributes with
            the algorithm specified.
        Pre:
            (1) Assumes a directed graph in which each arc has &#39;capacity&#39; and
            &#39;cost&#39; attributes.
            (2) Nodes should have &#39;demand&#39; attribute. This value should be
            positive for supply and negative for demand, and 0 for transhipment
            nodes.
            (3) The graph should be connected.
            (4) Assumes (i,j) and (j,i) does not exist together. Needed when
            solving max flow. (max flow problem is solved to get a feasible
            flow).
        Input:
            display: &#39;off&#39; for no display, &#39;matplotlib&#39; for live update of tree
            args: may have the following
                display: display method, if not given current mode (the one
                    specified by __init__ or set_display) will be used.
                algo: determines algorithm to use, can be one of the following
                    &#39;simplex&#39;: network simplex algorithm
                    &#39;cycle_canceling&#39;: cycle canceling algorithm
                    &#39;simplex&#39; is used if not given.
                    see Network Flows by Ahuja et al. for details of algorithms.
                pivot: valid if algo is &#39;simlex&#39;, determines pivoting rule for
                    simplex, may be one of the following; &#39;first_eligible&#39;,
                    &#39;dantzig&#39; or &#39;scaled&#39;.
                    &#39;dantzig&#39; is used if not given.
                    see Network Flows by Ahuja et al. for pivot rules.
                root: valid if algo is &#39;simlex&#39;, specifies the root node for
                    simplex algorithm. It is name of the one of the nodes. It
                    will be chosen randomly if not provided.
        Post:
            The &#39;flow&#39; attribute of each arc gives the optimal flows.
            &#39;distance&#39; attribute of the nodes are also changed during max flow
            solution process.
        Examples:
            g.min_cost_flow():
                solves minimum cost feasible flow problem using simplex
                algorithm with dantzig pivoting rule.
                See pre section for details.
            g.min_cost_flow(algo=&#39;cycle_canceling&#39;):
                solves minimum cost feasible flow problem using cycle canceling
                agorithm.
            g.min_cost_flow(algo=&#39;simplex&#39;, pivot=&#39;scaled&#39;):
                solves minimum cost feasible flow problem using network simplex
                agorithm with scaled pivot rule.
        &#39;&#39;&#39;
        if display is None:
            display = self.attr[&#39;display&#39;]
        if &#39;algo&#39; in args:
            algorithm = args[&#39;algo&#39;]
        else:
            algorithm = &#39;simplex&#39;
        if algorithm == &#39;simplex&#39;:
            if &#39;root&#39; in args:
                root = args[&#39;root&#39;]
            else:
                for k in self.neighbors:
                    root = k
                    break
            if &#39;pivot&#39; in args:
                if not self.network_simplex(display, args[&#39;pivot&#39;], root):
                    print(&#39;problem is infeasible&#39;)
            else:
                if not self.network_simplex(display, &#39;dantzig&#39;, root):
                    print(&#39;problem is infeasible&#39;)
        elif algorithm == &#39;cycle_canceling&#39;:
            if not self.cycle_canceling(display):
                print(&#39;problem is infeasible&#39;)
        else:
            print(args[&#39;algo&#39;], &#39;is not a defined algorithm. Exiting.&#39;)
            return

    def random(self, numnodes = 10, degree_range = (2, 4), length_range = (1, 10),
               density = None, edge_format = None, node_format = None,
               Euclidean = False, seedInput = 0, add_labels = True,
               parallel_allowed = False, node_selection = &#39;closest&#39;,
               scale = 10, scale_cost = 5):
        &#39;&#39;&#39;
        API:
            random(self, numnodes = 10, degree_range = None, length_range = None,
               density = None, edge_format = None, node_format = None,
               Euclidean = False, seedInput = 0)
        Description:
            Populates graph with random edges and nodes.
        Input:
            numnodes: Number of nodes to add.
            degree_range: A tuple that has lower and upper bounds of degree for
            a node.
            length_range: A tuple that has lower and upper bounds for &#39;cost&#39;
            attribute of edges.
            density: Density of edges, ie. 0.5 indicates a node will
            approximately have edge to half of the other nodes.
            edge_format: Dictionary that specifies attribute values for edges.
            node_format: Dictionary that specifies attribute values for nodes.
            Euclidean: Creates an Euclidean graph (Euclidean distance between
            nodes) if True.
            seedInput: Seed that will be used for random number generation.
        Pre:
            It is recommended to call this method on empty Graph objects.
        Post:
            Graph will be populated by nodes and edges.
        &#39;&#39;&#39;
        random.seed(seedInput)
        if edge_format == None:
            edge_format = {&#39;fontsize&#39;:10,
                           &#39;fontcolor&#39;:&#39;blue&#39;}
        if node_format == None:
            node_format = {&#39;height&#39;:0.5,
                           &#39;width&#39;:0.5,
                           &#39;fixedsize&#39;:&#39;true&#39;,
                           &#39;fontsize&#39;:10,
                           &#39;fontcolor&#39;:&#39;red&#39;,
                           &#39;shape&#39;:&#39;circle&#39;,
                           }
        if Euclidean == False:
            for m in range(numnodes):
                self.add_node(m, **node_format)
            if degree_range is not None and density is None:
                for m in range(numnodes):
                    degree = random.randint(degree_range[0], degree_range[1])
                    i = 0
                    while i &lt; degree:
                        n = random.randint(1, numnodes-1)
                        if (((m,n) not in self.edge_attr and m != n) and
                            (parallel_allowed or (n, m) not in self.edge_attr)):
                            if length_range is not None:
                                length = random.randint(length_range[0],
                                                        length_range[1])
                                self.add_edge(m, n, cost = length, **edge_format)
                                if add_labels:
                                    self.set_edge_attr(m, n, &#39;label&#39;, str(length))
                                else:
                                    self.add_edge(m, n, **edge_format)
                        i += 1
            elif density != None:
                for m in range(numnodes):
                    if self.graph_type == DIRECTED_GRAPH:
                        numnodes2 = numnodes
                    else:
                        numnodes2 = m
                    for n in range(numnodes2):
                        if ((parallel_allowed or (n, m) not in self.edge_attr)
                            and m != n):
                            if random.random() &lt; density:
                                if length_range is not None:
                                    length = random.randint(length_range[0],
                                                     length_range[1])
                                    self.add_edge(m, n, cost = length,
                                                  **edge_format)
                                    if add_labels:
                                        self.set_edge_attr(m, n, &#39;label&#39;, str(length))
                                else:
                                    self.add_edge(m, n, **edge_format)
            else:
                print(&#34;Must set either degree range or density&#34;)
        else:
            for m in range(numnodes):
                &#39;&#39;&#39; Assigns random coordinates (between 1 and 20) to the nodes
                &#39;&#39;&#39;
                x = random.random()*scale
                y = random.random()*scale
                self.add_node(m, locationx = x, locationy = y,
                              pos = &#39;&#34;&#39;+str(x) + &#34;,&#34; + str(y)+&#39;!&#34;&#39;,
                              **node_format)
            if degree_range is not None and density is None:
                for m in range(numnodes):
                    degree = random.randint(degree_range[0], degree_range[1])
                    i = 0
                    neighbors = []
                    if node_selection == &#39;random&#39;:
                        while i &lt; degree:
                            length = round((((self.get_node(n).get_attr(&#39;locationx&#39;) -
                                              self.get_node(m).get_attr(&#39;locationx&#39;)) ** 2 +
                                             (self.get_node(n).get_attr(&#39;locationy&#39;) -
                                              self.get_node(m).get_attr(&#39;locationy&#39;)) ** 2) ** 0.5)*scale_cost,
                                           0)
                            if (((m,n) not in self.edge_attr and m != n) and
                                (parallel_allowed or (n, m) not in self.edge_attr)):
                                neighbors.append(random.randint(0, numnodes-1))
                                self.add_edge(m, n, cost = int(length), **edge_format)
                                if add_labels:
                                    self.set_edge_attr(m, n, &#39;label&#39;, str(int(length)))
                                i += 1
                    elif node_selection == &#39;closest&#39;:
                        lengths = []
                        for n in range(numnodes):
                            lengths.append((n, round((((self.get_node(n).get_attr(&#39;locationx&#39;) -
                                                        self.get_node(m).get_attr(&#39;locationx&#39;)) ** 2 +
                                                       (self.get_node(n).get_attr(&#39;locationy&#39;) -
                                                        self.get_node(m).get_attr(&#39;locationy&#39;)) ** 2) ** 0.5)*scale_cost,
                                                     0)))
                        lengths.sort(key = lambda l : l[1])
                        for i in range(degree+1):
                            if not (lengths[i][0] == m or self.check_edge(m, lengths[i][0])):
                                self.add_edge(m, lengths[i][0], cost = int(lengths[i][1]), **edge_format)
                                if add_labels:
                                    self.set_edge_attr(m, lengths[i][0], &#39;label&#39;, str(int(lengths[i][1])))
                    else:
                        print(&#34;Unknown node selection rule...exiting&#34;)
                        return
            elif density != None:
                for m in range(numnodes):
                    if self.graph_type == DIRECTED_GRAPH:
                        numnodes2 = numnodes
                    else:
                        numnodes2 = m
                    for n in range(numnodes2):
                        if ((parallel_allowed or (n, m) not in self.edge_attr)
                            and m != n):
                            if random.random() &lt; density:
                                if length_range is None:
                                    &#39;&#39;&#39; calculates the euclidean norm and round it
                                    to an integer &#39;&#39;&#39;
                                    length = round((((self.get_node(n).get_attr(&#39;locationx&#39;) -
                                                      self.get_node(m).get_attr(&#39;locationx&#39;)) ** 2 +
                                                     (self.get_node(n).get_attr(&#39;locationy&#39;) -
                                                      self.get_node(m).get_attr(&#39;locationy&#39;)) ** 2) ** 0.5), 0)
                                    self.add_edge(m, n, cost = int(length), **edge_format)
                                    if add_labels:
                                        self.set_edge_attr(m, n, &#39;label&#39;, str(int(length)))
                                else:
                                    self.add_edge(m, n, **edge_format)
            else:
                print(&#34;Must set either degree range or density&#34;)

    def page_rank(self, damping_factor=0.85, max_iterations=100,
                  min_delta=0.00001):
        &#39;&#39;&#39;
        API:
            page_rank(self, damping_factor=0.85, max_iterations=100,
                  min_delta=0.00001)
        Description:
            Compute and return the page-rank of a directed graph.
            This function was originally taken from here and modified for this
            graph class: http://code.google.com/p/python-graph/source/browse/
            trunk/core/pygraph/algorithms/pagerank.py
        Input:
            damping_factor: Damping factor.
            max_iterations: Maximum number of iterations.
            min_delta: Smallest variation required to have a new iteration.
        Pre:
            Graph should be a directed graph.
        Return:
            Returns dictionary of page-ranks. Keys are node names, values are
            corresponding page-ranks.
        &#39;&#39;&#39;
        nodes = self.get_node_list()
        graph_size = len(nodes)
        if graph_size == 0:
            return {}
        #value for nodes without inbound links
        min_value = old_div((1.0-damping_factor),graph_size)
        # itialize the page rank dict with 1/N for all nodes
        pagerank = dict.fromkeys(nodes, old_div(1.0,graph_size))
        for _ in range(max_iterations):
            diff = 0 #total difference compared to last iteraction
            # computes each node PageRank based on inbound links
            for node in nodes:
                rank = min_value
                for referring_page in self.get_in_neighbors(node):
                    rank += (damping_factor * pagerank[referring_page] /
                             len(self.get_neighbors(referring_page)))
                diff += abs(pagerank[node] - rank)
                pagerank[node] = rank
            #stop if PageRank has converged
            if diff &lt; min_delta:
                break
        return pagerank

    def get_degrees(self):
        &#39;&#39;&#39;
        API:
            get_degree(self)
        Description:
            Returns degrees of nodes in dictionary format.
        Return:
            Returns a dictionary of node degrees. Keys are node names, values
            are corresponding degrees.
        &#39;&#39;&#39;
        degree = {}
        if self.attr[&#39;type&#39;] is not DIRECTED_GRAPH:
            for n in self.get_node_list():
                degree[n] = len(self.get_neighbors(n))
            return degree
        else:
            for n in self.get_node_list():
                degree[n] = (len(self.get_in_neighbors(n)) +
                             len(self.get_out_neighbors(n)))

    def get_in_degrees(self):
        &#39;&#39;&#39;
        API:
            get_degree(self)
        Description:
            Returns degrees of nodes in dictionary format.
        Return:
            Returns a dictionary of node degrees. Keys are node names, values
            are corresponding degrees.
        &#39;&#39;&#39;
        degree = {}
        if self.attr[&#39;type&#39;] is not DIRECTED_GRAPH:
            print(&#39;This function only works for directed graphs&#39;)
            return
        for n in self.get_node_list():
            degree[n] = len(self.get_in_neighbors(n))
        return degree

    def get_out_degrees(self):
        &#39;&#39;&#39;
        API:
            get_degree(self)
        Description:
            Returns degrees of nodes in dictionary format.
        Return:
            Returns a dictionary of node degrees. Keys are node names, values
            are corresponding degrees.
        &#39;&#39;&#39;
        degree = {}
        if self.attr[&#39;type&#39;] is not DIRECTED_GRAPH:
            print(&#39;This function only works for directed graphs&#39;)
            return
        for n in self.get_node_list():
            degree[n] = len(self.get_out_neighbors(n))
        return degree

    def get_diameter(self):
        &#39;&#39;&#39;
        API:
            get_diameter(self)
        Description:
            Returns diameter of the graph. Diameter is defined as follows.
            distance(n,m): shortest unweighted path from n to m
            eccentricity(n) = $\max _m distance(n,m)$
            diameter = $\min _n eccentricity(n) = \min _n \max _m distance(n,m)$
        Return:
            Returns diameter of the graph.
        &#39;&#39;&#39;

        if self.attr[&#39;type&#39;] is not UNDIRECTED_GRAPH:
            print(&#39;This function only works for undirected graphs&#39;)
            return
        diameter = &#39;infinity&#39;
        eccentricity_n = 0
        for n in self.get_node_list():
            for m in self.get_node_list():
                path_n_m = self.search(n, destination = m, algo = &#39;BFS&#39;)
                if path_n_m is None:
                    # this indicates there is no path from n to m, no diameter
                    # is defined, since the graph is not connected, return
                    # &#39;infinity&#39;
                    return &#39;infinity&#39;
                distance_n_m = len(path_n_m)-1
                if distance_n_m &gt; eccentricity_n:
                    eccentricity_n = distance_n_m
            if diameter == &#39;infinity&#39; or eccentricity_n &gt; diameter:
                diameter = eccentricity_n
        return diameter

    def create_cluster(self, node_list, cluster_attrs={}, node_attrs={}):
        &#39;&#39;&#39;
        API:
            create_cluster(self, node_list, cluster_attrs, node_attrs)
        Description:
            Creates a cluster from the node given in the node list.
        Input:
            node_list: List of nodes in the cluster.
            cluster_attrs: Dictionary of cluster attributes, see Dot language
            grammer documentation for details.
            node_attrs: Dictionary of node attributes. It will overwrite
            previous attributes of the nodes in the cluster.
        Post:
            A cluster will be created. Attributes of the nodes in the cluster
            may change.
        &#39;&#39;&#39;
        if &#39;name&#39; in cluster_attrs:
            if &#39;name&#39; in self.cluster:
                raise Exception(&#39;A cluster with name %s already exists!&#39; %cluster_attrs[&#39;name&#39;])
            else:
                name = cluster_attrs[&#39;name&#39;]
        else:
            name = &#39;c%d&#39; %self.attr[&#39;cluster_count&#39;]
            self.attr[&#39;cluster_count&#39;] += 1
            cluster_attrs[&#39;name&#39;] = name
        #cluster_attrs[&#39;name&#39;] =
        self.cluster[name] = {&#39;node_list&#39;:node_list,
                              &#39;attrs&#39;:copy.deepcopy(cluster_attrs),
                              &#39;node_attrs&#39;:copy.deepcopy(node_attrs)}</code></pre>
</details>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="coinor.gimpy.examples.simplex_test.mGraph" href="examples/simplex_test.html#coinor.gimpy.examples.simplex_test.mGraph">mGraph</a></li>
<li><a title="coinor.gimpy.graph.DisjointSet" href="#coinor.gimpy.graph.DisjointSet">DisjointSet</a></li>
<li><a title="coinor.gimpy.tree.Tree" href="tree.html#coinor.gimpy.tree.Tree">Tree</a></li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="coinor.gimpy.graph.Graph.add_edge"><code class="name flex">
<span>def <span class="ident">add_edge</span></span>(<span>self, name1, name2, **attr)</span>
</code></dt>
<dd>
<div class="desc"><p>API: add_edge(self, name1, name2, **attr)
Description:
Adds edge to the graph. Sets edge attributes using attr argument.</p>
<h2 id="input">Input</h2>
<p>name1: Name of the source node (if directed).
name2: Name of the sink node (if directed).
attr: Edge attributes.</p>
<h2 id="pre">Pre</h2>
<p>Graph should not already contain this edge. We do not allow
multiple edges with same source and sink nodes.</p>
<h2 id="post">Post</h2>
<p>self.edge_attr is updated.
self.neighbors, self.nodes and self.in_neighbors are updated if
graph was missing at least one of the nodes.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def add_edge(self, name1, name2, **attr):
    &#39;&#39;&#39;
    API: add_edge(self, name1, name2, **attr)
    Description:
    Adds edge to the graph. Sets edge attributes using attr argument.
    Input:
        name1: Name of the source node (if directed).
        name2: Name of the sink node (if directed).
        attr: Edge attributes.
    Pre:
        Graph should not already contain this edge. We do not allow
        multiple edges with same source and sink nodes.
    Post:
        self.edge_attr is updated.
        self.neighbors, self.nodes and self.in_neighbors are updated if
        graph was missing at least one of the nodes.
    &#39;&#39;&#39;
    if (name1, name2) in self.edge_attr:
        raise MultipleEdgeException
    if self.graph_type is UNDIRECTED_GRAPH and (name2,name1) in self.edge_attr:
        raise MultipleEdgeException
    self.edge_attr[(name1,name2)] = copy.deepcopy(DEFAULT_EDGE_ATTRIBUTES)
    for a in attr:
        self.edge_attr[(name1,name2)][a] = attr[a]
    if name1 not in self.nodes:
        self.add_node(name1)
    if name2 not in self.nodes:
        self.add_node(name2)
    self.neighbors[name1].append(name2)
    if self.graph_type is UNDIRECTED_GRAPH:
        self.neighbors[name2].append(name1)
    else:
        self.in_neighbors[name2].append(name1)</code></pre>
</details>
</dd>
<dt id="coinor.gimpy.graph.Graph.add_node"><code class="name flex">
<span>def <span class="ident">add_node</span></span>(<span>self, name, **attr)</span>
</code></dt>
<dd>
<div class="desc"><p>API: add_node(self, name, **attr)
Description:
Adds node to the graph.</p>
<h2 id="pre">Pre</h2>
<p>Graph should not contain a node with this name. We do not allow
multiple nodes with the same name.</p>
<h2 id="input">Input</h2>
<p>name: Name of the node.
attr: Node attributes.</p>
<h2 id="post">Post</h2>
<p>self.neighbors, self.nodes and self.in_neighbors are updated.</p>
<h2 id="return">Return</h2>
<p>Node (a Node class instance) added to the graph.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def add_node(self, name, **attr):
    &#39;&#39;&#39;
    API: add_node(self, name, **attr)
    Description:
    Adds node to the graph.
    Pre:
        Graph should not contain a node with this name. We do not allow
        multiple nodes with the same name.
    Input:
        name: Name of the node.
        attr: Node attributes.
    Post:
        self.neighbors, self.nodes and self.in_neighbors are updated.
    Return:
        Node (a Node class instance) added to the graph.
    &#39;&#39;&#39;
    if name in self.neighbors:
        raise MultipleNodeException
    self.neighbors[name] = list()
    if self.graph_type is DIRECTED_GRAPH:
        self.in_neighbors[name] = list()
    self.nodes[name] = Node(name, **attr)
    return self.nodes[name]</code></pre>
</details>
</dd>
<dt id="coinor.gimpy.graph.Graph.augment_cycle"><code class="name flex">
<span>def <span class="ident">augment_cycle</span></span>(<span>self, amount, cycle)</span>
</code></dt>
<dd>
<div class="desc"><h2 id="api">Api</h2>
<p>augment_cycle(self, amount, cycle):</p>
<h2 id="description">Description</h2>
<p>Augments 'amount' unit of flow along cycle.</p>
<h2 id="pre">Pre</h2>
<p>Arcs should have 'flow' attribute.</p>
<h2 id="inputs">Inputs</h2>
<p>amount: An integer representing the amount to augment
cycle: A list representing a cycle</p>
<h2 id="post">Post</h2>
<p>Changes 'flow' attributes of arcs.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def augment_cycle(self, amount, cycle):
    &#39;&#39;&#39;
    API:
        augment_cycle(self, amount, cycle):
    Description:
        Augments &#39;amount&#39; unit of flow along cycle.
    Pre:
        Arcs should have &#39;flow&#39; attribute.
    Inputs:
        amount: An integer representing the amount to augment
        cycle: A list representing a cycle
    Post:
        Changes &#39;flow&#39; attributes of arcs.
    &#39;&#39;&#39;
    index = 0
    k = len(cycle)
    while index&lt;(k-1):
        i = cycle[index]
        j = cycle[index+1]
        if (i,j) in self.edge_attr:
            flow_ij = self.edge_attr[(i,j)][&#39;flow&#39;]
            self.edge_attr[(i,j)][&#39;flow&#39;] = flow_ij+amount
        else:
            flow_ji = self.edge_attr[(j,i)][&#39;flow&#39;]
            self.edge_attr[(j,i)][&#39;flow&#39;] = flow_ji-amount
        index += 1
    i = cycle[k-1]
    j = cycle[0]
    if (i,j) in self.edge_attr:
        flow_ij = self.edge_attr[(i,j)][&#39;flow&#39;]
        self.edge_attr[(i,j)][&#39;flow&#39;] = flow_ij+amount
    else:
        flow_ji = self.edge_attr[(j,i)][&#39;flow&#39;]
        self.edge_attr[(j,i)][&#39;flow&#39;] = flow_ji-amount</code></pre>
</details>
</dd>
<dt id="coinor.gimpy.graph.Graph.bfs"><code class="name flex">
<span>def <span class="ident">bfs</span></span>(<span>self, root, display=None, component=None)</span>
</code></dt>
<dd>
<div class="desc"><p>API: bfs(self, root, display = None, component=None)
Description:
Make a breadth-first search starting from node with name root.</p>
<h2 id="input">Input</h2>
<p>root: Starting node name.
display: display method.
component: component number.</p>
<h2 id="post">Post</h2>
<p>Nodes will have 'component' attribute that will have component
number as value.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def bfs(self, root, display = None, component = None):
    &#39;&#39;&#39;
    API: bfs(self, root, display = None, component=None)
    Description:
    Make a breadth-first search starting from node with name root.
    Input:
        root: Starting node name.
        display: display method.
        component: component number.
    Post:
        Nodes will have &#39;component&#39; attribute that will have component
        number as value.
    &#39;&#39;&#39;
    self.search(root, display = display, component = component, q = Queue())</code></pre>
</details>
</dd>
<dt id="coinor.gimpy.graph.Graph.check_edge"><code class="name flex">
<span>def <span class="ident">check_edge</span></span>(<span>self, name1, name2)</span>
</code></dt>
<dd>
<div class="desc"><p>API: check_edge(self, name1, name2)
Description:
Return True if edge exists, False otherwise.</p>
<h2 id="input">Input</h2>
<p>name1: name of the source node.
name2: name of the sink node.</p>
<h2 id="return">Return</h2>
<p>Returns True if edge exists, False otherwise.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def check_edge(self, name1, name2):
    &#39;&#39;&#39;
    API: check_edge(self, name1, name2)
    Description:
    Return True if edge exists, False otherwise.
    Input:
        name1: name of the source node.
        name2: name of the sink node.
    Return:
        Returns True if edge exists, False otherwise.
    &#39;&#39;&#39;
    if self.graph_type is DIRECTED_GRAPH:
        return (name1, name2) in self.edge_attr
    else:
        return ((name1, name2) in self.edge_attr or
                (name2, name1) in self.edge_attr)</code></pre>
</details>
</dd>
<dt id="coinor.gimpy.graph.Graph.create"><code class="name flex">
<span>def <span class="ident">create</span></span>(<span>self, layout, format, **args)</span>
</code></dt>
<dd>
<div class="desc"><h2 id="api">Api</h2>
<p>create(self, layout, format, **args)</p>
<h2 id="description">Description</h2>
<p>Returns postscript representation of graph.</p>
<h2 id="input">Input</h2>
<p>layout: Dot layout for generating graph image.
format: Image format, all format supported by Dot are wellcome.</p>
<h2 id="return">Return</h2>
<p>Returns postscript representation of graph.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">    def create(self, layout, format, **args):
        &#39;&#39;&#39;
        API:
            create(self, layout, format, **args)
        Description:
            Returns postscript representation of graph.
        Input:
            layout: Dot layout for generating graph image.
            format: Image format, all format supported by Dot are wellcome.
        Return:
            Returns postscript representation of graph.
        &#39;&#39;&#39;
        tmp_fd, tmp_name = tempfile.mkstemp()
        tmp_file = os.fdopen(tmp_fd, &#39;w&#39;)
        tmp_file.write(self.to_string())
        tmp_file.close()
        try:
            p = subprocess.run([layout, &#39;-T&#39;+format, tmp_name],
                               capture_output = True)
        except OSError:
            print(&#39;&#39;&#39;Graphviz executable not found.
Graphviz must be installed and in your search path.
Please visit http://www.graphviz.org/ for information on installation.
After installation, ensure that the PATH variable is properly set.&#39;&#39;&#39;)
            return None

        
        p.check_returncode()

        os.remove(tmp_name)
            
        if p.stderr:
            print(p.stderr)
        return p.stdout</code></pre>
</details>
</dd>
<dt id="coinor.gimpy.graph.Graph.create_cluster"><code class="name flex">
<span>def <span class="ident">create_cluster</span></span>(<span>self, node_list, cluster_attrs={}, node_attrs={})</span>
</code></dt>
<dd>
<div class="desc"><h2 id="api">Api</h2>
<p>create_cluster(self, node_list, cluster_attrs, node_attrs)</p>
<h2 id="description">Description</h2>
<p>Creates a cluster from the node given in the node list.</p>
<h2 id="input">Input</h2>
<p>node_list: List of nodes in the cluster.
cluster_attrs: Dictionary of cluster attributes, see Dot language
grammer documentation for details.
node_attrs: Dictionary of node attributes. It will overwrite
previous attributes of the nodes in the cluster.</p>
<h2 id="post">Post</h2>
<p>A cluster will be created. Attributes of the nodes in the cluster
may change.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def create_cluster(self, node_list, cluster_attrs={}, node_attrs={}):
    &#39;&#39;&#39;
    API:
        create_cluster(self, node_list, cluster_attrs, node_attrs)
    Description:
        Creates a cluster from the node given in the node list.
    Input:
        node_list: List of nodes in the cluster.
        cluster_attrs: Dictionary of cluster attributes, see Dot language
        grammer documentation for details.
        node_attrs: Dictionary of node attributes. It will overwrite
        previous attributes of the nodes in the cluster.
    Post:
        A cluster will be created. Attributes of the nodes in the cluster
        may change.
    &#39;&#39;&#39;
    if &#39;name&#39; in cluster_attrs:
        if &#39;name&#39; in self.cluster:
            raise Exception(&#39;A cluster with name %s already exists!&#39; %cluster_attrs[&#39;name&#39;])
        else:
            name = cluster_attrs[&#39;name&#39;]
    else:
        name = &#39;c%d&#39; %self.attr[&#39;cluster_count&#39;]
        self.attr[&#39;cluster_count&#39;] += 1
        cluster_attrs[&#39;name&#39;] = name
    #cluster_attrs[&#39;name&#39;] =
    self.cluster[name] = {&#39;node_list&#39;:node_list,
                          &#39;attrs&#39;:copy.deepcopy(cluster_attrs),
                          &#39;node_attrs&#39;:copy.deepcopy(node_attrs)}</code></pre>
</details>
</dd>
<dt id="coinor.gimpy.graph.Graph.create_residual_graph"><code class="name flex">
<span>def <span class="ident">create_residual_graph</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>API: create_residual_graph(self)
Description:
Creates and returns residual graph, which is a Graph instance
itself.</p>
<h2 id="pre">Pre</h2>
<p>(1) Arcs should have 'flow', 'capacity' and 'cost' attribute
(2) Graph should be a directed graph</p>
<h2 id="return">Return</h2>
<p>Returns residual graph, which is a Graph instance.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def create_residual_graph(self):
    &#39;&#39;&#39;
    API: create_residual_graph(self)
    Description:
    Creates and returns residual graph, which is a Graph instance
    itself.
    Pre:
        (1) Arcs should have &#39;flow&#39;, &#39;capacity&#39; and &#39;cost&#39; attribute
        (2) Graph should be a directed graph
    Return:
        Returns residual graph, which is a Graph instance.
    &#39;&#39;&#39;
    if self.graph_type is UNDIRECTED_GRAPH:
        raise Exception(&#39;residual graph is defined for directed graphs.&#39;)
    residual_g = Graph(type = DIRECTED_GRAPH)
    for e in self.get_edge_list():
        capacity_e = self.get_edge_attr(e[0], e[1], &#39;capacity&#39;)
        flow_e = self.get_edge_attr(e[0], e[1], &#39;flow&#39;)
        cost_e = self.get_edge_attr(e[0], e[1], &#39;cost&#39;)
        if flow_e &gt; 0:
            residual_g.add_edge(e[1], e[0], cost=-1*cost_e,
                                capacity=flow_e)
        if capacity_e - flow_e &gt; 0:
            residual_g.add_edge(e[0], e[1], cost=cost_e,
                                capacity=capacity_e-flow_e)
    return residual_g</code></pre>
</details>
</dd>
<dt id="coinor.gimpy.graph.Graph.cycle_canceling"><code class="name flex">
<span>def <span class="ident">cycle_canceling</span></span>(<span>self, display)</span>
</code></dt>
<dd>
<div class="desc"><h2 id="api">Api</h2>
<p>cycle_canceling(self, display)</p>
<h2 id="description">Description</h2>
<p>Solves minimum cost feasible flow problem using cycle canceling
algorithm. Returns True when an optimal solution is found, returns
False otherwise. 'flow' attribute values of arcs should be
considered as junk when returned False.</p>
<h2 id="input">Input</h2>
<p>display: Display method.</p>
<h2 id="pre">Pre</h2>
<p>(1) Arcs should have 'capacity' and 'cost' attribute.
(2) Nodes should have 'demand' attribute, this value should be
positive if the node is a supply node, negative if it is demand
node and 0 if it is transhipment node.
(3) graph should not have node 's' and 't'.</p>
<h2 id="post">Post</h2>
<p>Changes 'flow' attributes of arcs.</p>
<h2 id="return">Return</h2>
<p>Returns True when an optimal solution is found, returns False
otherwise.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def cycle_canceling(self, display):
    &#39;&#39;&#39;
    API:
        cycle_canceling(self, display)
    Description:
        Solves minimum cost feasible flow problem using cycle canceling
        algorithm. Returns True when an optimal solution is found, returns
        False otherwise. &#39;flow&#39; attribute values of arcs should be
        considered as junk when returned False.
    Input:
        display: Display method.
    Pre:
        (1) Arcs should have &#39;capacity&#39; and &#39;cost&#39; attribute.
        (2) Nodes should have &#39;demand&#39; attribute, this value should be
        positive if the node is a supply node, negative if it is demand
        node and 0 if it is transhipment node.
        (3) graph should not have node &#39;s&#39; and &#39;t&#39;.
    Post:
        Changes &#39;flow&#39; attributes of arcs.
    Return:
        Returns True when an optimal solution is found, returns False
        otherwise.
    &#39;&#39;&#39;
    # find a feasible solution to flow problem
    if not self.find_feasible_flow():
        return False
    # create residual graph
    residual_g = self.create_residual_graph()
    # identify a negative cycle in residual graph
    ncycle = residual_g.get_negative_cycle()
    # loop while residual graph has a negative cycle
    while ncycle is not None:
        # find capacity of cycle
        cap = residual_g.find_cycle_capacity(ncycle)
        # augment capacity amount along the cycle
        self.augment_cycle(cap, ncycle)
        # create residual graph
        residual_g = self.create_residual_graph()
        # identify next negative cycle
        ncycle = residual_g.get_negative_cycle()
    return True</code></pre>
</details>
</dd>
<dt id="coinor.gimpy.graph.Graph.del_edge"><code class="name flex">
<span>def <span class="ident">del_edge</span></span>(<span>self, e)</span>
</code></dt>
<dd>
<div class="desc"><p>API: del_edge(self, e)
Description:
Removes edge from graph.</p>
<h2 id="input">Input</h2>
<p>e: Tuple that represents edge, in (source,sink) form.</p>
<h2 id="pre">Pre</h2>
<p>Graph should contain this edge.</p>
<h2 id="post">Post</h2>
<p>self.edge_attr, self.neighbors and self.in_neighbors are updated.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def del_edge(self, e):
    &#39;&#39;&#39;
    API: del_edge(self, e)
    Description:
    Removes edge from graph.
    Input:
        e: Tuple that represents edge, in (source,sink) form.
    Pre:
        Graph should contain this edge.
    Post:
        self.edge_attr, self.neighbors and self.in_neighbors are updated.
    &#39;&#39;&#39;
    if self.graph_type is DIRECTED_GRAPH:
        try:
            del self.edge_attr[e]
        except KeyError:
            raise Exception(&#39;Edge %s does not exists!&#39; %str(e))
        self.neighbors[e[0]].remove(e[1])
        self.in_neighbors[e[1]].remove(e[0])
    else:
        try:
            del self.edge_attr[e]
        except KeyError:
            try:
                del self.edge_attr[(e[1],e[0])]
            except KeyError:
                raise Exception(&#39;Edge %s does not exists!&#39; %str(e))
        self.neighbors[e[0]].remove(e[1])
        self.neighbors[e[1]].remove(e[0])</code></pre>
</details>
</dd>
<dt id="coinor.gimpy.graph.Graph.del_node"><code class="name flex">
<span>def <span class="ident">del_node</span></span>(<span>self, name)</span>
</code></dt>
<dd>
<div class="desc"><p>API: del_node(self, name)
Description:
Removes node from Graph.</p>
<h2 id="input">Input</h2>
<p>name: Name of the node.</p>
<h2 id="pre">Pre</h2>
<p>Graph should contain a node with this name.</p>
<h2 id="post">Post</h2>
<p>self.neighbors, self.nodes and self.in_neighbors are updated.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def del_node(self, name):
    &#39;&#39;&#39;
    API: del_node(self, name)
    Description:
    Removes node from Graph.
    Input:
        name: Name of the node.
    Pre:
        Graph should contain a node with this name.
    Post:
        self.neighbors, self.nodes and self.in_neighbors are updated.
    &#39;&#39;&#39;
    if name not in self.neighbors:
        raise Exception(&#39;Node %s does not exist!&#39; %str(name))
    for n in self.neighbors[name]:
        del self.edge_attr[(name, n)]
        if self.graph_type == UNDIRECTED_GRAPH:
            self.neighbors[n].remove(name)
        else:
            self.in_neighbors[n].remove(name)
    if self.graph_type is DIRECTED_GRAPH:
        for n in self.in_neighbors[name]:
            del self.edge_attr[(n, name)]
            self.neighbors[n].remove(name)
    del self.neighbors[name]
    del self.in_neighbors[name]
    del self.nodes[name]</code></pre>
</details>
</dd>
<dt id="coinor.gimpy.graph.Graph.dfs"><code class="name flex">
<span>def <span class="ident">dfs</span></span>(<span>self, root, disc_count=0, finish_count=1, component=None, transpose=False, display=None, pred=None)</span>
</code></dt>
<dd>
<div class="desc"><p>API: dfs(self, root, disc_count = 0, finish_count = 1, component=None,
transpose=False)
Description:
Make a depth-first search starting from node with name root.</p>
<h2 id="input">Input</h2>
<p>root: Starting node name.
disc_count: Discovery time.
finish_count: Finishing time.
component: component number.
transpose: Goes in the reverse direction along edges if transpose
is True.</p>
<h2 id="post">Post</h2>
<p>Nodes will have 'component' attribute that will have component
number as value. Updates 'disc_time' and 'finish_time' attributes
of nodes which represents discovery time and finishing time.</p>
<h2 id="return">Return</h2>
<p>Returns a tuple that has discovery time and finish time of the
last node in the following form (disc_time,finish_time).</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def dfs(self, root, disc_count = 0, finish_count = 1, component = None,
        transpose = False, display = None, pred = None):
    &#39;&#39;&#39;
    API: dfs(self, root, disc_count = 0, finish_count = 1, component=None,
        transpose=False)
    Description:
    Make a depth-first search starting from node with name root.
    Input:
        root: Starting node name.
        disc_count: Discovery time.
        finish_count: Finishing time.
        component: component number.
        transpose: Goes in the reverse direction along edges if transpose
        is True.
    Post:
        Nodes will have &#39;component&#39; attribute that will have component
        number as value. Updates &#39;disc_time&#39; and &#39;finish_time&#39; attributes
        of nodes which represents discovery time and finishing time.
    Return:
        Returns a tuple that has discovery time and finish time of the
        last node in the following form (disc_time,finish_time).
    &#39;&#39;&#39;
    if pred == None:
        pred = {}
    if display == None:
        display = self.attr[&#39;display&#39;]
    else:
        self.set_display_mode(display)
    neighbors = self.neighbors
    if self.graph_type == DIRECTED_GRAPH and transpose:
        neighbors = self.in_neighbors
    self.get_node(root).set_attr(&#39;component&#39;, component)
    disc_count += 1
    self.get_node(root).set_attr(&#39;disc_time&#39;, disc_count)
    self.get_node(root).set_attr(&#39;label&#39;, str(disc_count)+&#39;,-&#39;)
    self.get_node(root).set_attr(&#39;color&#39;, &#39;blue&#39;)
    if root in pred:
        self.set_edge_attr(pred[root], root, &#39;color&#39;, &#39;green&#39;)
    self.display()
    if transpose:
        fTime = []
        for n in neighbors[root]:
            fTime.append((n,self.get_node(n).get_attr(&#39;finish_time&#39;)))
        neighbor_list = sorted(fTime, key=operator.itemgetter(1))
        neighbor_list = list(t[0] for t in neighbor_list)
        neighbor_list.reverse()
    else:
        neighbor_list = neighbors[root]
    for i in neighbor_list:
        if not transpose:
            if self.get_node(i).get_attr(&#39;disc_time&#39;) is None:
                pred[i] = root
                disc_count, finish_count = self.dfs(i, disc_count,
                                                    finish_count,
                                                    component, transpose,
                                                    pred = pred)
        else:
            if self.get_node(i).get_attr(&#39;component&#39;) is None:
                disc_count, finish_count = self.dfs(i, disc_count,
                                                    finish_count,
                                                    component, transpose,
                                                    pred = pred)
    self.get_node(root).set_attr(&#39;finish_time&#39;, finish_count)
    d_time = self.get_node(root).get_attr(&#39;disc_time&#39;)
    label = &#39;&#34;&#39; + str(d_time) + &#39;,&#39; + str(finish_count) + &#39;&#34;&#39;
    self.get_node(root).set_attr(&#39;label&#39;, label)
    self.get_node(root).set_attr(&#39;color&#39;, &#39;green&#39;)
    self.display()
    finish_count += 1
    return disc_count, finish_count</code></pre>
</details>
</dd>
<dt id="coinor.gimpy.graph.Graph.display"><code class="name flex">
<span>def <span class="ident">display</span></span>(<span>self, highlight=None, basename='graph', format='png', pause=False, wait_for_click=True)</span>
</code></dt>
<dd>
<div class="desc"><h2 id="api">Api</h2>
<p>display(self, highlight = None, basename = 'graph', format = 'png',
pause = True)</p>
<h2 id="description">Description</h2>
<p>Displays graph according to the arguments provided.
Current display modes: 'off', 'file', 'PIL', 'matplotlib', 'xdot',
'svg'
Current layout modes: Layouts provided by graphviz ('dot', 'fdp',
'circo', etc.) and 'dot2tex'.
Current formats: Formats provided by graphviz ('ps', 'pdf', 'png',
etc.)</p>
<h2 id="input">Input</h2>
<p>highlight: List of nodes to be highlighted.
basename: File name. It will be used if display mode is 'file'.
format: Image format, all format supported by Dot are wellcome.
pause: If display is 'matplotlib', window will remain open until closed.
wait_for_click: If display is 'matplotlib', setting to True will
wait for a button click before proceeding. This is useful when
animating an algorithm. </p>
<h2 id="post">Post</h2>
<p>A display window will pop up or a file will be written depending
on display mode.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def display(self, highlight = None, basename = &#39;graph&#39;, format = &#39;png&#39;,
            pause = False, wait_for_click = True):
    &#39;&#39;&#39;
    API:
        display(self, highlight = None, basename = &#39;graph&#39;, format = &#39;png&#39;,
            pause = True)
    Description:
        Displays graph according to the arguments provided.
        Current display modes: &#39;off&#39;, &#39;file&#39;, &#39;PIL&#39;, &#39;matplotlib&#39;, &#39;xdot&#39;,
        &#39;svg&#39;
        Current layout modes: Layouts provided by graphviz (&#39;dot&#39;, &#39;fdp&#39;,
        &#39;circo&#39;, etc.) and &#39;dot2tex&#39;.
        Current formats: Formats provided by graphviz (&#39;ps&#39;, &#39;pdf&#39;, &#39;png&#39;,
        etc.)
    Input:
        highlight: List of nodes to be highlighted.
        basename: File name. It will be used if display mode is &#39;file&#39;.
        format: Image format, all format supported by Dot are wellcome.
        pause: If display is &#39;matplotlib&#39;, window will remain open until closed.
        wait_for_click: If display is &#39;matplotlib&#39;, setting to True will 
        wait for a button click before proceeding. This is useful when 
        animating an algorithm. 
    Post:
        A display window will pop up or a file will be written depending
        on display mode.
    &#39;&#39;&#39;
    if self.attr[&#39;display&#39;] == &#39;off&#39;:
        return
    if highlight != None:
        for n in highlight:
            if not isinstance(n, Node):
                n = self.get_node(n)
            n.set_attr(&#39;color&#39;, &#39;red&#39;)
    if self.get_layout() == &#39;dot2tex&#39;:
        if self.attr[&#39;display&#39;] != &#39;file&#39;:
            self.attr[&#39;display&#39;] = &#39;file&#39;
            print(&#34;Warning: Dot2tex layout can only be used with display mode &#39;file&#39;&#34;)
            print(&#34;         Automatically changing setting&#34;)
    if self.attr[&#39;display&#39;] == &#39;file&#39;:
        if self.get_layout() == &#39;dot2tex&#39;:
            try:
                if DOT2TEX_INSTALLED:
                    if format != &#39;pdf&#39; or format != &#39;ps&#39;:
                        print(&#34;Dot2tex only supports pdf and ps formats, falling back to pdf&#34;)
                        format = &#39;pdf&#39;
                    self.set_layout(&#39;dot&#39;)
                    tex = dot2tex.dot2tex(self.to_string(), autosize=True, texmode = &#39;math&#39;, template = DOT2TEX_TEMPLATE)
                else:
                    print(&#34;Error: Dot2tex not installed.&#34;)
            except:
                try:
                    self.set_layout(&#39;dot&#39;)
                    with open(basename+&#39;.dot&#39;, &#34;w+b&#34;) as f:
                        self.write(f, self.get_layout(), &#39;dot&#39;)
                        p = subprocess.call([&#39;dot2tex&#39;, &#39;-t math&#39;,
                                             basename + &#39;.dot&#39;])
                except:
                    print(&#34;There was an error running dot2tex.&#34;)
            with open(basename+&#39;.tex&#39;, &#39;w&#39;) as f:
                f.write(tex)
            try: 
                subprocess.call([&#39;latex&#39;, basename])
                if format == &#39;ps&#39;:
                    subprocess.call([&#39;dvips&#39;, basename])
                elif format == &#39;pdf&#39;:
                    subprocess.call([&#39;pdflatex&#39;, basename])
                self.set_layout(&#39;dot2tex&#39;)
            except:
                print(&#34;There was an error runing latex. Is it installed?&#34;)
        else:
            with open(basename+&#39;.&#39;+format, &#34;w+b&#34;) as f:
                self.write(f, self.get_layout(), format)
        return
    elif self.attr[&#39;display&#39;] == &#39;PIL&#39;:
        if PIL_INSTALLED:
            tmp_fd, tmp_name = tempfile.mkstemp()
            tmp_file = os.fdopen(tmp_fd, &#39;w+b&#39;)
            self.write(tmp_file, self.get_layout(), format)
            tmp_file.close()
            im = PIL_Image.open(tmp_name)
            im.show()
            os.remove(tmp_name)
        else:
            print(&#39;Error: PIL not installed. Display disabled.&#39;)
            self.attr[&#39;display&#39;] = &#39;off&#39;
    elif self.attr[&#39;display&#39;] == &#39;matplotlib&#39;:
        if MATPLOTLIB_INSTALLED and PIL_INSTALLED:
            tmp_fd, tmp_name = tempfile.mkstemp()
            tmp_file = os.fdopen(tmp_fd, &#39;w+b&#39;)
            self.write(tmp_file, self.get_layout(), format)
            tmp_file.close()
            im = PIL_Image.open(tmp_name)
            fig = plt.figure(1)
            fig.canvas.mpl_connect(&#39;close_event&#39;, handle_close)
            plt.clf()
            plt.axis(&#39;off&#39;)
            plt.imshow(im, interpolation=&#39;bilinear&#39; #resample=True
                       #extent = (0, 100, 0, 100)
            )
            if wait_for_click == True:
                plt.draw()
                try:
                    if plt.waitforbuttonpress(timeout = 10000):
                        plt.close()
                        exit()
                except:
                    exit()
            else:
                plt.show(block=pause)
            im.close()
            os.remove(tmp_name)
        else:
            print(&#39;Warning: Either matplotlib or Pillow is not installed. Display disabled.&#39;)
            self.attr[&#39;display&#39;] = &#39;off&#39;
    elif self.attr[&#39;display&#39;] == &#39;xdot&#39;:
        if XDOT_INSTALLED:
            window = xdot.DotWindow()
            window.set_dotcode(self.to_string())
            window.connect(&#39;destroy&#39;, gtk.main_quit)
            gtk.main()
        else:
            print(&#39;Error: xdot not installed. Display disabled.&#39;)
            self.attr[&#39;display&#39;] = &#39;off&#39;
    else:
        print(&#34;Unknown display mode: &#34;, end=&#39; &#39;)
        print(self.attr[&#39;display&#39;])
    if highlight != None:
        for n in highlight:
            if not isinstance(n, Node):
                n = self.get_node(n)
            n.set_attr(&#39;color&#39;, &#39;black&#39;)</code></pre>
</details>
</dd>
<dt id="coinor.gimpy.graph.Graph.edge_to_string"><code class="name flex">
<span>def <span class="ident">edge_to_string</span></span>(<span>self, e)</span>
</code></dt>
<dd>
<div class="desc"><p>API: edge_to_string(self, e)
Description:
Return string that represents edge e in dot language.</p>
<h2 id="input">Input</h2>
<p>e: Edge tuple in (source,sink) format.</p>
<h2 id="pre">Pre</h2>
<p>Graph should have this edge.</p>
<h2 id="return">Return</h2>
<p>String that represents given edge.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def edge_to_string(self, e):
    &#39;&#39;&#39;
    API: edge_to_string(self, e)
    Description:
    Return string that represents edge e in dot language.
    Input:
        e: Edge tuple in (source,sink) format.
    Pre:
        Graph should have this edge.
    Return:
        String that represents given edge.
    &#39;&#39;&#39;
    edge = list()
    edge.append(quote_if_necessary(str(e[0])))
    edge.append(self.edge_connect_symbol)
    edge.append(quote_if_necessary(str(e[1])))
    # return if there is nothing in self.edge_attr[e]
    if len(self.edge_attr[e]) == 0:
        return &#39;&#39;.join(edge)
    edge.append(&#39;  [&#39;)
    for a in self.edge_attr[e]:
        edge.append(a)
        edge.append(&#39;=&#39;)
        edge.append(quote_if_necessary(str(self.edge_attr[e][a])))
        edge.append(&#39;, &#39;)
    edge = edge[:-1]
    edge.append(&#39;]&#39;)
    return &#39;&#39;.join(edge)</code></pre>
</details>
</dd>
<dt id="coinor.gimpy.graph.Graph.fifo_label_correcting"><code class="name flex">
<span>def <span class="ident">fifo_label_correcting</span></span>(<span>self, source)</span>
</code></dt>
<dd>
<div class="desc"><h2 id="api">Api</h2>
<p>fifo_label_correcting(self, source)</p>
<h2 id="description">Description</h2>
<p>finds shortest path from source to every other node. Returns
predecessor dictionary. If graph has a negative cycle, detects it
and returns to it.</p>
<h2 id="pre">Pre</h2>
<p>(1) 'cost' attribute of arcs. It will be used to compute shortest
path.</p>
<h2 id="input">Input</h2>
<p>source: source node</p>
<h2 id="post">Post</h2>
<p>Modifies 'distance' attribute of nodes.</p>
<h2 id="return">Return</h2>
<p>If there is no negative cycle returns to (True, pred), otherwise
returns to (False, cycle) where pred is the predecessor dictionary
and cycle is a list of nodes that represents cycle. It is in
[n_1, n_2, &hellip;, n_k] form where the cycle has k nodes.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def fifo_label_correcting(self, source):
    &#39;&#39;&#39;
    API:
        fifo_label_correcting(self, source)
    Description:
        finds shortest path from source to every other node. Returns
        predecessor dictionary. If graph has a negative cycle, detects it
        and returns to it.
    Pre:
        (1) &#39;cost&#39; attribute of arcs. It will be used to compute shortest
        path.
    Input:
        source: source node
    Post:
        Modifies &#39;distance&#39; attribute of nodes.
    Return:
        If there is no negative cycle returns to (True, pred), otherwise
        returns to (False, cycle) where pred is the predecessor dictionary
        and cycle is a list of nodes that represents cycle. It is in
        [n_1, n_2, ..., n_k] form where the cycle has k nodes.
    &#39;&#39;&#39;
    pred = {}
    self.get_node(source).set_attr(&#39;distance&#39;, 0)
    pred[source] = None
    for n in self.neighbors:
        if n!=source:
            self.get_node(n).set_attr(&#39;distance&#39;, &#39;inf&#39;)
    q = [source]
    while q:
        i = q[0]
        q = q[1:]
        for j in self.neighbors[i]:
            distance_j = self.get_node(j).get_attr(&#39;distance&#39;)
            distance_i = self.get_node(i).get_attr(&#39;distance&#39;)
            c_ij = self.get_edge_attr(i, j, &#39;cost&#39;)
            if distance_j &gt; distance_i + c_ij:
                self.get_node(j).set_attr(&#39;distance&#39;, distance_i+c_ij)
                if j in pred:
                    pred[j] = i
                    cycle = self.label_correcting_check_cycle(j, pred)
                    if cycle is not None:
                        return (False, cycle)
                else:
                    pred[j] = i
                if j not in q:
                    q.append(j)
    return (True, pred)</code></pre>
</details>
</dd>
<dt id="coinor.gimpy.graph.Graph.find_cycle_capacity"><code class="name flex">
<span>def <span class="ident">find_cycle_capacity</span></span>(<span>self, cycle)</span>
</code></dt>
<dd>
<div class="desc"><h2 id="api">Api</h2>
<p>find_cycle_capacity(self, cycle):</p>
<h2 id="description">Description</h2>
<p>Finds capacity of the cycle input.</p>
<h2 id="pre">Pre</h2>
<p>(1) Arcs should have 'capacity' attribute.</p>
<h2 id="input">Input</h2>
<p>cycle: a list representing a cycle</p>
<h2 id="return">Return</h2>
<p>Returns an integer number representing capacity of cycle.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def find_cycle_capacity(self, cycle):
    &#39;&#39;&#39;
    API:
        find_cycle_capacity(self, cycle):
    Description:
        Finds capacity of the cycle input.
    Pre:
        (1) Arcs should have &#39;capacity&#39; attribute.
    Input:
        cycle: a list representing a cycle
    Return:
        Returns an integer number representing capacity of cycle.
    &#39;&#39;&#39;
    index = 0
    k = len(cycle)
    capacity = self.get_edge_attr(cycle[k-1], cycle[0], &#39;capacity&#39;)
    while index&lt;(k-1):
        i = cycle[index]
        j = cycle[index+1]
        capacity_ij = self.get_edge_attr(i, j, &#39;capacity&#39;)
        if capacity &gt; capacity_ij:
            capacity = capacity_ij
        index += 1
    return capacity</code></pre>
</details>
</dd>
<dt id="coinor.gimpy.graph.Graph.find_feasible_flow"><code class="name flex">
<span>def <span class="ident">find_feasible_flow</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><h2 id="api">Api</h2>
<p>find_feasible_flow(self)</p>
<h2 id="description">Description</h2>
<p>Solves feasible flow problem, stores solution in 'flow' attribute
or arcs. This method is used to get an initial feasible flow for
simplex and cycle canceling algorithms. Uses max_flow() method.
Other max flow methods can also be used. Returns True if a feasible
flow is found, returns False, if the problem is infeasible. When
the problem is infeasible 'flow' attributes of arcs should be
considered as junk.</p>
<h2 id="pre">Pre</h2>
<p>(1) 'capacity' attribute of arcs
(2) 'demand' attribute of nodes</p>
<h2 id="post">Post</h2>
<p>Keeps solution in 'flow' attribute of arcs.</p>
<h2 id="return">Return</h2>
<p>Returns True if a feasible flow is found, returns False, if the
problem is infeasible</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def find_feasible_flow(self):
    &#39;&#39;&#39;
    API:
        find_feasible_flow(self)
    Description:
        Solves feasible flow problem, stores solution in &#39;flow&#39; attribute
        or arcs. This method is used to get an initial feasible flow for
        simplex and cycle canceling algorithms. Uses max_flow() method.
        Other max flow methods can also be used. Returns True if a feasible
        flow is found, returns False, if the problem is infeasible. When
        the problem is infeasible &#39;flow&#39; attributes of arcs should be
        considered as junk.
    Pre:
        (1) &#39;capacity&#39; attribute of arcs
        (2) &#39;demand&#39; attribute of nodes
    Post:
        Keeps solution in &#39;flow&#39; attribute of arcs.
    Return:
        Returns True if a feasible flow is found, returns False, if the
        problem is infeasible
    &#39;&#39;&#39;
    # establish a feasible flow in the network, to do this add nodes s and
    # t and solve a max flow problem.
    nl = self.get_node_list()
    for i in nl:
        b_i = self.get_node(i).get_attr(&#39;demand&#39;)
        if b_i &gt; 0:
            # i is a supply node, add (s,i) arc
            self.add_edge(&#39;s&#39;, i, capacity=b_i)
        elif b_i &lt; 0:
            # i is a demand node, add (i,t) arc
            self.add_edge(i, &#39;t&#39;, capacity=-1*b_i)
    # solve max flow on this modified graph
    self.max_flow(&#39;s&#39;, &#39;t&#39;, &#39;off&#39;)
    # check if all demand is satisfied, i.e. the min cost problem is
    # feasible or not
    for i in self.neighbors[&#39;s&#39;]:
        flow = self.get_edge_attr(&#39;s&#39;, i, &#39;flow&#39;)
        capacity = self.get_edge_attr(&#39;s&#39;, i, &#39;capacity&#39;)
        if flow != capacity:
            self.del_node(&#39;s&#39;)
            self.del_node(&#39;t&#39;)
            return False
    # remove node &#39;s&#39; and node &#39;t&#39;
    self.del_node(&#39;s&#39;)
    self.del_node(&#39;t&#39;)
    return True</code></pre>
</details>
</dd>
<dt id="coinor.gimpy.graph.Graph.floyd_warshall"><code class="name flex">
<span>def <span class="ident">floyd_warshall</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><h2 id="api">Api</h2>
<p>floyd_warshall(self)</p>
<h2 id="description">Description</h2>
<p>Finds all pair shortest paths and stores it in a list of lists.
This is possible if the graph does not have negative cycles. It will
return a tuple with 3 elements. The first element indicates whether
the graph has a negative cycle. It is true if the graph does not
have a negative cycle, ie. distances found are valid shortest
distances. The second element is a dictionary of shortest distances
between nodes. Keys are tuple of node pairs ie. (i,j). The third
element is a dictionary that helps to retrieve the shortest path
between nodes. Then return value can be represented as (validity,
distance, nextn) where nextn is the dictionary to retrieve paths.
distance and nextn can be used as inputs to other methods to get
shortest path between nodes.</p>
<h2 id="pre">Pre</h2>
<p>Arcs should have 'cost' attribute.</p>
<h2 id="return">Return</h2>
<p>Returns (validity, distance, nextn). The distances are valid if
validity is True.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def floyd_warshall(self):
    &#39;&#39;&#39;
    API:
        floyd_warshall(self)
    Description:
        Finds all pair shortest paths and stores it in a list of lists.
        This is possible if the graph does not have negative cycles. It will
        return a tuple with 3 elements. The first element indicates whether
        the graph has a negative cycle. It is true if the graph does not
        have a negative cycle, ie. distances found are valid shortest
        distances. The second element is a dictionary of shortest distances
        between nodes. Keys are tuple of node pairs ie. (i,j). The third
        element is a dictionary that helps to retrieve the shortest path
        between nodes. Then return value can be represented as (validity,
        distance, nextn) where nextn is the dictionary to retrieve paths.
        distance and nextn can be used as inputs to other methods to get
        shortest path between nodes.
    Pre:
        Arcs should have &#39;cost&#39; attribute.
    Return:
        Returns (validity, distance, nextn). The distances are valid if
        validity is True.
    &#39;&#39;&#39;
    nl = self.get_node_list()
    el = self.get_edge_list()
    # initialize distance
    distance = {}
    for i in nl:
        for j in nl:
            distance[(i,j)] = &#39;infinity&#39;
    for i in nl:
        distance[(i,i)] = 0
    for e in el:
        distance[(e[0],e[1])] = self.get_edge_cost(e)
    # == end of distance initialization
    # initialize next
    nextn = {}
    for i in nl:
        for j in nl:
            if i==j or distance[(i,j)]==&#39;infinity&#39;:
                nextn[(i,j)] = None
            else:
                nextn[(i,j)] = i
    # == end of next initialization
    # compute shortest distance
    for k in nl:
        for i in nl:
            for j in nl:
                if distance[(i,k)]==&#39;infinity&#39; or distance[(k,j)]==&#39;infinity&#39;:
                    continue
                elif distance[(i,j)]==&#39;infinity&#39;:
                    distance[(i,j)] = distance[(i,k)] + distance[(k,j)]
                    nextn[(i,j)] = nextn[(k,j)]
                elif distance[(i,j)] &gt; distance[(i,k)] + distance[(k,j)]:
                    distance[(i,j)] = distance[(i,k)] + distance[(k,j)]
                    nextn[(i,j)] = nextn[(k,j)]
    # == end of compute shortest distance
    # check if graph has negative cycles
    for i in nl:
        if distance[(i,i)] &lt; 0:
            # shortest distances are not valid
            # graph has negative cycle
            return (False, distance, nextn)
    return (True, distance, nextn)</code></pre>
</details>
</dd>
<dt id="coinor.gimpy.graph.Graph.floyd_warshall_get_cycle"><code class="name flex">
<span>def <span class="ident">floyd_warshall_get_cycle</span></span>(<span>self, distance, nextn, element=None)</span>
</code></dt>
<dd>
<div class="desc"><h2 id="api">Api</h2>
<p>floyd_warshall_get_cycle(self, distance, nextn, element = None)</p>
<h2 id="description">Description</h2>
<p>Finds a negative cycle in the graph.</p>
<h2 id="pre">Pre</h2>
<p>(1) distance and nextn are outputs of floyd_warshall method.
(2) The graph should have a negative cycle, , ie.
distance[(i,i)] &lt; 0 for some node i.</p>
<h2 id="return">Return</h2>
<p>Returns the list of nodes on the cycle. Ex: [i,j,k,&hellip;,r], where
(i,j), (j,k) and (r,i) are some edges in the cycle.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def floyd_warshall_get_cycle(self, distance, nextn, element = None):
    &#39;&#39;&#39;
    API:
        floyd_warshall_get_cycle(self, distance, nextn, element = None)
    Description:
        Finds a negative cycle in the graph.
    Pre:
        (1) distance and nextn are outputs of floyd_warshall method.
        (2) The graph should have a negative cycle, , ie.
        distance[(i,i)] &lt; 0 for some node i.
    Return:
        Returns the list of nodes on the cycle. Ex: [i,j,k,...,r], where
        (i,j), (j,k) and (r,i) are some edges in the cycle.
    &#39;&#39;&#39;
    nl = self.get_node_list()
    if element is None:
        for i in nl:
            if distance[(i,i)] &lt; 0:
                # graph has a cycle on the path from i to i.
                element = i
                break
        else:
            raise Exception(&#39;Graph does not have a negative cycle!&#39;)
    elif distance[(element,element)] &gt;= 0:
        raise Exception(&#39;Graph does not have a negative cycle that contains node &#39;+str(element)+&#39;!&#39;)
    # find the cycle on the path from i to i.
    cycle = [element]
    k = nextn[(element,element)]
    while k not in cycle:
        cycle.insert(1,k)
        k = nextn[(element,k)]
    if k==element:
        return cycle
    else:
        return self.floyd_warshall_get_cycle(distance, nextn, k)</code></pre>
</details>
</dd>
<dt id="coinor.gimpy.graph.Graph.floyd_warshall_get_path"><code class="name flex">
<span>def <span class="ident">floyd_warshall_get_path</span></span>(<span>self, distance, nextn, i, j)</span>
</code></dt>
<dd>
<div class="desc"><h2 id="api">Api</h2>
<p>floyd_warshall_get_path(self, distance, nextn, i, j):</p>
<h2 id="description">Description</h2>
<p>Finds shortest path between i and j using distance and nextn
dictionaries.</p>
<h2 id="pre">Pre</h2>
<p>(1) distance and nextn are outputs of floyd_warshall method.
(2) The graph does not have a negative cycle, , ie.
distance[(i,i)] &gt;=0 for all node i.</p>
<h2 id="return">Return</h2>
<p>Returns the list of nodes on the path from i to j, ie. [i,&hellip;,j]</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def floyd_warshall_get_path(self, distance, nextn, i, j):
    &#39;&#39;&#39;
    API:
        floyd_warshall_get_path(self, distance, nextn, i, j):
    Description:
        Finds shortest path between i and j using distance and nextn
        dictionaries.
    Pre:
        (1) distance and nextn are outputs of floyd_warshall method.
        (2) The graph does not have a negative cycle, , ie.
        distance[(i,i)] &gt;=0 for all node i.
    Return:
        Returns the list of nodes on the path from i to j, ie. [i,...,j]
    &#39;&#39;&#39;
    if distance[(i,j)]==&#39;infinity&#39;:
        return None
    k = nextn[(i,j)]
    path = self.floyd_warshall_get_path
    if i==k:
        return [i, j]
    else:
        return path(distance, nextn, i,k) + [k] + path(distance, nextn, k,j)</code></pre>
</details>
</dd>
<dt id="coinor.gimpy.graph.Graph.get_degrees"><code class="name flex">
<span>def <span class="ident">get_degrees</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><h2 id="api">Api</h2>
<p>get_degree(self)</p>
<h2 id="description">Description</h2>
<p>Returns degrees of nodes in dictionary format.</p>
<h2 id="return">Return</h2>
<p>Returns a dictionary of node degrees. Keys are node names, values
are corresponding degrees.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_degrees(self):
    &#39;&#39;&#39;
    API:
        get_degree(self)
    Description:
        Returns degrees of nodes in dictionary format.
    Return:
        Returns a dictionary of node degrees. Keys are node names, values
        are corresponding degrees.
    &#39;&#39;&#39;
    degree = {}
    if self.attr[&#39;type&#39;] is not DIRECTED_GRAPH:
        for n in self.get_node_list():
            degree[n] = len(self.get_neighbors(n))
        return degree
    else:
        for n in self.get_node_list():
            degree[n] = (len(self.get_in_neighbors(n)) +
                         len(self.get_out_neighbors(n)))</code></pre>
</details>
</dd>
<dt id="coinor.gimpy.graph.Graph.get_diameter"><code class="name flex">
<span>def <span class="ident">get_diameter</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><h2 id="api">Api</h2>
<p>get_diameter(self)</p>
<h2 id="description">Description</h2>
<p>Returns diameter of the graph. Diameter is defined as follows.
distance(n,m): shortest unweighted path from n to m
eccentricity(n) = $\max _m distance(n,m)$
diameter = $\min _n eccentricity(n) = \min _n \max _m distance(n,m)$</p>
<h2 id="return">Return</h2>
<p>Returns diameter of the graph.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_diameter(self):
    &#39;&#39;&#39;
    API:
        get_diameter(self)
    Description:
        Returns diameter of the graph. Diameter is defined as follows.
        distance(n,m): shortest unweighted path from n to m
        eccentricity(n) = $\max _m distance(n,m)$
        diameter = $\min _n eccentricity(n) = \min _n \max _m distance(n,m)$
    Return:
        Returns diameter of the graph.
    &#39;&#39;&#39;

    if self.attr[&#39;type&#39;] is not UNDIRECTED_GRAPH:
        print(&#39;This function only works for undirected graphs&#39;)
        return
    diameter = &#39;infinity&#39;
    eccentricity_n = 0
    for n in self.get_node_list():
        for m in self.get_node_list():
            path_n_m = self.search(n, destination = m, algo = &#39;BFS&#39;)
            if path_n_m is None:
                # this indicates there is no path from n to m, no diameter
                # is defined, since the graph is not connected, return
                # &#39;infinity&#39;
                return &#39;infinity&#39;
            distance_n_m = len(path_n_m)-1
            if distance_n_m &gt; eccentricity_n:
                eccentricity_n = distance_n_m
        if diameter == &#39;infinity&#39; or eccentricity_n &gt; diameter:
            diameter = eccentricity_n
    return diameter</code></pre>
</details>
</dd>
<dt id="coinor.gimpy.graph.Graph.get_edge_attr"><code class="name flex">
<span>def <span class="ident">get_edge_attr</span></span>(<span>self, n, m, attr)</span>
</code></dt>
<dd>
<div class="desc"><p>API: get_edge_attr(self, n, m, attr)
Description:
Returns attribute attr of edge (n,m).</p>
<h2 id="input">Input</h2>
<p>n: Source node name.
m: Sink node name.
attr: Attribute of edge.</p>
<h2 id="pre">Pre</h2>
<p>Graph should have this edge.</p>
<h2 id="return">Return</h2>
<p>Value of edge attribute attr.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_edge_attr(self, n, m, attr):
    &#39;&#39;&#39;
    API: get_edge_attr(self, n, m, attr)
    Description:
    Returns attribute attr of edge (n,m).
    Input:
        n: Source node name.
        m: Sink node name.
        attr: Attribute of edge.
    Pre:
        Graph should have this edge.
    Return:
        Value of edge attribute attr.
    &#39;&#39;&#39;
    if self.graph_type is DIRECTED_GRAPH:
        return self.edge_attr[(n,m)][attr]
    else:
        try:
            return self.edge_attr[(n,m)][attr]
        except KeyError:
            return self.edge_attr[(m,n)][attr]</code></pre>
</details>
</dd>
<dt id="coinor.gimpy.graph.Graph.get_edge_cost"><code class="name flex">
<span>def <span class="ident">get_edge_cost</span></span>(<span>self, edge)</span>
</code></dt>
<dd>
<div class="desc"><p>API: get_edge_cost(self, edge)
Description:
Returns cost attr of edge, required for minimum_spanning_tree_kruskal().</p>
<h2 id="input">Input</h2>
<p>edge: Tuple that represents edge, in (source,sink) form.</p>
<h2 id="return">Return</h2>
<p>Returns cost attribute value of the edge.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_edge_cost(self, edge):
    &#39;&#39;&#39;
    API: get_edge_cost(self, edge)
    Description:
    Returns cost attr of edge, required for minimum_spanning_tree_kruskal().
    Input:
        edge: Tuple that represents edge, in (source,sink) form.
    Return:
        Returns cost attribute value of the edge.
    &#39;&#39;&#39;
    return self.get_edge_attr(edge[0], edge[1], &#39;cost&#39;)</code></pre>
</details>
</dd>
<dt id="coinor.gimpy.graph.Graph.get_edge_list"><code class="name flex">
<span>def <span class="ident">get_edge_list</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>API: get_edge_list(self)
Description:
Returns edge list.</p>
<h2 id="return">Return</h2>
<p>List of edges, edges are tuples and in (source,sink) format.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_edge_list(self):
    &#39;&#39;&#39;
    API: get_edge_list(self)
    Description:
    Returns edge list.
    Return:
        List of edges, edges are tuples and in (source,sink) format.
    &#39;&#39;&#39;
    return list(self.edge_attr.keys())</code></pre>
</details>
</dd>
<dt id="coinor.gimpy.graph.Graph.get_edge_num"><code class="name flex">
<span>def <span class="ident">get_edge_num</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>API: get_edge_num(self)
Description:
Returns number of edges.</p>
<h2 id="return">Return</h2>
<p>Number of edges.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_edge_num(self):
    &#39;&#39;&#39;
    API: get_edge_num(self)
    Description:
    Returns number of edges.
    Return:
        Number of edges.
    &#39;&#39;&#39;
    return len(self.edge_attr)</code></pre>
</details>
</dd>
<dt id="coinor.gimpy.graph.Graph.get_in_degrees"><code class="name flex">
<span>def <span class="ident">get_in_degrees</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><h2 id="api">Api</h2>
<p>get_degree(self)</p>
<h2 id="description">Description</h2>
<p>Returns degrees of nodes in dictionary format.</p>
<h2 id="return">Return</h2>
<p>Returns a dictionary of node degrees. Keys are node names, values
are corresponding degrees.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_in_degrees(self):
    &#39;&#39;&#39;
    API:
        get_degree(self)
    Description:
        Returns degrees of nodes in dictionary format.
    Return:
        Returns a dictionary of node degrees. Keys are node names, values
        are corresponding degrees.
    &#39;&#39;&#39;
    degree = {}
    if self.attr[&#39;type&#39;] is not DIRECTED_GRAPH:
        print(&#39;This function only works for directed graphs&#39;)
        return
    for n in self.get_node_list():
        degree[n] = len(self.get_in_neighbors(n))
    return degree</code></pre>
</details>
</dd>
<dt id="coinor.gimpy.graph.Graph.get_in_neighbors"><code class="name flex">
<span>def <span class="ident">get_in_neighbors</span></span>(<span>self, name)</span>
</code></dt>
<dd>
<div class="desc"><p>API: get_in_neighbors(self, name)
Description:
Returns list of in neighbors of given node.</p>
<h2 id="input">Input</h2>
<p>name: Node name.</p>
<h2 id="pre">Pre</h2>
<p>Graph should have this node.</p>
<h2 id="return">Return</h2>
<p>List of in-neighbor node names.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_in_neighbors(self, name):
    &#39;&#39;&#39;
    API: get_in_neighbors(self, name)
    Description:
    Returns list of in neighbors of given node.
    Input:
        name: Node name.
    Pre:
        Graph should have this node.
    Return:
        List of in-neighbor node names.
    &#39;&#39;&#39;
    return self.in_neighbors[name]</code></pre>
</details>
</dd>
<dt id="coinor.gimpy.graph.Graph.get_layout"><code class="name flex">
<span>def <span class="ident">get_layout</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><h2 id="api">Api</h2>
<p>get_layout(self)
Description:
Returns layout attribute of the graph.</p>
<h2 id="return">Return</h2>
<p>Returns layout attribute of the graph.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_layout(self):
    &#39;&#39;&#39;
    API:
        get_layout(self)
    Description:
    Returns layout attribute of the graph.
    Return:
        Returns layout attribute of the graph.
    &#39;&#39;&#39;
    return self.attr[&#39;layout&#39;]</code></pre>
</details>
</dd>
<dt id="coinor.gimpy.graph.Graph.get_negative_cycle"><code class="name flex">
<span>def <span class="ident">get_negative_cycle</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><h2 id="api">Api</h2>
<p>get_negative_cycle(self)</p>
<h2 id="description">Description</h2>
<p>Finds and returns negative cost cycle using 'cost' attribute of
arcs. Return value is a list of nodes representing cycle it is in
the following form; n_1-n_2-&hellip;-n_k, when the cycle has k nodes.</p>
<h2 id="pre">Pre</h2>
<p>Arcs should have 'cost' attribute.</p>
<h2 id="return">Return</h2>
<p>Returns a list of nodes in the cycle if a negative cycle exists,
returns None otherwise.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_negative_cycle(self):
    &#39;&#39;&#39;
    API:
        get_negative_cycle(self)
    Description:
        Finds and returns negative cost cycle using &#39;cost&#39; attribute of
        arcs. Return value is a list of nodes representing cycle it is in
        the following form; n_1-n_2-...-n_k, when the cycle has k nodes.
    Pre:
        Arcs should have &#39;cost&#39; attribute.
    Return:
        Returns a list of nodes in the cycle if a negative cycle exists,
        returns None otherwise.
    &#39;&#39;&#39;
    nl = self.get_node_list()
    i = nl[0]
    (valid, distance, nextn) = self.floyd_warshall()
    if not valid:
        cycle = self.floyd_warshall_get_cycle(distance, nextn)
        return cycle
    else:
        return None</code></pre>
</details>
</dd>
<dt id="coinor.gimpy.graph.Graph.get_neighbors"><code class="name flex">
<span>def <span class="ident">get_neighbors</span></span>(<span>self, name)</span>
</code></dt>
<dd>
<div class="desc"><p>API: get_neighbors(self, name)
Description:
Returns list of neighbors of given node.</p>
<h2 id="input">Input</h2>
<p>name: Node name.</p>
<h2 id="pre">Pre</h2>
<p>Graph should have this node.</p>
<h2 id="return">Return</h2>
<p>List of neighbor node names.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_neighbors(self, name):
    &#39;&#39;&#39;
    API: get_neighbors(self, name)
    Description:
    Returns list of neighbors of given node.
    Input:
        name: Node name.
    Pre:
        Graph should have this node.
    Return:
        List of neighbor node names.
    &#39;&#39;&#39;
    return self.neighbors[name]</code></pre>
</details>
</dd>
<dt id="coinor.gimpy.graph.Graph.get_node"><code class="name flex">
<span>def <span class="ident">get_node</span></span>(<span>self, name)</span>
</code></dt>
<dd>
<div class="desc"><p>API: get_node(self, name)
Description:
Returns node object with the provided name.</p>
<h2 id="input">Input</h2>
<p>name: Name of the node.</p>
<h2 id="return">Return</h2>
<p>Returns node object if node exists, returns None otherwise.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_node(self, name):
    &#39;&#39;&#39;
    API: get_node(self, name)
    Description:
    Returns node object with the provided name.
    Input:
        name: Name of the node.
    Return:
        Returns node object if node exists, returns None otherwise.
    &#39;&#39;&#39;
    if name in self.nodes:
        return self.nodes[name]
    else:
        return None</code></pre>
</details>
</dd>
<dt id="coinor.gimpy.graph.Graph.get_node_attr"><code class="name flex">
<span>def <span class="ident">get_node_attr</span></span>(<span>self, name, attr)</span>
</code></dt>
<dd>
<div class="desc"><p>API: get_node_attr(self, name, attr)
Description:
Returns attribute attr of given node.</p>
<h2 id="input">Input</h2>
<p>name: Name of node.
attr: Attribute of node.</p>
<h2 id="pre">Pre</h2>
<p>Graph should have this node.</p>
<h2 id="return">Return</h2>
<p>Value of node attribute attr.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_node_attr(self, name, attr):
    &#39;&#39;&#39;
    API: get_node_attr(self, name, attr)
    Description:
    Returns attribute attr of given node.
    Input:
        name: Name of node.
        attr: Attribute of node.
    Pre:
        Graph should have this node.
    Return:
        Value of node attribute attr.
    &#39;&#39;&#39;
    return self.get_node(name).get_attr(attr)</code></pre>
</details>
</dd>
<dt id="coinor.gimpy.graph.Graph.get_node_list"><code class="name flex">
<span>def <span class="ident">get_node_list</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>API: get_node_list(self)
Description:
Returns node list.</p>
<h2 id="return">Return</h2>
<p>List of nodes.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_node_list(self):
    &#39;&#39;&#39;
    API: get_node_list(self)
    Description:
    Returns node list.
    Return:
        List of nodes.
    &#39;&#39;&#39;
    return list(self.neighbors.keys())</code></pre>
</details>
</dd>
<dt id="coinor.gimpy.graph.Graph.get_node_num"><code class="name flex">
<span>def <span class="ident">get_node_num</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>API: get_node_num(self)
Description:
Returns number of nodes.</p>
<h2 id="return">Return</h2>
<p>Number of nodes.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_node_num(self):
    &#39;&#39;&#39;
    API: get_node_num(self)
    Description:
    Returns number of nodes.
    Return:
        Number of nodes.
    &#39;&#39;&#39;
    return len(self.neighbors)</code></pre>
</details>
</dd>
<dt id="coinor.gimpy.graph.Graph.get_out_degrees"><code class="name flex">
<span>def <span class="ident">get_out_degrees</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><h2 id="api">Api</h2>
<p>get_degree(self)</p>
<h2 id="description">Description</h2>
<p>Returns degrees of nodes in dictionary format.</p>
<h2 id="return">Return</h2>
<p>Returns a dictionary of node degrees. Keys are node names, values
are corresponding degrees.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_out_degrees(self):
    &#39;&#39;&#39;
    API:
        get_degree(self)
    Description:
        Returns degrees of nodes in dictionary format.
    Return:
        Returns a dictionary of node degrees. Keys are node names, values
        are corresponding degrees.
    &#39;&#39;&#39;
    degree = {}
    if self.attr[&#39;type&#39;] is not DIRECTED_GRAPH:
        print(&#39;This function only works for directed graphs&#39;)
        return
    for n in self.get_node_list():
        degree[n] = len(self.get_out_neighbors(n))
    return degree</code></pre>
</details>
</dd>
<dt id="coinor.gimpy.graph.Graph.get_out_neighbors"><code class="name flex">
<span>def <span class="ident">get_out_neighbors</span></span>(<span>self, name)</span>
</code></dt>
<dd>
<div class="desc"><p>API: get_out_neighbors(self, name)
Description:
Returns list of out-neighbors of given node.</p>
<h2 id="input">Input</h2>
<p>name: Node name.</p>
<h2 id="pre">Pre</h2>
<p>Graph should have this node.</p>
<h2 id="return">Return</h2>
<p>List of out-neighbor node names.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_out_neighbors(self, name):
    &#39;&#39;&#39;
    API: get_out_neighbors(self, name)
    Description:
    Returns list of out-neighbors of given node.
    Input:
        name: Node name.
    Pre:
        Graph should have this node.
    Return:
        List of out-neighbor node names.
    &#39;&#39;&#39;
    return self.neighbors[name]</code></pre>
</details>
</dd>
<dt id="coinor.gimpy.graph.Graph.get_simplex_solution_graph"><code class="name flex">
<span>def <span class="ident">get_simplex_solution_graph</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><h2 id="api">Api</h2>
<p>get_simplex_solution_graph(self):</p>
<h2 id="description">Description</h2>
<p>Assumes a feasible flow solution stored in 'flow' attribute's of
arcs. Returns the graph with arcs that have flow between 0 and
capacity.</p>
<h2 id="pre">Pre</h2>
<p>(1) 'flow' attribute represents a feasible flow solution. See
Pre section of min_cost_flow() for details.</p>
<h2 id="return">Return</h2>
<p>Graph instance that only has the arcs that have flow strictly
between 0 and capacity.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_simplex_solution_graph(self):
    &#39;&#39;&#39;
    API:
        get_simplex_solution_graph(self):
    Description:
        Assumes a feasible flow solution stored in &#39;flow&#39; attribute&#39;s of
        arcs. Returns the graph with arcs that have flow between 0 and
        capacity.
    Pre:
        (1) &#39;flow&#39; attribute represents a feasible flow solution. See
        Pre section of min_cost_flow() for details.
    Return:
        Graph instance that only has the arcs that have flow strictly
        between 0 and capacity.
    &#39;&#39;&#39;
    simplex_g = Graph(type=DIRECTED_GRAPH)
    for i in self.neighbors:
        simplex_g.add_node(i)
    for e in self.edge_attr:
        flow_e = self.edge_attr[e][&#39;flow&#39;]
        capacity_e = self.edge_attr[e][&#39;capacity&#39;]
        if flow_e&gt;0 and flow_e&lt;capacity_e:
            simplex_g.add_edge(e[0], e[1])
    return simplex_g</code></pre>
</details>
</dd>
<dt id="coinor.gimpy.graph.Graph.label_components"><code class="name flex">
<span>def <span class="ident">label_components</span></span>(<span>self, display=None)</span>
</code></dt>
<dd>
<div class="desc"><p>API: label_components(self, display=None)
Description:
This method labels the nodes of an undirected graph with component
numbers so that each node has the same label as all nodes in the
same component. It will display the algortihm if display argument is
provided.</p>
<h2 id="input">Input</h2>
<p>display: display method.</p>
<h2 id="pre">Pre</h2>
<p>self.graph_type should be UNDIRECTED_GRAPH.</p>
<h2 id="post">Post</h2>
<p>Nodes will have 'component' attribute that will have component
number as value.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def label_components(self, display = None):
    &#39;&#39;&#39;
    API: label_components(self, display=None)
    Description:
    This method labels the nodes of an undirected graph with component
    numbers so that each node has the same label as all nodes in the
    same component. It will display the algortihm if display argument is
    provided.
    Input:
        display: display method.
    Pre:
        self.graph_type should be UNDIRECTED_GRAPH.
    Post:
        Nodes will have &#39;component&#39; attribute that will have component
        number as value.
    &#39;&#39;&#39;
    if self.graph_type == DIRECTED_GRAPH:
        raise Exception(&#34;label_components only works for &#34;,
                        &#34;undirected graphs&#34;)
    self.num_components = 0
    for n in self.get_node_list():
        self.get_node(n).set_attr(&#39;component&#39;, None)
    for n in self.neighbors:
        self.get_node(n).set_attr(&#39;label&#39;, &#39;-&#39;)
    for n in self.get_node_list():
        if self.get_node(n).get_attr(&#39;component&#39;) == None:
            self.search(n, display=display,
                        component=self.num_components, algo=&#39;DFS&#39;)
            self.num_components += 1</code></pre>
</details>
</dd>
<dt id="coinor.gimpy.graph.Graph.label_correcting_check_cycle"><code class="name flex">
<span>def <span class="ident">label_correcting_check_cycle</span></span>(<span>self, j, pred)</span>
</code></dt>
<dd>
<div class="desc"><h2 id="api">Api</h2>
<p>label_correcting_check_cycle(self, j, pred)</p>
<h2 id="description">Description</h2>
<p>Checks if predecessor dictionary has a cycle, j represents the node
that predecessor is recently updated.</p>
<h2 id="pre">Pre</h2>
<p>(1) predecessor of source node should be None.</p>
<h2 id="input">Input</h2>
<p>j: node that predecessor is recently updated.
pred: predecessor dictionary</p>
<h2 id="return">Return</h2>
<p>If there exists a cycle, returns the list that represents the
cycle, otherwise it returns to None.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def label_correcting_check_cycle(self, j, pred):
    &#39;&#39;&#39;
    API:
        label_correcting_check_cycle(self, j, pred)
    Description:
        Checks if predecessor dictionary has a cycle, j represents the node
        that predecessor is recently updated.
    Pre:
        (1) predecessor of source node should be None.
    Input:
        j: node that predecessor is recently updated.
        pred: predecessor dictionary
    Return:
        If there exists a cycle, returns the list that represents the
        cycle, otherwise it returns to None.
    &#39;&#39;&#39;
    labelled = {}
    for n in self.neighbors:
        labelled[n] = None
    current = j
    while current != None:
        if labelled[current]==j:
            cycle = self.label_correcting_get_cycle(j, pred)
            return cycle
        labelled[current] = j
        current = pred[current]
    return None</code></pre>
</details>
</dd>
<dt id="coinor.gimpy.graph.Graph.label_correcting_get_cycle"><code class="name flex">
<span>def <span class="ident">label_correcting_get_cycle</span></span>(<span>self, j, pred)</span>
</code></dt>
<dd>
<div class="desc"><h2 id="api">Api</h2>
<p>label_correcting_get_cycle(self, labelled, pred)</p>
<h2 id="description">Description</h2>
<p>In label correcting check cycle it is decided pred has a cycle and
nodes in the cycle are labelled. We will create a list of nodes
in the cycle using labelled and pred inputs.</p>
<h2 id="pre">Pre</h2>
<p>This method should be called from label_correcting_check_cycle(),
unless you are sure about what you are doing.</p>
<h2 id="input">Input</h2>
<p>j: Node that predecessor is recently updated. We know that it is
in the cycle
pred: Predecessor dictionary that contains a cycle</p>
<h2 id="post">Post</h2>
<p>Returns a list of nodes that represents cycle. It is in
[n_1, n_2, &hellip;, n_k] form where the cycle has k nodes.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def label_correcting_get_cycle(self, j, pred):
    &#39;&#39;&#39;
    API:
        label_correcting_get_cycle(self, labelled, pred)
    Description:
        In label correcting check cycle it is decided pred has a cycle and
        nodes in the cycle are labelled. We will create a list of nodes
        in the cycle using labelled and pred inputs.
    Pre:
        This method should be called from label_correcting_check_cycle(),
        unless you are sure about what you are doing.
    Input:
        j: Node that predecessor is recently updated. We know that it is
        in the cycle
        pred: Predecessor dictionary that contains a cycle
    Post:
        Returns a list of nodes that represents cycle. It is in
        [n_1, n_2, ..., n_k] form where the cycle has k nodes.
    &#39;&#39;&#39;
    cycle = []
    cycle.append(j)
    current = pred[j]
    while current!=j:
        cycle.append(current)
        current = pred[current]
    cycle.reverse()
    return cycle</code></pre>
</details>
</dd>
<dt id="coinor.gimpy.graph.Graph.label_strong_component"><code class="name flex">
<span>def <span class="ident">label_strong_component</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>API: label_strong_component(self)
Description:
This method labels the nodes of a directed graph with component
numbers so that each node has the same label as all nodes in the
same component.</p>
<h2 id="pre">Pre</h2>
<p>self.graph_type should be DIRECTED_GRAPH.</p>
<h2 id="post">Post</h2>
<p>Nodes will have 'component' attribute that will have component
number as value. Changes 'index' attribute of nodes.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def label_strong_component(self):
    &#39;&#39;&#39;
    API: label_strong_component(self)
    Description:
    This method labels the nodes of a directed graph with component
    numbers so that each node has the same label as all nodes in the
    same component.
    Pre:
        self.graph_type should be DIRECTED_GRAPH.
    Post:
        Nodes will have &#39;component&#39; attribute that will have component
        number as value. Changes &#39;index&#39; attribute of nodes.
    &#39;&#39;&#39;
    self.num_components = 0
    self.tarjan()</code></pre>
</details>
</dd>
<dt id="coinor.gimpy.graph.Graph.max_flow"><code class="name flex">
<span>def <span class="ident">max_flow</span></span>(<span>self, source, sink, display=None, algo='DFS')</span>
</code></dt>
<dd>
<div class="desc"><p>API: max_flow(self, source, sink, display=None)
Description:
Finds maximum flow from source to sink by a depth-first search based
augmenting path algorithm.</p>
<h2 id="pre">Pre</h2>
<p>Assumes a directed graph in which each arc has a 'capacity'
attribute and for which there does does not exist both arcs (i,j)
and (j, i) for any pair of nodes i and j.</p>
<h2 id="input">Input</h2>
<p>source: Source node name.
sink: Sink node name.
display: Display mode.</p>
<h2 id="post">Post</h2>
<p>The 'flow" attribute of each arc gives a maximum flow.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def max_flow(self, source, sink, display = None, algo = &#39;DFS&#39;):
    &#39;&#39;&#39;
    API: max_flow(self, source, sink, display=None)
    Description:
    Finds maximum flow from source to sink by a depth-first search based
    augmenting path algorithm.
    Pre:
        Assumes a directed graph in which each arc has a &#39;capacity&#39;
        attribute and for which there does does not exist both arcs (i,j)
        and (j, i) for any pair of nodes i and j.
    Input:
        source: Source node name.
        sink: Sink node name.
        display: Display mode.
    Post:
        The &#39;flow&#34; attribute of each arc gives a maximum flow.
    &#39;&#39;&#39;
    if display is not None:
        old_display =  self.attr[&#39;display&#39;]
        self.attr[&#39;display&#39;] = display
    nl = self.get_node_list()
    # set flow of all edges to 0
    for e in self.edge_attr:
        self.edge_attr[e][&#39;flow&#39;] = 0
        if &#39;capacity&#39; in self.edge_attr[e]:
            capacity = self.edge_attr[e][&#39;capacity&#39;]
            self.edge_attr[e][&#39;label&#39;] = str(capacity)+&#39;/0&#39;
        else:
            self.edge_attr[e][&#39;capacity&#39;] = INF
            self.edge_attr[e][&#39;label&#39;] = &#39;INF/0&#39;
    while True:
        # find an augmenting path from source to sink using DFS
        if algo == &#39;DFS&#39;:
            q = Stack()
        elif algo == &#39;BFS&#39;:
            q = Queue()
        q.push(source)
        pred = {source:None}
        explored = [source]
        for n in nl:
            self.get_node(n).set_attr(&#39;color&#39;, &#39;black&#39;)
        for e in self.edge_attr:
            if self.edge_attr[e][&#39;flow&#39;] == 0:
                self.edge_attr[e][&#39;color&#39;] = &#39;black&#39;
            elif self.edge_attr[e][&#39;flow&#39;]==self.edge_attr[e][&#39;capacity&#39;]:
                self.edge_attr[e][&#39;color&#39;] = &#39;red&#39;
            else:
                self.edge_attr[e][&#39;color&#39;] = &#39;green&#39;
        self.display()
        while not q.isEmpty():
            current = q.peek()
            q.remove(current)
            if current == sink:
                break
            out_neighbor = self.neighbors[current]
            in_neighbor = self.in_neighbors[current]
            neighbor = out_neighbor+in_neighbor
            for m in neighbor:
                if m in explored:
                    continue
                self.get_node(m).set_attr(&#39;color&#39;, &#39;yellow&#39;)
                if m in out_neighbor:
                    self.set_edge_attr(current, m, &#39;color&#39;, &#39;yellow&#39;)
                    available_capacity = (
                        self.get_edge_attr(current, m, &#39;capacity&#39;)-
                        self.get_edge_attr(current, m, &#39;flow&#39;))
                else:
                    self.set_edge_attr(m, current, &#39;color&#39;, &#39;yellow&#39;)
                    available_capacity=self.get_edge_attr(m, current, &#39;flow&#39;)
                self.display()
                if available_capacity &gt; 0:
                    self.get_node(m).set_attr(&#39;color&#39;, &#39;blue&#39;)
                    if m in out_neighbor:
                        self.set_edge_attr(current, m, &#39;color&#39;, &#39;blue&#39;)
                    else:
                        self.set_edge_attr(m, current, &#39;color&#39;, &#39;blue&#39;)
                    explored.append(m)
                    pred[m] = current
                    q.push(m)
                else:
                    self.get_node(m).set_attr(&#39;color&#39;, &#39;black&#39;)
                    if m in out_neighbor:
                        if (self.get_edge_attr(current, m, &#39;flow&#39;) ==
                            self.get_edge_attr(current, m, &#39;capacity&#39;)):
                            self.set_edge_attr(current, m, &#39;color&#39;, &#39;red&#39;)
                        elif self.get_edge_attr(current, m, &#39;flow&#39;) == 0:
                            self.set_edge_attr(current, m, &#39;color&#39;, &#39;black&#39;)
                        #else:
                        #    self.set_edge_attr(current, m, &#39;color&#39;, &#39;green&#39;)
                    else:
                        if (self.get_edge_attr(m, current, &#39;flow&#39;) ==
                            self.get_edge_attr(m, current, &#39;capacity&#39;)):
                            self.set_edge_attr(m, current, &#39;color&#39;, &#39;red&#39;)
                        elif self.get_edge_attr(m, current, &#39;flow&#39;) == 0:
                            self.set_edge_attr(m, current, &#39;color&#39;, &#39;black&#39;)
                        #else:
                        #    self.set_edge_attr(m, current, &#39;color&#39;, &#39;green&#39;)
                self.display()
        # if no path with positive capacity from source sink exists, stop
        if sink not in pred:
            break
        # find capacity of the path
        current = sink
        min_capacity = &#39;infinite&#39;
        while True:
            m = pred[current]
            if (m,current) in self.edge_attr:
                arc_capacity = self.edge_attr[(m, current)][&#39;capacity&#39;]
                flow = self.edge_attr[(m, current)][&#39;flow&#39;]
                potential = arc_capacity-flow
                if min_capacity == &#39;infinite&#39;:
                    min_capacity = potential
                elif min_capacity &gt; potential:
                    min_capacity = potential
            else:
                potential = self.edge_attr[(current, m)][&#39;flow&#39;]
                if min_capacity == &#39;infinite&#39;:
                    min_capacity = potential
                elif min_capacity &gt; potential:
                    min_capacity = potential
            if m == source:
                break
            current = m
        # update flows on the path
        current = sink
        while True:
            m = pred[current]
            if (m, current) in self.edge_attr:
                flow = self.edge_attr[(m, current)][&#39;flow&#39;]
                capacity = self.edge_attr[(m, current)][&#39;capacity&#39;]
                new_flow = flow+min_capacity
                self.edge_attr[(m, current)][&#39;flow&#39;] = new_flow
                if capacity == INF:
                    self.edge_attr[(m, current)][&#39;label&#39;] = \
                        &#39;INF&#39; + &#39;/&#39;+str(new_flow)
                else:
                    self.edge_attr[(m, current)][&#39;label&#39;] = \
                        str(capacity)+&#39;/&#39;+str(new_flow)
                if new_flow==capacity:
                    self.edge_attr[(m, current)][&#39;color&#39;] = &#39;red&#39;
                else:
                    self.edge_attr[(m, current)][&#39;color&#39;] = &#39;green&#39;
                self.display()
            else:
                flow = self.edge_attr[(current, m)][&#39;flow&#39;]
                capacity = self.edge_attr[(current, m)][&#39;capacity&#39;]
                new_flow = flow-min_capacity
                self.edge_attr[(current, m)][&#39;flow&#39;] = new_flow
                if capacity == INF:
                    self.edge_attr[(current, m)][&#39;label&#39;] = \
                        &#39;INF&#39; + &#39;/&#39;+str(new_flow)
                else:
                    self.edge_attr[(current, m)][&#39;label&#39;] = \
                        str(capacity)+&#39;/&#39;+str(new_flow)
                if new_flow==0:
                    self.edge_attr[(current, m)][&#39;color&#39;] = &#39;red&#39;
                else:
                    self.edge_attr[(current, m)][&#39;color&#39;] = &#39;green&#39;
                self.display()
            if m == source:
                break
            current = m
    if display is not None:
        self.attr[&#39;display&#39;] = old_display</code></pre>
</details>
</dd>
<dt id="coinor.gimpy.graph.Graph.max_flow_preflowpush"><code class="name flex">
<span>def <span class="ident">max_flow_preflowpush</span></span>(<span>self, source, sink, algo='FIFO', display=None)</span>
</code></dt>
<dd>
<div class="desc"><p>API: max_flow_preflowpush(self, source, sink, algo = 'FIFO',
display = None)
Description:
Finds maximum flow from source to sink by a depth-first search based
augmenting path algorithm.</p>
<h2 id="pre">Pre</h2>
<p>Assumes a directed graph in which each arc has a 'capacity'
attribute and for which there does does not exist both arcs (i,j)
and (j,i) for any pair of nodes i and j.</p>
<h2 id="input">Input</h2>
<p>source: Source node name.
sink: Sink node name.
algo: Algorithm choice, 'FIFO', 'SAP' or 'HighestLabel'.
display: display method.</p>
<h2 id="post">Post</h2>
<p>The 'flow' attribute of each arc gives a maximum flow.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def max_flow_preflowpush(self, source, sink, algo = &#39;FIFO&#39;, display = None):
    &#39;&#39;&#39;
    API: max_flow_preflowpush(self, source, sink, algo = &#39;FIFO&#39;,
                              display = None)
    Description:
    Finds maximum flow from source to sink by a depth-first search based
    augmenting path algorithm.
    Pre:
         Assumes a directed graph in which each arc has a &#39;capacity&#39;
         attribute and for which there does does not exist both arcs (i,j)
         and (j,i) for any pair of nodes i and j.
    Input:
        source: Source node name.
        sink: Sink node name.
        algo: Algorithm choice, &#39;FIFO&#39;, &#39;SAP&#39; or &#39;HighestLabel&#39;.
        display: display method.
    Post:
        The &#39;flow&#39; attribute of each arc gives a maximum flow.
    &#39;&#39;&#39;
    if display == None:
        display = self.attr[&#39;display&#39;]
    else:
        self.set_display_mode(display)
    nl = self.get_node_list()
    # set excess of all nodes to 0
    for n in nl:
        self.set_node_attr(n, &#39;excess&#39;, 0)
    # set flow of all edges to 0
    for e in self.edge_attr:
        self.edge_attr[e][&#39;flow&#39;] = 0
        if &#39;capacity&#39; in self.edge_attr[e]:
            capacity = self.edge_attr[e][&#39;capacity&#39;]
            self.edge_attr[e][&#39;label&#39;] = str(capacity)+&#39;/0&#39;
        else:
            self.edge_attr[e][&#39;capacity&#39;] = INF
            self.edge_attr[e][&#39;label&#39;] = &#39;INF/0&#39;
    self.display()
    self.set_display_mode(&#39;off&#39;)
    self.search(sink, algo = &#39;UnweightedSPT&#39;, reverse = True)
    self.set_display_mode(display)
    disconnect = False
    for n in nl:
        if self.get_node_attr(n, &#39;distance&#39;) is None:
            disconnect = True
            self.set_node_attr(n, &#39;distance&#39;,
                               2*len(nl) + 1)
    if disconnect:
        print(&#39;Warning: graph contains nodes not connected to the sink...&#39;)
    if algo == &#39;FIFO&#39;:
        q = Queue()
    elif algo == &#39;SAP&#39;:
        q = Stack()
    elif algo == &#39;HighestLabel&#39;:
        q = PriorityQueue()
    for n in self.get_neighbors(source):
        capacity = self.get_edge_attr(source, n, &#39;capacity&#39;)
        self.set_edge_attr(source, n, &#39;flow&#39;, capacity)
        self.set_node_attr(n, &#39;excess&#39;, capacity)
        excess = self.get_node_attr(source, &#39;excess&#39;)
        self.set_node_attr(source, &#39;excess&#39;, excess - capacity)
        if algo == &#39;FIFO&#39; or algo == &#39;SAP&#39;:
            q.push(n)
        elif algo == &#39;HighestLabel&#39;:
            q.push(n, -1)
    self.set_node_attr(source, &#39;distance&#39;, len(nl))
    self.show_flow()
    while not q.isEmpty():
        relabel = True
        current = q.peek()
        neighbors = (self.get_neighbors(current) +
                     self.get_in_neighbors(current))
        for n in neighbors:
            pushed = self.process_edge_flow(source, sink, current, n, algo,
                                            q)
            if pushed:
                self.show_flow()
                if algo == &#39;FIFO&#39;:
                    &#39;&#39;&#39;With FIFO, we need to add the neighbors to the queue
                    before the current is added back in or the nodes will
                    be out of order
                    &#39;&#39;&#39;
                    if q.peek(n) is None and n != source and n != sink:
                        q.push(n)
                    &#39;&#39;&#39;Keep pushing while there is excess&#39;&#39;&#39;
                    if self.get_node_attr(current, &#39;excess&#39;) &gt; 0:
                        continue
                &#39;&#39;&#39;If we were able to push, then there we should not
                relabel
                &#39;&#39;&#39;
                relabel = False
                break
        q.remove(current)
        if current != sink:
            if relabel:
                self.relabel(current)
                self.show_flow()
            if self.get_node_attr(current, &#39;excess&#39;) &gt; 0:
                if algo == &#39;FIFO&#39; or algo == &#39;SAP&#39;:
                    q.push(current)
                elif algo == &#39;HighestLabel&#39;:
                    q.push(current, -self.get_node_attr(current,
                                                        &#39;distance&#39;))
        if pushed and q.peek(n) is None and n != source:
            if algo == &#39;SAP&#39;:
                q.push(n)
            elif algo == &#39;HighestLabel&#39;:
                q.push(n, -self.get_node_attr(n, &#39;distance&#39;))</code></pre>
</details>
</dd>
<dt id="coinor.gimpy.graph.Graph.min_cost_flow"><code class="name flex">
<span>def <span class="ident">min_cost_flow</span></span>(<span>self, display=None, **args)</span>
</code></dt>
<dd>
<div class="desc"><h2 id="api">Api</h2>
<p>min_cost_flow(self, display='off', **args)</p>
<h2 id="description">Description</h2>
<p>Solves minimum cost flow problem using node/edge attributes with
the algorithm specified.</p>
<h2 id="pre">Pre</h2>
<p>(1) Assumes a directed graph in which each arc has 'capacity' and
'cost' attributes.
(2) Nodes should have 'demand' attribute. This value should be
positive for supply and negative for demand, and 0 for transhipment
nodes.
(3) The graph should be connected.
(4) Assumes (i,j) and (j,i) does not exist together. Needed when
solving max flow. (max flow problem is solved to get a feasible
flow).</p>
<h2 id="input">Input</h2>
<p>display: 'off' for no display, 'matplotlib' for live update of tree
args: may have the following
display: display method, if not given current mode (the one
specified by <strong>init</strong> or set_display) will be used.
algo: determines algorithm to use, can be one of the following
'simplex': network simplex algorithm
'cycle_canceling': cycle canceling algorithm
'simplex' is used if not given.
see Network Flows by Ahuja et al. for details of algorithms.
pivot: valid if algo is 'simlex', determines pivoting rule for
simplex, may be one of the following; 'first_eligible',
'dantzig' or 'scaled'.
'dantzig' is used if not given.
see Network Flows by Ahuja et al. for pivot rules.
root: valid if algo is 'simlex', specifies the root node for
simplex algorithm. It is name of the one of the nodes. It
will be chosen randomly if not provided.</p>
<h2 id="post">Post</h2>
<p>The 'flow' attribute of each arc gives the optimal flows.
'distance' attribute of the nodes are also changed during max flow
solution process.</p>
<h2 id="examples">Examples</h2>
<p>g.min_cost_flow():
solves minimum cost feasible flow problem using simplex
algorithm with dantzig pivoting rule.
See pre section for details.
g.min_cost_flow(algo='cycle_canceling'):
solves minimum cost feasible flow problem using cycle canceling
agorithm.
g.min_cost_flow(algo='simplex', pivot='scaled'):
solves minimum cost feasible flow problem using network simplex
agorithm with scaled pivot rule.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def min_cost_flow(self, display = None, **args):
    &#39;&#39;&#39;
    API:
        min_cost_flow(self, display=&#39;off&#39;, **args)
    Description:
        Solves minimum cost flow problem using node/edge attributes with
        the algorithm specified.
    Pre:
        (1) Assumes a directed graph in which each arc has &#39;capacity&#39; and
        &#39;cost&#39; attributes.
        (2) Nodes should have &#39;demand&#39; attribute. This value should be
        positive for supply and negative for demand, and 0 for transhipment
        nodes.
        (3) The graph should be connected.
        (4) Assumes (i,j) and (j,i) does not exist together. Needed when
        solving max flow. (max flow problem is solved to get a feasible
        flow).
    Input:
        display: &#39;off&#39; for no display, &#39;matplotlib&#39; for live update of tree
        args: may have the following
            display: display method, if not given current mode (the one
                specified by __init__ or set_display) will be used.
            algo: determines algorithm to use, can be one of the following
                &#39;simplex&#39;: network simplex algorithm
                &#39;cycle_canceling&#39;: cycle canceling algorithm
                &#39;simplex&#39; is used if not given.
                see Network Flows by Ahuja et al. for details of algorithms.
            pivot: valid if algo is &#39;simlex&#39;, determines pivoting rule for
                simplex, may be one of the following; &#39;first_eligible&#39;,
                &#39;dantzig&#39; or &#39;scaled&#39;.
                &#39;dantzig&#39; is used if not given.
                see Network Flows by Ahuja et al. for pivot rules.
            root: valid if algo is &#39;simlex&#39;, specifies the root node for
                simplex algorithm. It is name of the one of the nodes. It
                will be chosen randomly if not provided.
    Post:
        The &#39;flow&#39; attribute of each arc gives the optimal flows.
        &#39;distance&#39; attribute of the nodes are also changed during max flow
        solution process.
    Examples:
        g.min_cost_flow():
            solves minimum cost feasible flow problem using simplex
            algorithm with dantzig pivoting rule.
            See pre section for details.
        g.min_cost_flow(algo=&#39;cycle_canceling&#39;):
            solves minimum cost feasible flow problem using cycle canceling
            agorithm.
        g.min_cost_flow(algo=&#39;simplex&#39;, pivot=&#39;scaled&#39;):
            solves minimum cost feasible flow problem using network simplex
            agorithm with scaled pivot rule.
    &#39;&#39;&#39;
    if display is None:
        display = self.attr[&#39;display&#39;]
    if &#39;algo&#39; in args:
        algorithm = args[&#39;algo&#39;]
    else:
        algorithm = &#39;simplex&#39;
    if algorithm == &#39;simplex&#39;:
        if &#39;root&#39; in args:
            root = args[&#39;root&#39;]
        else:
            for k in self.neighbors:
                root = k
                break
        if &#39;pivot&#39; in args:
            if not self.network_simplex(display, args[&#39;pivot&#39;], root):
                print(&#39;problem is infeasible&#39;)
        else:
            if not self.network_simplex(display, &#39;dantzig&#39;, root):
                print(&#39;problem is infeasible&#39;)
    elif algorithm == &#39;cycle_canceling&#39;:
        if not self.cycle_canceling(display):
            print(&#39;problem is infeasible&#39;)
    else:
        print(args[&#39;algo&#39;], &#39;is not a defined algorithm. Exiting.&#39;)
        return</code></pre>
</details>
</dd>
<dt id="coinor.gimpy.graph.Graph.minimum_spanning_tree_kruskal"><code class="name flex">
<span>def <span class="ident">minimum_spanning_tree_kruskal</span></span>(<span>self, display=None, components=None)</span>
</code></dt>
<dd>
<div class="desc"><p>API: minimum_spanning_tree_kruskal(self, display = None,
components = None)
Description:
Determines a minimum spanning tree using Kruskal's Algorithm.</p>
<h2 id="input">Input</h2>
<p>display: Display method.
component: component number.</p>
<h2 id="post">Post</h2>
<p>'color' attribute of nodes and edges may change.</p>
<h2 id="return">Return</h2>
<p>Returns list of edges where edges are tuples in (source,sink)
format.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def minimum_spanning_tree_kruskal(self, display = None, components = None):
    &#39;&#39;&#39;
    API: minimum_spanning_tree_kruskal(self, display = None,
                                       components = None)
    Description:
    Determines a minimum spanning tree using Kruskal&#39;s Algorithm.
    Input:
        display: Display method.
        component: component number.
    Post:
        &#39;color&#39; attribute of nodes and edges may change.
    Return:
        Returns list of edges where edges are tuples in (source,sink)
        format.
    &#39;&#39;&#39;
    if display == None:
        display = self.attr[&#39;display&#39;]
    else:
        self.set_display_mode(display)
    if components is None:
        components = DisjointSet(display = display, layout = &#39;dot&#39;,
                                 optimize = False)
    sorted_edge_list = sorted(self.get_edge_list(), key=self.get_edge_cost)
    edges = []
    for n in self.get_node_list():
        components.add([n])
    components.display()
    for e in sorted_edge_list:
        if len(edges) == len(self.get_node_list()) - 1:
            break
        self.set_edge_attr(e[0], e[1], &#39;color&#39;, &#39;yellow&#39;)
        self.display()
        if components.union(e[0], e[1]):
            self.set_edge_attr(e[0], e[1], &#39;color&#39;, &#39;green&#39;)
            self.display()
            edges.append(e)
        else:
            self.set_edge_attr(e[0], e[1], &#39;color&#39;, &#39;black&#39;)
            self.display()
        components.display()
    return edges</code></pre>
</details>
</dd>
<dt id="coinor.gimpy.graph.Graph.minimum_spanning_tree_prim"><code class="name flex">
<span>def <span class="ident">minimum_spanning_tree_prim</span></span>(<span>self, source, display=None, q=&lt;coinor.blimpy.Queues.PriorityQueue object&gt;)</span>
</code></dt>
<dd>
<div class="desc"><p>API: minimum_spanning_tree_prim(self, source, display = None,
q = PriorityQueue())
Description:
Determines a minimum spanning tree of all nodes reachable
from source using Prim's Algorithm.</p>
<h2 id="input">Input</h2>
<p>source: Name of source node.
display: Display method.
q: Data structure that holds nodes to be processed in a queue.</p>
<h2 id="post">Post</h2>
<p>'color', 'distance', 'component' attribute of nodes and edges may
change.</p>
<h2 id="return">Return</h2>
<p>Returns predecessor tree in dictionary format.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def minimum_spanning_tree_prim(self, source, display = None,
                               q = PriorityQueue()):
    &#39;&#39;&#39;
    API: minimum_spanning_tree_prim(self, source, display = None,
                                    q = PriorityQueue())
    Description:
    Determines a minimum spanning tree of all nodes reachable
    from source using Prim&#39;s Algorithm.
    Input:
        source: Name of source node.
        display: Display method.
        q: Data structure that holds nodes to be processed in a queue.
    Post:
        &#39;color&#39;, &#39;distance&#39;, &#39;component&#39; attribute of nodes and edges may
        change.
    Return:
        Returns predecessor tree in dictionary format.
    &#39;&#39;&#39;
    if display == None:
        display = self.attr[&#39;display&#39;]
    else:
        self.set_display_mode(display)
    if isinstance(q, PriorityQueue):
        addToQ = q.push
        removeFromQ = q.pop
        peek = q.peek
        isEmpty = q.isEmpty
    neighbors = self.get_neighbors
    pred = {}
    addToQ(source)
    done = False
    while not isEmpty() and not done:
        current = removeFromQ()
        self.set_node_attr(current, &#39;color&#39;, &#39;blue&#39;)
        if current != source:
            self.set_edge_attr(pred[current], current, &#39;color&#39;, &#39;green&#39;)
        self.display()
        for n in neighbors(current):
            if self.get_node_attr(n, &#39;color&#39;) != &#39;green&#39;:
                self.set_edge_attr(current, n, &#39;color&#39;, &#39;yellow&#39;)
                self.display()
                new_estimate = self.get_edge_attr(current, n, &#39;cost&#39;)
                if not n in pred or new_estimate &lt; peek(n)[0]:
                    pred[n] = current
                    self.set_node_attr(n, &#39;color&#39;, &#39;red&#39;)
                    self.set_node_attr(n, &#39;label&#39;, new_estimate)
                    addToQ(n, new_estimate)
                    self.display()
                    self.set_node_attr(n, &#39;color&#39;, &#39;black&#39;)
                self.set_edge_attr(current, n, &#39;color&#39;, &#39;black&#39;)
        self.set_node_attr(current, &#39;color&#39;, &#39;green&#39;)
        self.display()
    return pred</code></pre>
</details>
</dd>
<dt id="coinor.gimpy.graph.Graph.network_simplex"><code class="name flex">
<span>def <span class="ident">network_simplex</span></span>(<span>self, display, pivot, root)</span>
</code></dt>
<dd>
<div class="desc"><h2 id="api">Api</h2>
<p>network_simplex(self, display, pivot, root)</p>
<h2 id="description">Description</h2>
<p>Solves minimum cost feasible flow problem using network simplex
algorithm. It is recommended to use min_cost_flow(algo='simplex')
instead of using network_simplex() directly. Returns True when an
optimal solution is found, returns False otherwise. 'flow' attribute
values of arcs should be considered as junk when returned False.</p>
<h2 id="pre">Pre</h2>
<p>(1) check Pre section of min_cost_flow()</p>
<h2 id="input">Input</h2>
<p>pivot: specifies pivot rule. Check min_cost_flow()
display: 'off' for no display, 'matplotlib' for live update of
spanning tree.
root: Root node for the underlying spanning trees that will be
generated by network simplex algorthm.</p>
<h2 id="post">Post</h2>
<p>(1) Changes 'flow' attribute of edges.</p>
<h2 id="return">Return</h2>
<p>Returns True when an optimal solution is found, returns
False otherwise.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def network_simplex(self, display, pivot, root):
    &#39;&#39;&#39;
    API:
        network_simplex(self, display, pivot, root)
    Description:
        Solves minimum cost feasible flow problem using network simplex
        algorithm. It is recommended to use min_cost_flow(algo=&#39;simplex&#39;)
        instead of using network_simplex() directly. Returns True when an
        optimal solution is found, returns False otherwise. &#39;flow&#39; attribute
        values of arcs should be considered as junk when returned False.
    Pre:
        (1) check Pre section of min_cost_flow()
    Input:
        pivot: specifies pivot rule. Check min_cost_flow()
        display: &#39;off&#39; for no display, &#39;matplotlib&#39; for live update of
        spanning tree.
        root: Root node for the underlying spanning trees that will be
        generated by network simplex algorthm.
    Post:
        (1) Changes &#39;flow&#39; attribute of edges.
    Return:
        Returns True when an optimal solution is found, returns
        False otherwise.
    &#39;&#39;&#39;
    # ==== determine an initial tree structure (T,L,U)
    # find a feasible flow
    if not self.find_feasible_flow():
        return False
    t = self.simplex_find_tree()
    self.set_display_mode(display)
    # mark spanning tree arcs
    self.simplex_mark_st_arcs(t)
    # display initial spanning tree
    t.simplex_redraw(display, root)
    t.set_display_mode(display)
    #t.display()
    self.display()
    # set predecessor, depth and thread indexes
    t.simplex_search(root, 1)
    # compute potentials
    self.simplex_compute_potentials(t, root)
    # while some nontree arc violates optimality conditions
    while not self.simplex_optimal(t):
        self.display()
        # select an entering arc (k,l)
        (k,l) = self.simplex_select_entering_arc(t, pivot)
        self.simplex_mark_entering_arc(k, l)
        self.display()
        # determine leaving arc
        ((p,q), capacity, cycle)=self.simplex_determine_leaving_arc(t,k,l)
        # mark leaving arc
        self.simplex_mark_leaving_arc(p, q)
        self.display()
        self.simplex_remove_arc(t, p, q, capacity, cycle)
        # display after arc removed
        self.display()
        self.simplex_mark_st_arcs(t)
        self.display()
        # set predecessor, depth and thread indexes
        t.simplex_redraw(display, root)
        #t.display()
        t.simplex_search(root, 1)
        # compute potentials
        self.simplex_compute_potentials(t, root)
    return True</code></pre>
</details>
</dd>
<dt id="coinor.gimpy.graph.Graph.page_rank"><code class="name flex">
<span>def <span class="ident">page_rank</span></span>(<span>self, damping_factor=0.85, max_iterations=100, min_delta=1e-05)</span>
</code></dt>
<dd>
<div class="desc"><h2 id="api">Api</h2>
<p>page_rank(self, damping_factor=0.85, max_iterations=100,
min_delta=0.00001)</p>
<h2 id="description">Description</h2>
<p>Compute and return the page-rank of a directed graph.
This function was originally taken from here and modified for this
graph class: <a href="http://code.google.com/p/python-graph/source/browse/">http://code.google.com/p/python-graph/source/browse/</a>
trunk/core/pygraph/algorithms/pagerank.py</p>
<h2 id="input">Input</h2>
<p>damping_factor: Damping factor.
max_iterations: Maximum number of iterations.
min_delta: Smallest variation required to have a new iteration.</p>
<h2 id="pre">Pre</h2>
<p>Graph should be a directed graph.</p>
<h2 id="return">Return</h2>
<p>Returns dictionary of page-ranks. Keys are node names, values are
corresponding page-ranks.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def page_rank(self, damping_factor=0.85, max_iterations=100,
              min_delta=0.00001):
    &#39;&#39;&#39;
    API:
        page_rank(self, damping_factor=0.85, max_iterations=100,
              min_delta=0.00001)
    Description:
        Compute and return the page-rank of a directed graph.
        This function was originally taken from here and modified for this
        graph class: http://code.google.com/p/python-graph/source/browse/
        trunk/core/pygraph/algorithms/pagerank.py
    Input:
        damping_factor: Damping factor.
        max_iterations: Maximum number of iterations.
        min_delta: Smallest variation required to have a new iteration.
    Pre:
        Graph should be a directed graph.
    Return:
        Returns dictionary of page-ranks. Keys are node names, values are
        corresponding page-ranks.
    &#39;&#39;&#39;
    nodes = self.get_node_list()
    graph_size = len(nodes)
    if graph_size == 0:
        return {}
    #value for nodes without inbound links
    min_value = old_div((1.0-damping_factor),graph_size)
    # itialize the page rank dict with 1/N for all nodes
    pagerank = dict.fromkeys(nodes, old_div(1.0,graph_size))
    for _ in range(max_iterations):
        diff = 0 #total difference compared to last iteraction
        # computes each node PageRank based on inbound links
        for node in nodes:
            rank = min_value
            for referring_page in self.get_in_neighbors(node):
                rank += (damping_factor * pagerank[referring_page] /
                         len(self.get_neighbors(referring_page)))
            diff += abs(pagerank[node] - rank)
            pagerank[node] = rank
        #stop if PageRank has converged
        if diff &lt; min_delta:
            break
    return pagerank</code></pre>
</details>
</dd>
<dt id="coinor.gimpy.graph.Graph.print_flow"><code class="name flex">
<span>def <span class="ident">print_flow</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><h2 id="api">Api</h2>
<p>print_flow(self)</p>
<h2 id="description">Description</h2>
<p>Prints all positive flows to stdout. This method can be used for
debugging purposes.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def print_flow(self):
    &#39;&#39;&#39;
    API:
        print_flow(self)
    Description:
        Prints all positive flows to stdout. This method can be used for
        debugging purposes.
    &#39;&#39;&#39;
    print(&#39;printing current edge, flow, capacity&#39;)
    for e in self.edge_attr:
        if self.edge_attr[e][&#39;flow&#39;]!=0:
            print(e, str(self.edge_attr[e][&#39;flow&#39;]).ljust(4), end=&#39; &#39;)
            print(str(self.edge_attr[e][&#39;capacity&#39;]).ljust(4))</code></pre>
</details>
</dd>
<dt id="coinor.gimpy.graph.Graph.process_edge_dijkstra"><code class="name flex">
<span>def <span class="ident">process_edge_dijkstra</span></span>(<span>self, current, neighbor, pred, q, component)</span>
</code></dt>
<dd>
<div class="desc"><p>API: process_edge_dijkstra(self, current, neighbor, pred, q, component)
Description:
Used by search() method if the algo argument is 'Dijkstra'. Processes
edges along Dijkstra's algorithm. User does not need to call this
method directly.</p>
<h2 id="input">Input</h2>
<p>current: Name of the current node.
neighbor: Name of the neighbor node.
pred: Predecessor tree.
q: Data structure that holds nodes to be processed in a queue.
component: component number.</p>
<h2 id="post">Post</h2>
<p>'color' attribute of nodes and edges may change.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def process_edge_dijkstra(self, current, neighbor, pred, q, component):
    &#39;&#39;&#39;
    API: process_edge_dijkstra(self, current, neighbor, pred, q, component)
    Description:
    Used by search() method if the algo argument is &#39;Dijkstra&#39;. Processes
    edges along Dijkstra&#39;s algorithm. User does not need to call this
    method directly.
    Input:
        current: Name of the current node.
        neighbor: Name of the neighbor node.
        pred: Predecessor tree.
        q: Data structure that holds nodes to be processed in a queue.
        component: component number.
    Post:
        &#39;color&#39; attribute of nodes and edges may change.
    &#39;&#39;&#39;
    if current is None:
        self.get_node(neighbor).set_attr(&#39;color&#39;, &#39;red&#39;)
        self.get_node(neighbor).set_attr(&#39;label&#39;, 0)
        q.push(neighbor, 0)
        self.display()
        self.get_node(neighbor).set_attr(&#39;color&#39;, &#39;black&#39;)
        return
    new_estimate = (q.get_priority(current) +
                    self.get_edge_attr(current, neighbor, &#39;cost&#39;))
    if neighbor not in pred or new_estimate &lt; q.get_priority(neighbor):
        pred[neighbor] = current
        self.get_node(neighbor).set_attr(&#39;color&#39;, &#39;red&#39;)
        self.get_node(neighbor).set_attr(&#39;label&#39;, new_estimate)
        q.push(neighbor, new_estimate)
        self.display()
        self.get_node(neighbor).set_attr(&#39;color&#39;, &#39;black&#39;)</code></pre>
</details>
</dd>
<dt id="coinor.gimpy.graph.Graph.process_edge_flow"><code class="name flex">
<span>def <span class="ident">process_edge_flow</span></span>(<span>self, source, sink, i, j, algo, q)</span>
</code></dt>
<dd>
<div class="desc"><p>API: process_edge_flow(self, source, sink, i, j, algo, q)
Description:
Used by by max_flow_preflowpush() method. Processes edges along
prefolow push.</p>
<h2 id="input">Input</h2>
<p>source: Source node name of flow graph.
sink: Sink node name of flow graph.
i: Source node in the processed edge (tail of arc).
j: Sink node in the processed edge (head of arc).</p>
<h2 id="post">Post</h2>
<p>The 'flow' and 'excess' attributes of nodes may get updated.</p>
<h2 id="return">Return</h2>
<p>Returns False if residual capacity is 0, True otherwise.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def process_edge_flow(self, source, sink, i, j, algo, q):
    &#39;&#39;&#39;
    API: process_edge_flow(self, source, sink, i, j, algo, q)
    Description:
    Used by by max_flow_preflowpush() method. Processes edges along
    prefolow push.
    Input:
        source: Source node name of flow graph.
        sink: Sink node name of flow graph.
        i: Source node in the processed edge (tail of arc).
        j: Sink node in the processed edge (head of arc).
    Post:
        The &#39;flow&#39; and &#39;excess&#39; attributes of nodes may get updated.
    Return:
        Returns False if residual capacity is 0, True otherwise.
    &#39;&#39;&#39;
    if (self.get_node_attr(i, &#39;distance&#39;) !=
        self.get_node_attr(j, &#39;distance&#39;) + 1):
        return False
    if (i, j) in self.edge_attr:
        edge = (i, j)
        capacity = self.get_edge_attr(i, j, &#39;capacity&#39;)
        mult = 1
    else:
        edge = (j, i)
        capacity = 0
        mult = -1
    flow = mult*self.edge_attr[edge][&#39;flow&#39;]
    residual_capacity = capacity - flow
    if residual_capacity == 0:
        return False
    excess_i = self.get_node_attr(i, &#39;excess&#39;)
    excess_j = self.get_node_attr(j, &#39;excess&#39;)
    push_amount = min(excess_i, residual_capacity)
    self.edge_attr[edge][&#39;flow&#39;] = mult*(flow + push_amount)
    self.set_node_attr(i, &#39;excess&#39;, excess_i - push_amount)
    self.set_node_attr(j, &#39;excess&#39;, excess_j + push_amount)
    return True</code></pre>
</details>
</dd>
<dt id="coinor.gimpy.graph.Graph.process_edge_prim"><code class="name flex">
<span>def <span class="ident">process_edge_prim</span></span>(<span>self, current, neighbor, pred, q, component)</span>
</code></dt>
<dd>
<div class="desc"><p>API: process_edge_prim(self, current, neighbor, pred, q, component)
Description:
Used by search() method if the algo argument is 'Prim'. Processes
edges along Prim's algorithm. User does not need to call this method
directly.</p>
<h2 id="input">Input</h2>
<p>current: Name of the current node.
neighbor: Name of the neighbor node.
pred: Predecessor tree.
q: Data structure that holds nodes to be processed in a queue.
component: component number.</p>
<h2 id="post">Post</h2>
<p>'color' attribute of nodes and edges may change.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def process_edge_prim(self, current, neighbor, pred, q, component):
    &#39;&#39;&#39;
    API: process_edge_prim(self, current, neighbor, pred, q, component)
    Description:
    Used by search() method if the algo argument is &#39;Prim&#39;. Processes
    edges along Prim&#39;s algorithm. User does not need to call this method
    directly.
    Input:
        current: Name of the current node.
        neighbor: Name of the neighbor node.
        pred: Predecessor tree.
        q: Data structure that holds nodes to be processed in a queue.
        component: component number.
    Post:
        &#39;color&#39; attribute of nodes and edges may change.
    &#39;&#39;&#39;
    if current is None:
        self.get_node(neighbor).set_attr(&#39;color&#39;, &#39;red&#39;)
        self.get_node(neighbor).set_attr(&#39;label&#39;, 0)
        q.push(neighbor, 0)
        self.display()
        self.get_node(neighbor).set_attr(&#39;color&#39;, &#39;black&#39;)
        return
    new_estimate = self.get_edge_attr(current, neighbor, &#39;cost&#39;)
    if not neighbor in pred or new_estimate &lt; q.get_priority(neighbor):
        pred[neighbor] = current
        self.get_node(neighbor).set_attr(&#39;color&#39;, &#39;red&#39;)
        self.get_node(neighbor).set_attr(&#39;label&#39;, new_estimate)
        q.push(neighbor, new_estimate)
        self.display()
        self.get_node(neighbor).set_attr(&#39;color&#39;, &#39;black&#39;)</code></pre>
</details>
</dd>
<dt id="coinor.gimpy.graph.Graph.process_edge_search"><code class="name flex">
<span>def <span class="ident">process_edge_search</span></span>(<span>self, current, neighbor, pred, q, component, algo, **kargs)</span>
</code></dt>
<dd>
<div class="desc"><p>API: process_edge_search(self, current, neighbor, pred, q, component,
algo, **kargs)
Description:
Used by search() method. Processes edges according to the underlying
algortihm. User does not need to call this method directly.</p>
<h2 id="input">Input</h2>
<p>current: Name of the current node.
neighbor: Name of the neighbor node.
pred: Predecessor tree.
q: Data structure that holds nodes to be processed in a queue.
component: component number.
algo: Search algorithm. See search() documentation.
kwargs: Keyword arguments.</p>
<h2 id="post">Post</h2>
<p>'color', 'distance', 'component' attribute of nodes and edges may
change.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def process_edge_search(self, current, neighbor, pred, q, component, algo,
                        **kargs):
    &#39;&#39;&#39;
    API: process_edge_search(self, current, neighbor, pred, q, component,
                             algo, **kargs)
    Description:
    Used by search() method. Processes edges according to the underlying
    algortihm. User does not need to call this method directly.
    Input:
        current: Name of the current node.
        neighbor: Name of the neighbor node.
        pred: Predecessor tree.
        q: Data structure that holds nodes to be processed in a queue.
        component: component number.
        algo: Search algorithm. See search() documentation.
        kwargs: Keyword arguments.
    Post:
        &#39;color&#39;, &#39;distance&#39;, &#39;component&#39; attribute of nodes and edges may
        change.
    &#39;&#39;&#39;
    if algo == &#39;Dijkstra&#39;:
        return self.process_edge_dijkstra(current, neighbor, pred, q,
                                          component)
    if algo == &#39;Prim&#39;:
        return self.process_edge_prim(current, neighbor, pred, q,
                                      component)
    neighbor_node = self.get_node(neighbor)
    if current == None:
        neighbor_node.set_attr(&#39;distance&#39;, 0)
        if isinstance(q, PriorityQueue):
            q.push(neighbor, 0)
        else:
            q.push(neighbor)
        if component != None:
            neighbor_node.set_attr(&#39;component&#39;, component)
            neighbor_node.set_attr(&#39;label&#39;, component)
        else:
            neighbor_node.set_attr(&#39;label&#39;, 0)
        return
    if isinstance(q, PriorityQueue):
        current_priority = q.get_priority(neighbor)
        if algo == &#39;UnweightedSPT&#39; or algo == &#39;BFS&#39;:
            priority = self.get_node(current).get_attr(&#39;distance&#39;) + 1
        if algo == &#39;DFS&#39;:
            priority = -self.get_node(current).get_attr(&#39;distance&#39;) - 1
        if current_priority is not None and priority &gt;= current_priority:
            return
        q.push(neighbor, priority)
        if algo == &#39;UnweightedSPT&#39; or algo == &#39;BFS&#39;:
            neighbor_node.set_attr(&#39;distance&#39;, priority)
        if algo == &#39;DFS&#39;:
            neighbor_node.set_attr(&#39;depth&#39;, -priority)
    else:
        distance = self.get_node(current).get_attr(&#39;distance&#39;) + 1
        if ((algo == &#39;UnweightedSPT&#39; or algo == &#39;BFS&#39;) and
            neighbor_node.get_attr(&#39;distance&#39;) is not None):
            return
        neighbor_node.set_attr(&#39;distance&#39;, distance)
        neighbor_node.set_attr(&#39;label&#39;, str(distance))
        q.push(neighbor)
    pred[neighbor] = current
    neighbor_node.set_attr(&#39;color&#39;, &#39;red&#39;)
    if component != None:
        neighbor_node.set_attr(&#39;component&#39;, component)
        neighbor_node.set_attr(&#39;label&#39;, component)
    self.display()</code></pre>
</details>
</dd>
<dt id="coinor.gimpy.graph.Graph.process_node_search"><code class="name flex">
<span>def <span class="ident">process_node_search</span></span>(<span>self, node, q, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>API: process_node_search(self, node, q, **kwargs)
Description:
Used by search() method. Process nodes along the search. Should not be
called by user directly.</p>
<h2 id="input">Input</h2>
<p>node: Name of the node being processed.
q: Queue data structure.
kwargs: Keyword arguments.</p>
<h2 id="post">Post</h2>
<p>'priority' attribute of the node may get updated.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def process_node_search(self, node, q, **kwargs):
    &#39;&#39;&#39;
    API: process_node_search(self, node, q, **kwargs)
    Description:
    Used by search() method. Process nodes along the search. Should not be
    called by user directly.
    Input:
        node: Name of the node being processed.
        q: Queue data structure.
        kwargs: Keyword arguments.
    Post:
        &#39;priority&#39; attribute of the node may get updated.
    &#39;&#39;&#39;
    if isinstance(q, PriorityQueue):
        self.get_node(node).set_attr(&#39;priority&#39;, q.get_priority(node))</code></pre>
</details>
</dd>
<dt id="coinor.gimpy.graph.Graph.random"><code class="name flex">
<span>def <span class="ident">random</span></span>(<span>self, numnodes=10, degree_range=(2, 4), length_range=(1, 10), density=None, edge_format=None, node_format=None, Euclidean=False, seedInput=0, add_labels=True, parallel_allowed=False, node_selection='closest', scale=10, scale_cost=5)</span>
</code></dt>
<dd>
<div class="desc"><h2 id="api">Api</h2>
<p>random(self, numnodes = 10, degree_range = None, length_range = None,
density = None, edge_format = None, node_format = None,
Euclidean = False, seedInput = 0)</p>
<h2 id="description">Description</h2>
<p>Populates graph with random edges and nodes.</p>
<h2 id="input">Input</h2>
<p>numnodes: Number of nodes to add.
degree_range: A tuple that has lower and upper bounds of degree for
a node.
length_range: A tuple that has lower and upper bounds for 'cost'
attribute of edges.
density: Density of edges, ie. 0.5 indicates a node will
approximately have edge to half of the other nodes.
edge_format: Dictionary that specifies attribute values for edges.
node_format: Dictionary that specifies attribute values for nodes.
Euclidean: Creates an Euclidean graph (Euclidean distance between
nodes) if True.
seedInput: Seed that will be used for random number generation.</p>
<h2 id="pre">Pre</h2>
<p>It is recommended to call this method on empty Graph objects.</p>
<h2 id="post">Post</h2>
<p>Graph will be populated by nodes and edges.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def random(self, numnodes = 10, degree_range = (2, 4), length_range = (1, 10),
           density = None, edge_format = None, node_format = None,
           Euclidean = False, seedInput = 0, add_labels = True,
           parallel_allowed = False, node_selection = &#39;closest&#39;,
           scale = 10, scale_cost = 5):
    &#39;&#39;&#39;
    API:
        random(self, numnodes = 10, degree_range = None, length_range = None,
           density = None, edge_format = None, node_format = None,
           Euclidean = False, seedInput = 0)
    Description:
        Populates graph with random edges and nodes.
    Input:
        numnodes: Number of nodes to add.
        degree_range: A tuple that has lower and upper bounds of degree for
        a node.
        length_range: A tuple that has lower and upper bounds for &#39;cost&#39;
        attribute of edges.
        density: Density of edges, ie. 0.5 indicates a node will
        approximately have edge to half of the other nodes.
        edge_format: Dictionary that specifies attribute values for edges.
        node_format: Dictionary that specifies attribute values for nodes.
        Euclidean: Creates an Euclidean graph (Euclidean distance between
        nodes) if True.
        seedInput: Seed that will be used for random number generation.
    Pre:
        It is recommended to call this method on empty Graph objects.
    Post:
        Graph will be populated by nodes and edges.
    &#39;&#39;&#39;
    random.seed(seedInput)
    if edge_format == None:
        edge_format = {&#39;fontsize&#39;:10,
                       &#39;fontcolor&#39;:&#39;blue&#39;}
    if node_format == None:
        node_format = {&#39;height&#39;:0.5,
                       &#39;width&#39;:0.5,
                       &#39;fixedsize&#39;:&#39;true&#39;,
                       &#39;fontsize&#39;:10,
                       &#39;fontcolor&#39;:&#39;red&#39;,
                       &#39;shape&#39;:&#39;circle&#39;,
                       }
    if Euclidean == False:
        for m in range(numnodes):
            self.add_node(m, **node_format)
        if degree_range is not None and density is None:
            for m in range(numnodes):
                degree = random.randint(degree_range[0], degree_range[1])
                i = 0
                while i &lt; degree:
                    n = random.randint(1, numnodes-1)
                    if (((m,n) not in self.edge_attr and m != n) and
                        (parallel_allowed or (n, m) not in self.edge_attr)):
                        if length_range is not None:
                            length = random.randint(length_range[0],
                                                    length_range[1])
                            self.add_edge(m, n, cost = length, **edge_format)
                            if add_labels:
                                self.set_edge_attr(m, n, &#39;label&#39;, str(length))
                            else:
                                self.add_edge(m, n, **edge_format)
                    i += 1
        elif density != None:
            for m in range(numnodes):
                if self.graph_type == DIRECTED_GRAPH:
                    numnodes2 = numnodes
                else:
                    numnodes2 = m
                for n in range(numnodes2):
                    if ((parallel_allowed or (n, m) not in self.edge_attr)
                        and m != n):
                        if random.random() &lt; density:
                            if length_range is not None:
                                length = random.randint(length_range[0],
                                                 length_range[1])
                                self.add_edge(m, n, cost = length,
                                              **edge_format)
                                if add_labels:
                                    self.set_edge_attr(m, n, &#39;label&#39;, str(length))
                            else:
                                self.add_edge(m, n, **edge_format)
        else:
            print(&#34;Must set either degree range or density&#34;)
    else:
        for m in range(numnodes):
            &#39;&#39;&#39; Assigns random coordinates (between 1 and 20) to the nodes
            &#39;&#39;&#39;
            x = random.random()*scale
            y = random.random()*scale
            self.add_node(m, locationx = x, locationy = y,
                          pos = &#39;&#34;&#39;+str(x) + &#34;,&#34; + str(y)+&#39;!&#34;&#39;,
                          **node_format)
        if degree_range is not None and density is None:
            for m in range(numnodes):
                degree = random.randint(degree_range[0], degree_range[1])
                i = 0
                neighbors = []
                if node_selection == &#39;random&#39;:
                    while i &lt; degree:
                        length = round((((self.get_node(n).get_attr(&#39;locationx&#39;) -
                                          self.get_node(m).get_attr(&#39;locationx&#39;)) ** 2 +
                                         (self.get_node(n).get_attr(&#39;locationy&#39;) -
                                          self.get_node(m).get_attr(&#39;locationy&#39;)) ** 2) ** 0.5)*scale_cost,
                                       0)
                        if (((m,n) not in self.edge_attr and m != n) and
                            (parallel_allowed or (n, m) not in self.edge_attr)):
                            neighbors.append(random.randint(0, numnodes-1))
                            self.add_edge(m, n, cost = int(length), **edge_format)
                            if add_labels:
                                self.set_edge_attr(m, n, &#39;label&#39;, str(int(length)))
                            i += 1
                elif node_selection == &#39;closest&#39;:
                    lengths = []
                    for n in range(numnodes):
                        lengths.append((n, round((((self.get_node(n).get_attr(&#39;locationx&#39;) -
                                                    self.get_node(m).get_attr(&#39;locationx&#39;)) ** 2 +
                                                   (self.get_node(n).get_attr(&#39;locationy&#39;) -
                                                    self.get_node(m).get_attr(&#39;locationy&#39;)) ** 2) ** 0.5)*scale_cost,
                                                 0)))
                    lengths.sort(key = lambda l : l[1])
                    for i in range(degree+1):
                        if not (lengths[i][0] == m or self.check_edge(m, lengths[i][0])):
                            self.add_edge(m, lengths[i][0], cost = int(lengths[i][1]), **edge_format)
                            if add_labels:
                                self.set_edge_attr(m, lengths[i][0], &#39;label&#39;, str(int(lengths[i][1])))
                else:
                    print(&#34;Unknown node selection rule...exiting&#34;)
                    return
        elif density != None:
            for m in range(numnodes):
                if self.graph_type == DIRECTED_GRAPH:
                    numnodes2 = numnodes
                else:
                    numnodes2 = m
                for n in range(numnodes2):
                    if ((parallel_allowed or (n, m) not in self.edge_attr)
                        and m != n):
                        if random.random() &lt; density:
                            if length_range is None:
                                &#39;&#39;&#39; calculates the euclidean norm and round it
                                to an integer &#39;&#39;&#39;
                                length = round((((self.get_node(n).get_attr(&#39;locationx&#39;) -
                                                  self.get_node(m).get_attr(&#39;locationx&#39;)) ** 2 +
                                                 (self.get_node(n).get_attr(&#39;locationy&#39;) -
                                                  self.get_node(m).get_attr(&#39;locationy&#39;)) ** 2) ** 0.5), 0)
                                self.add_edge(m, n, cost = int(length), **edge_format)
                                if add_labels:
                                    self.set_edge_attr(m, n, &#39;label&#39;, str(int(length)))
                            else:
                                self.add_edge(m, n, **edge_format)
        else:
            print(&#34;Must set either degree range or density&#34;)</code></pre>
</details>
</dd>
<dt id="coinor.gimpy.graph.Graph.relabel"><code class="name flex">
<span>def <span class="ident">relabel</span></span>(<span>self, i)</span>
</code></dt>
<dd>
<div class="desc"><p>API: relabel(self, i)
Description:
Used by max_flow_preflowpush() method for relabelling node i.</p>
<h2 id="input">Input</h2>
<p>i: Node that is being relabelled.</p>
<h2 id="post">Post</h2>
<p>'distance' attribute of node i is updated.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def relabel(self, i):
    &#39;&#39;&#39;
    API: relabel(self, i)
    Description:
    Used by max_flow_preflowpush() method for relabelling node i.
    Input:
        i: Node that is being relabelled.
    Post:
        &#39;distance&#39; attribute of node i is updated.
    &#39;&#39;&#39;
    min_distance = 2*len(self.get_node_list()) + 1
    for j in self.get_neighbors(i):
        if (self.get_node_attr(j, &#39;distance&#39;) &lt; min_distance and
            (self.get_edge_attr(i, j, &#39;flow&#39;) &lt;
             self.get_edge_attr(i, j, &#39;capacity&#39;))):
            min_distance = self.get_node_attr(j, &#39;distance&#39;)
    for j in self.get_in_neighbors(i):
        if (self.get_node_attr(j, &#39;distance&#39;) &lt; min_distance and
            self.get_edge_attr(j, i, &#39;flow&#39;) &gt; 0):
            min_distance = self.get_node_attr(j, &#39;distance&#39;)
    self.set_node_attr(i, &#39;distance&#39;, min_distance + 1)</code></pre>
</details>
</dd>
<dt id="coinor.gimpy.graph.Graph.search"><code class="name flex">
<span>def <span class="ident">search</span></span>(<span>self, source, destination=None, display=None, component=None, q=None, algo='DFS', reverse=False, **kargs)</span>
</code></dt>
<dd>
<div class="desc"><p>API: search(self, source, destination = None, display = None,
component = None, q = Stack(),
algo = 'DFS', reverse = False, **kargs)
Description:
Generic search method. Changes behavior (dfs,bfs,dijkstra,prim)
according to algo argument.
if destination is not specified:
This method determines all nodes reachable from "source" ie. creates
precedence tree and returns it (dictionary).
if destionation is given:
If there exists a path from "source" to "destination" it will return
list of the nodes is this path. If there is no such path, it will
return the precedence tree constructed from source (dictionary).
Optionally, it marks all nodes reachable from "source" with a component
number. The variable "q" determines the order in which the nodes are
searched.</p>
<h2 id="input">Input</h2>
<p>source: Search starts from node with this name.
destination: Destination node name.
display: Display method.
algo: Algortihm that specifies search. Available algortihms are
'DFS', 'BFS', 'Dijkstra' and 'Prim'.
reverse: Search goes in reverse arc directions if True.
kargs: Additional keyword arguments.</p>
<h2 id="post">Post</h2>
<p>Nodes will have 'component' attribute that will have component
number as value (if component argument provided). Color attribute
of nodes and edges may change.</p>
<h2 id="return">Return</h2>
<p>Returns predecessor tree in dictionary form if destination is
not specified, returns list of node names in the path from source
to destionation if destionation is specified and there is a path.
If there is no path returns predecessor tree in dictionary form.
See description section.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def search(self, source, destination = None, display = None,
           component = None, q = None,
           algo = &#39;DFS&#39;, reverse = False, **kargs):
    &#39;&#39;&#39;
    API: search(self, source, destination = None, display = None,
           component = None, q = Stack(),
           algo = &#39;DFS&#39;, reverse = False, **kargs)
    Description:
    Generic search method. Changes behavior (dfs,bfs,dijkstra,prim)
    according to algo argument.
    if destination is not specified:
       This method determines all nodes reachable from &#34;source&#34; ie. creates
       precedence tree and returns it (dictionary).
    if destionation is given:
       If there exists a path from &#34;source&#34; to &#34;destination&#34; it will return
       list of the nodes is this path. If there is no such path, it will
       return the precedence tree constructed from source (dictionary).
    Optionally, it marks all nodes reachable from &#34;source&#34; with a component
    number. The variable &#34;q&#34; determines the order in which the nodes are
    searched.
    Input:
        source: Search starts from node with this name.
        destination: Destination node name.
        display: Display method.
        algo: Algortihm that specifies search. Available algortihms are
        &#39;DFS&#39;, &#39;BFS&#39;, &#39;Dijkstra&#39; and &#39;Prim&#39;.
        reverse: Search goes in reverse arc directions if True.
        kargs: Additional keyword arguments.
    Post:
        Nodes will have &#39;component&#39; attribute that will have component
        number as value (if component argument provided). Color attribute
        of nodes and edges may change.
    Return:
        Returns predecessor tree in dictionary form if destination is
        not specified, returns list of node names in the path from source
        to destionation if destionation is specified and there is a path.
        If there is no path returns predecessor tree in dictionary form.
        See description section.
    &#39;&#39;&#39;
    if display == None:
        display = self.attr[&#39;display&#39;]
    else:
        self.set_display_mode(display)
    if algo == &#39;DFS&#39;:
        if q is None:
            q = Stack()
        self.get_node(source).set_attr(&#39;component&#39;, component)
    elif algo == &#39;BFS&#39; or algo == &#39;UnweightedSPT&#39;:
        if q is None:
            q = Queue()
        self.get_node(source).set_attr(&#39;component&#39;, component)
    elif algo == &#39;Dijkstra&#39; or algo == &#39;Prim&#39;:
        if q is None:
            q = PriorityQueue()
    else:
        print(&#34;Unknown search algorithm...exiting&#34;)
        return
    neighbors = self.neighbors
    if self.graph_type == DIRECTED_GRAPH and reverse:
        neighbors = self.in_neighbors
    for i in self.get_node_list():
        self.get_node(i).set_attr(&#39;label&#39;, &#39;-&#39;)
        self.get_node(i).attr.pop(&#39;priority&#39;, None)
        self.get_node(i).set_attr(&#39;distance&#39;, None)
        self.get_node(i).set_attr(&#39;color&#39;, &#39;black&#39;)
        for j in neighbors[i]:
            if reverse:
                self.set_edge_attr(j, i, &#39;color&#39;, &#39;black&#39;)
            else:
                self.set_edge_attr(i, j, &#39;color&#39;, &#39;black&#39;)
    self.display()
    pred = {}
    self.process_edge_search(None, source, pred, q, component, algo,
                             **kargs)
    found = True
    if source != destination:
        found = False
    while not q.isEmpty() and not found:
        current = q.peek()
        if self.get_node(current).get_attr(&#39;color&#39;) == &#39;green&#39;:
            q.remove(current)
            continue
        self.process_node_search(current, q, **kargs)
        self.get_node(current).set_attr(&#39;color&#39;, &#39;blue&#39;)
        if current != source:
            if reverse:
                self.set_edge_attr(current, pred[current], &#39;color&#39;, &#39;green&#39;)
            else:
                self.set_edge_attr(pred[current], current, &#39;color&#39;, &#39;green&#39;)
        if current == destination:
            found = True
            break
        self.display()
        for n in neighbors[current]:
            if self.get_node(n).get_attr(&#39;color&#39;) != &#39;green&#39;:
                if reverse:
                    self.set_edge_attr(n, current, &#39;color&#39;, &#39;yellow&#39;)
                else:
                    self.set_edge_attr(current, n, &#39;color&#39;, &#39;yellow&#39;)
                self.display()
                self.process_edge_search(current, n, pred, q, component,
                                         algo, **kargs)
                if reverse:
                    self.set_edge_attr(n, current, &#39;color&#39;, &#39;black&#39;)
                else:
                    self.set_edge_attr(current, n, &#39;color&#39;, &#39;black&#39;)
        q.remove(current)
        self.get_node(current).set_attr(&#39;color&#39;, &#39;green&#39;)
        self.display()
    if found:
        path = [destination]
        current = destination
        while current != source:
            path.insert(0, pred[current])
            current = pred[current]
        return path
    if destination == None:
        return pred
    else:
        return None</code></pre>
</details>
</dd>
<dt id="coinor.gimpy.graph.Graph.set_display_mode"><code class="name flex">
<span>def <span class="ident">set_display_mode</span></span>(<span>self, value)</span>
</code></dt>
<dd>
<div class="desc"><h2 id="api">Api</h2>
<p>set_display_mode(self, value)</p>
<h2 id="description">Description</h2>
<p>Sets display mode to value.</p>
<h2 id="input">Input</h2>
<p>value: New display mode.</p>
<h2 id="post">Post</h2>
<p>Display mode attribute of graph is updated.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_display_mode(self, value):
    &#39;&#39;&#39;
    API:
        set_display_mode(self, value)
    Description:
        Sets display mode to value.
    Input:
        value: New display mode.
    Post:
        Display mode attribute of graph is updated.
    &#39;&#39;&#39;
    self.attr[&#39;display&#39;] = value</code></pre>
</details>
</dd>
<dt id="coinor.gimpy.graph.Graph.set_edge_attr"><code class="name flex">
<span>def <span class="ident">set_edge_attr</span></span>(<span>self, n, m, attr, value)</span>
</code></dt>
<dd>
<div class="desc"><p>API: set_edge_attr(self, n, m, attr, value)
Description:
Sets attr attribute of edge (n,m) to value.</p>
<h2 id="input">Input</h2>
<p>n: Source node name.
m: Sink node name.
attr: Attribute of edge to set.
value: New value of attribute.</p>
<h2 id="pre">Pre</h2>
<p>Graph should have this edge.</p>
<h2 id="post">Post</h2>
<p>Edge attribute will be updated.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_edge_attr(self, n, m, attr, value):
    &#39;&#39;&#39;
    API: set_edge_attr(self, n, m, attr, value)
    Description:
    Sets attr attribute of edge (n,m) to value.
    Input:
        n: Source node name.
        m: Sink node name.
        attr: Attribute of edge to set.
        value: New value of attribute.
    Pre:
        Graph should have this edge.
    Post:
        Edge attribute will be updated.
    &#39;&#39;&#39;
    if self.graph_type is DIRECTED_GRAPH:
        self.edge_attr[(n,m)][attr] = value
    else:
        try:
            self.edge_attr[(n,m)][attr] = value
        except KeyError:
            self.edge_attr[(m,n)][attr] = value</code></pre>
</details>
</dd>
<dt id="coinor.gimpy.graph.Graph.set_layout"><code class="name flex">
<span>def <span class="ident">set_layout</span></span>(<span>self, value)</span>
</code></dt>
<dd>
<div class="desc"><h2 id="api">Api</h2>
<p>set_layout(self, value)
Description:
Sets layout attribute of the graph to value.</p>
<h2 id="input">Input</h2>
<p>value: New value of the layout.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_layout(self, value):
    &#39;&#39;&#39;
    API:
        set_layout(self, value)
    Description:
    Sets layout attribute of the graph to value.
    Input:
        value: New value of the layout.
    &#39;&#39;&#39;
    self.attr[&#39;layout&#39;]=value
    if value == &#39;dot2tex&#39;:
        self.attr[&#39;d2tgraphstyle&#39;] = &#39;every text node part/.style={align=center}&#39;</code></pre>
</details>
</dd>
<dt id="coinor.gimpy.graph.Graph.set_node_attr"><code class="name flex">
<span>def <span class="ident">set_node_attr</span></span>(<span>self, name, attr, value)</span>
</code></dt>
<dd>
<div class="desc"><p>API: set_node_attr(self, name, attr)
Description:
Sets attr attribute of node named name to value.</p>
<h2 id="input">Input</h2>
<p>name: Name of node.
attr: Attribute of node to set.</p>
<h2 id="pre">Pre</h2>
<p>Graph should have this node.</p>
<h2 id="post">Post</h2>
<p>Node attribute will be updated.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_node_attr(self, name, attr, value):
    &#39;&#39;&#39;
    API: set_node_attr(self, name, attr)
    Description:
    Sets attr attribute of node named name to value.
    Input:
        name: Name of node.
        attr: Attribute of node to set.
    Pre:
        Graph should have this node.
    Post:
        Node attribute will be updated.
    &#39;&#39;&#39;
    self.get_node(name).set_attr(attr, value)</code></pre>
</details>
</dd>
<dt id="coinor.gimpy.graph.Graph.show_flow"><code class="name flex">
<span>def <span class="ident">show_flow</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>API: relabel(self, i)
Description:
Used by max_flow_preflowpush() method for display purposed.</p>
<h2 id="post">Post</h2>
<p>'color' and 'label' attribute of edges/nodes are updated.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def show_flow(self):
    &#39;&#39;&#39;
    API: relabel(self, i)
    Description:
    Used by max_flow_preflowpush() method for display purposed.
    Post:
        &#39;color&#39; and &#39;label&#39; attribute of edges/nodes are updated.
    &#39;&#39;&#39;
    for n in self.get_node_list():
        excess = self.get_node_attr(n, &#39;excess&#39;)
        distance = self.get_node_attr(n, &#39;distance&#39;)
        self.set_node_attr(n, &#39;label&#39;, str(excess)+&#39;/&#39;+str(distance))
        for neighbor in self.get_neighbors(n):
            capacity = self.get_edge_attr(n, neighbor, &#39;capacity&#39;)
            flow = self.get_edge_attr(n, neighbor, &#39;flow&#39;)
            if capacity == INF:
                self.set_edge_attr(n, neighbor, &#39;label&#39;,
                                   &#39;INF&#39;+&#39;/&#39;+str(flow))
            else:
                self.set_edge_attr(n, neighbor, &#39;label&#39;,
                                   str(capacity)+&#39;/&#39;+str(flow))
            if capacity == flow:
                self.set_edge_attr(n, neighbor, &#39;color&#39;, &#39;red&#39;)
            elif flow &gt; 0:
                self.set_edge_attr(n, neighbor, &#39;color&#39;, &#39;green&#39;)
            else:
                self.set_edge_attr(n, neighbor, &#39;color&#39;, &#39;black&#39;)
    self.display()</code></pre>
</details>
</dd>
<dt id="coinor.gimpy.graph.Graph.simplex_augment_cycle"><code class="name flex">
<span>def <span class="ident">simplex_augment_cycle</span></span>(<span>self, cycle)</span>
</code></dt>
<dd>
<div class="desc"><h2 id="api">Api</h2>
<p>simplex_augment_cycle(self, cycle)</p>
<h2 id="description">Description</h2>
<p>Augments along the cycle to break it.</p>
<h2 id="pre">Pre</h2>
<p>'flow', 'capacity' attributes on arcs.</p>
<h2 id="input">Input</h2>
<p>cycle: list representing a cycle in the solution</p>
<h2 id="post">Post</h2>
<p>'flow' attribute will be modified.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def simplex_augment_cycle(self, cycle):
    &#39;&#39;&#39;
    API:
        simplex_augment_cycle(self, cycle)
    Description:
        Augments along the cycle to break it.
    Pre:
        &#39;flow&#39;, &#39;capacity&#39; attributes on arcs.
    Input:
        cycle: list representing a cycle in the solution
    Post:
        &#39;flow&#39; attribute will be modified.
    &#39;&#39;&#39;
    # find amount to augment
    index = 0
    k = len(cycle)
    el = list(self.edge_attr.keys())
    # check arc (cycle[k-1], cycle[0])
    if (cycle[k-1], cycle[0]) in el:
        min_capacity = self.edge_attr[(cycle[k-1], cycle[0])][&#39;capacity&#39;]-\
                          self.edge_attr[(cycle[k-1], cycle[0])][&#39;flow&#39;]
    else:
        min_capacity = self.edge_attr[(cycle[0], cycle[k-1])][&#39;flow&#39;]
    # check rest of the arcs in the cycle
    while index&lt;(k-1):
        i = cycle[index]
        j = cycle[index+1]
        if (i,j) in el:
            capacity_ij = self.edge_attr[(i,j)][&#39;capacity&#39;] -\
                          self.edge_attr[(i,j)][&#39;flow&#39;]
        else:
            capacity_ij = self.edge_attr[(j,i)][&#39;flow&#39;]
        if min_capacity &gt; capacity_ij:
            min_capacity = capacity_ij
        index += 1
    return min_capacity</code></pre>
</details>
</dd>
<dt id="coinor.gimpy.graph.Graph.simplex_compute_potentials"><code class="name flex">
<span>def <span class="ident">simplex_compute_potentials</span></span>(<span>self, t, root)</span>
</code></dt>
<dd>
<div class="desc"><h2 id="api">Api</h2>
<p>simplex_compute_potentials(self, t, root)</p>
<h2 id="description">Description</h2>
<p>Computes node potentials for a minimum cost flow problem and stores
them as node attribute 'potential'. Based on pseudocode given in
Network Flows by Ahuja et al.</p>
<h2 id="pre">Pre</h2>
<p>(1) Assumes a directed graph in which each arc has a 'cost'
attribute.
(2) Uses 'thread' and 'pred' attributes of nodes.</p>
<h2 id="input">Input</h2>
<p>t: Current spanning tree solution, its type is Graph.
root: root node of the tree.</p>
<h2 id="post">Post</h2>
<p>Keeps the node potentials as 'potential' attribute.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def simplex_compute_potentials(self, t, root):
    &#39;&#39;&#39;
    API:
        simplex_compute_potentials(self, t, root)
    Description:
        Computes node potentials for a minimum cost flow problem and stores
        them as node attribute &#39;potential&#39;. Based on pseudocode given in
        Network Flows by Ahuja et al.
    Pre:
        (1) Assumes a directed graph in which each arc has a &#39;cost&#39;
        attribute.
        (2) Uses &#39;thread&#39; and &#39;pred&#39; attributes of nodes.
    Input:
        t: Current spanning tree solution, its type is Graph.
        root: root node of the tree.
    Post:
        Keeps the node potentials as &#39;potential&#39; attribute.
    &#39;&#39;&#39;
    self.get_node(root).set_attr(&#39;potential&#39;, 0)
    j = t.get_node(root).get_attr(&#39;thread&#39;)
    while j is not root:
        i = t.get_node(j).get_attr(&#39;pred&#39;)
        potential_i = self.get_node(i).get_attr(&#39;potential&#39;)
        if (i,j) in self.edge_attr:
            c_ij = self.edge_attr[(i,j)][&#39;cost&#39;]
            self.get_node(j).set_attr(&#39;potential&#39;, potential_i-c_ij)
        if (j,i) in self.edge_attr:
            c_ji = self.edge_attr[(j,i)][&#39;cost&#39;]
            self.get_node(j).set_attr(&#39;potential&#39;, potential_i+c_ji)
        j = t.get_node(j).get_attr(&#39;thread&#39;)</code></pre>
</details>
</dd>
<dt id="coinor.gimpy.graph.Graph.simplex_connect"><code class="name flex">
<span>def <span class="ident">simplex_connect</span></span>(<span>self, solution_g)</span>
</code></dt>
<dd>
<div class="desc"><h2 id="api">Api</h2>
<p>simplex_connect(self, solution_g)</p>
<h2 id="description">Description</h2>
<p>At this point we assume that the solution does not have a cycle.
We check if all the nodes are connected, if not we add an arc to
solution_g that does not create a cycle and return True. Otherwise
we do nothing and return False.</p>
<h2 id="pre">Pre</h2>
<p>(1) We assume there is no cycle in the solution.</p>
<h2 id="input">Input</h2>
<p>solution_g: current spanning tree solution instance.</p>
<h2 id="post">Post</h2>
<p>(1) solution_g is updated. An arc that does not create a cycle is
added.
(2) 'component' attribute of nodes are changed.</p>
<h2 id="return">Return</h2>
<p>Returns True if an arc is added, returns False otherwise.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def simplex_connect(self, solution_g):
    &#39;&#39;&#39;
    API:
        simplex_connect(self, solution_g)
    Description:
        At this point we assume that the solution does not have a cycle.
        We check if all the nodes are connected, if not we add an arc to
        solution_g that does not create a cycle and return True. Otherwise
        we do nothing and return False.
    Pre:
        (1) We assume there is no cycle in the solution.
    Input:
        solution_g: current spanning tree solution instance.
    Post:
        (1) solution_g is updated. An arc that does not create a cycle is
        added.
        (2) &#39;component&#39; attribute of nodes are changed.
    Return:
        Returns True if an arc is added, returns False otherwise.
    &#39;&#39;&#39;
    nl = solution_g.get_node_list()
    current = nl[0]
    pred = solution_g.simplex_search(current, current)
    separated = list(pred.keys())
    for n in nl:
        if solution_g.get_node(n).get_attr(&#39;component&#39;) != current:
            # find an arc from n to seperated
            for m in separated:
                if (n,m) in self.edge_attr:
                    solution_g.add_edge(n,m)
                    return True
                elif (m,n) in self.edge_attr:
                    solution_g.add_edge(m,n)
                    return True
    return False</code></pre>
</details>
</dd>
<dt id="coinor.gimpy.graph.Graph.simplex_determine_leaving_arc"><code class="name flex">
<span>def <span class="ident">simplex_determine_leaving_arc</span></span>(<span>self, t, k, l)</span>
</code></dt>
<dd>
<div class="desc"><h2 id="api">Api</h2>
<p>simplex_determine_leaving_arc(self, t, k, l)</p>
<h2 id="description">Description</h2>
<p>Determines and returns the leaving arc.</p>
<h2 id="input">Input</h2>
<p>t: current spanning tree solution.
k: tail of the entering arc.
l: head of the entering arc.</p>
<h2 id="return">Return</h2>
<p>Returns the tuple that represents leaving arc, capacity of the
cycle and cycle.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def simplex_determine_leaving_arc(self, t, k, l):
    &#39;&#39;&#39;
    API:
        simplex_determine_leaving_arc(self, t, k, l)
    Description:
        Determines and returns the leaving arc.
    Input:
        t: current spanning tree solution.
        k: tail of the entering arc.
        l: head of the entering arc.
    Return:
        Returns the tuple that represents leaving arc, capacity of the
        cycle and cycle.
    &#39;&#39;&#39;
    # k,l are the first two elements of the cycle
    cycle = self.simplex_identify_cycle(t, k, l)
    flow_kl = self.get_edge_attr(k, l, &#39;flow&#39;)
    capacity_kl = self.get_edge_attr(k, l, &#39;capacity&#39;)
    min_capacity = capacity_kl
    # check if k,l is in U or L
    if flow_kl==capacity_kl:
        # l,k will be the last two elements
        cycle.reverse()
    n = len(cycle)
    index = 0
    # determine last blocking arc
    t.add_edge(k, l)
    tel = t.get_edge_list()
    while index &lt; (n-1):
        if (cycle[index], cycle[index+1]) in tel:
            flow = self.edge_attr[(cycle[index], cycle[index+1])][&#39;flow&#39;]
            capacity = \
                self.edge_attr[(cycle[index],cycle[index+1])][&#39;capacity&#39;]
            if min_capacity &gt;= (capacity-flow):
                candidate = (cycle[index], cycle[index+1])
                min_capacity = capacity-flow
        else:
            flow = self.edge_attr[(cycle[index+1], cycle[index])][&#39;flow&#39;]
            if min_capacity &gt;= flow:
                candidate = (cycle[index+1], cycle[index])
                min_capacity = flow
        index += 1
    # check arc (cycle[n-1], cycle[0])
    if (cycle[n-1], cycle[0]) in tel:
        flow = self.edge_attr[(cycle[n-1], cycle[0])][&#39;flow&#39;]
        capacity = self.edge_attr[(cycle[n-1], cycle[0])][&#39;capacity&#39;]
        if min_capacity &gt;= (capacity-flow):
            candidate = (cycle[n-1], cycle[0])
            min_capacity = capacity-flow
    else:
        flow = self.edge_attr[(cycle[0], cycle[n-1])][&#39;flow&#39;]
        if min_capacity &gt;= flow:
            candidate = (cycle[0], cycle[n-1])
            min_capacity = flow
    return (candidate, min_capacity, cycle)</code></pre>
</details>
</dd>
<dt id="coinor.gimpy.graph.Graph.simplex_find_cycle"><code class="name flex">
<span>def <span class="ident">simplex_find_cycle</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><h2 id="api">Api</h2>
<p>simplex_find_cycle(self)</p>
<h2 id="description">Description</h2>
<p>Returns a cycle (list of nodes) if the graph has one, returns None
otherwise. Uses DFS. During DFS checks existence of arcs to lower
depth regions. Note that direction of the arcs are not important.</p>
<h2 id="return">Return</h2>
<p>Returns list of nodes that represents cycle. Returns None if the
graph does not have any cycle.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def simplex_find_cycle(self):
    &#39;&#39;&#39;
    API:
        simplex_find_cycle(self)
    Description:
        Returns a cycle (list of nodes) if the graph has one, returns None
        otherwise. Uses DFS. During DFS checks existence of arcs to lower
        depth regions. Note that direction of the arcs are not important.
    Return:
        Returns list of nodes that represents cycle. Returns None if the
        graph does not have any cycle.
    &#39;&#39;&#39;
    # make a dfs, if you identify an arc to a lower depth node we have a
    # cycle
    nl = self.get_node_list()
    q = [nl[0]]
    visited = []
    depth = {nl[0]:0}
    pred = {nl[0]:None}
    for n in nl:
        self.get_node(n).set_attr(&#39;component&#39;, None)
    component_nr = int(nl[0])
    self.get_node(nl[0]).set_attr(&#39;component&#39;, component_nr)
    while True:
        while q:
            current = q.pop()
            visited.append(current)
            neighbors = self.in_neighbors[current] +\
                self.neighbors[current]
            for n in neighbors:
                if n==pred[current]:
                    continue
                self.get_node(n).set_attr(&#39;component&#39;, component_nr)
                if n in depth:
                    # we have a cycle
                    cycle1 = []
                    cycle2 = []
                    temp = n
                    while temp is not None:
                        cycle1.append(temp)
                        temp = pred[temp]
                    temp = current
                    while temp is not None:
                        cycle2.append(temp)
                        temp = pred[temp]
                    cycle1.pop()
                    cycle1.reverse()
                    cycle2.extend(cycle1)
                    return cycle2
                else:
                    pred[n] = current
                    depth[n] = depth[current] + 1
                if n not in visited:
                    q.append(n)
        flag = False
        for n in nl:
            if self.get_node(n).get_attr(&#39;component&#39;) is None:
                q.append(n)
                depth = {n:0}
                pred = {n:None}
                visited = []
                component_nr = int(n)
                self.get_node(n).set_attr(&#39;component&#39;, component_nr)
                flag = True
                break
        if not flag:
            break
    return None</code></pre>
</details>
</dd>
<dt id="coinor.gimpy.graph.Graph.simplex_find_tree"><code class="name flex">
<span>def <span class="ident">simplex_find_tree</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><h2 id="api">Api</h2>
<p>simplex_find_tree(self)</p>
<h2 id="description">Description</h2>
<p>Assumes a feasible flow solution stored in 'flow' attribute's of
arcs and converts this solution to a feasible spanning tree
solution.</p>
<h2 id="pre">Pre</h2>
<p>(1) 'flow' attributes represents a feasible flow solution.</p>
<h2 id="post">Post</h2>
<p>(1) 'flow' attributes may change when eliminating cycles.</p>
<h2 id="return">Return</h2>
<p>Return a Graph instance that is a spanning tree solution.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def simplex_find_tree(self):
    &#39;&#39;&#39;
    API:
        simplex_find_tree(self)
    Description:
        Assumes a feasible flow solution stored in &#39;flow&#39; attribute&#39;s of
        arcs and converts this solution to a feasible spanning tree
        solution.
    Pre:
        (1) &#39;flow&#39; attributes represents a feasible flow solution.
    Post:
        (1) &#39;flow&#39; attributes may change when eliminating cycles.
    Return:
        Return a Graph instance that is a spanning tree solution.
    &#39;&#39;&#39;
    # find a cycle
    solution_g = self.get_simplex_solution_graph()
    cycle = solution_g.simplex_find_cycle()
    while cycle is not None:
        # find amount to augment and direction
        amount = self.simplex_augment_cycle(cycle)
        # augment along the cycle
        self.augment_cycle(amount, cycle)
        # find a new cycle
        solution_g = self.get_simplex_solution_graph()
        cycle = solution_g.simplex_find_cycle()
    # check if the solution is connected
    while self.simplex_connect(solution_g):
        pass
    # add attributes
    for e in self.edge_attr:
        flow = self.edge_attr[e][&#39;flow&#39;]
        capacity = self.edge_attr[e][&#39;capacity&#39;]
        cost = self.edge_attr[e][&#39;cost&#39;]
        self.edge_attr[e][&#39;label&#39;] = &#34;%d/%d/%d&#34; %(flow,capacity,cost)
        if e in solution_g.edge_attr:
            solution_g.edge_attr[e][&#39;flow&#39;] = flow
            solution_g.edge_attr[e][&#39;capacity&#39;] = capacity
            solution_g.edge_attr[e][&#39;cost&#39;] = cost
            solution_g.edge_attr[e][&#39;label&#39;] = &#34;%d/%d/%d&#34; %(flow,capacity,cost)
    return solution_g</code></pre>
</details>
</dd>
<dt id="coinor.gimpy.graph.Graph.simplex_identify_cycle"><code class="name flex">
<span>def <span class="ident">simplex_identify_cycle</span></span>(<span>self, t, k, l)</span>
</code></dt>
<dd>
<div class="desc"><h2 id="api">Api</h2>
<p>identify_cycle(self, t, k, l)</p>
<h2 id="description">Description</h2>
<p>Identifies and returns to the pivot cycle, which is a list of
nodes.</p>
<h2 id="pre">Pre</h2>
<p>(1) t is spanning tree solution, (k,l) is the entering arc.</p>
<h2 id="input">Input</h2>
<p>t: current spanning tree solution
k: tail of the entering arc
l: head of the entering arc</p>
<h2 id="returns">Returns</h2>
<p>List of nodes in the cycle.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def simplex_identify_cycle(self, t, k, l):
    &#39;&#39;&#39;
    API:
        identify_cycle(self, t, k, l)
    Description:
        Identifies and returns to the pivot cycle, which is a list of
        nodes.
    Pre:
        (1) t is spanning tree solution, (k,l) is the entering arc.
    Input:
        t: current spanning tree solution
        k: tail of the entering arc
        l: head of the entering arc
    Returns:
        List of nodes in the cycle.
    &#39;&#39;&#39;
    i = k
    j = l
    cycle = []
    li = [k]
    lj = [j]
    while i is not j:
        depth_i = t.get_node(i).get_attr(&#39;depth&#39;)
        depth_j = t.get_node(j).get_attr(&#39;depth&#39;)
        if depth_i &gt; depth_j:
            i = t.get_node(i).get_attr(&#39;pred&#39;)
            li.append(i)
        elif depth_i &lt; depth_j:
            j = t.get_node(j).get_attr(&#39;pred&#39;)
            lj.append(j)
        else:
            i = t.get_node(i).get_attr(&#39;pred&#39;)
            li.append(i)
            j = t.get_node(j).get_attr(&#39;pred&#39;)
            lj.append(j)
    cycle.extend(lj)
    li.pop()
    li.reverse()
    cycle.extend(li)
    # l is beginning k is end
    return cycle</code></pre>
</details>
</dd>
<dt id="coinor.gimpy.graph.Graph.simplex_mark_entering_arc"><code class="name flex">
<span>def <span class="ident">simplex_mark_entering_arc</span></span>(<span>self, k, l)</span>
</code></dt>
<dd>
<div class="desc"><h2 id="api">Api</h2>
<p>simplex_mark_entering_arc(self, k, l)</p>
<h2 id="description">Description</h2>
<p>Marks entering arc (k,l)</p>
<h2 id="input">Input</h2>
<p>k: tail of the entering arc
l: head of the entering arc</p>
<h2 id="post">Post</h2>
<p>(1) color attribute of the arc (k,l)</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def simplex_mark_entering_arc(self, k, l):
    &#39;&#39;&#39;
    API:
        simplex_mark_entering_arc(self, k, l)
    Description:
        Marks entering arc (k,l)
    Input:
        k: tail of the entering arc
        l: head of the entering arc
    Post:
        (1) color attribute of the arc (k,l)
    &#39;&#39;&#39;
    self.set_edge_attr(k, l, &#39;color&#39;, &#39;green&#39;)</code></pre>
</details>
</dd>
<dt id="coinor.gimpy.graph.Graph.simplex_mark_leaving_arc"><code class="name flex">
<span>def <span class="ident">simplex_mark_leaving_arc</span></span>(<span>self, p, q)</span>
</code></dt>
<dd>
<div class="desc"><h2 id="api">Api</h2>
<p>simplex_mark_leving_arc(self, p, q)</p>
<h2 id="description">Description</h2>
<p>Marks leaving arc.</p>
<h2 id="input">Input</h2>
<p>p: tail of the leaving arc
q: head of the leaving arc</p>
<h2 id="post">Post</h2>
<p>Changes color attribute of leaving arc.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def simplex_mark_leaving_arc(self, p, q):
    &#39;&#39;&#39;
    API:
        simplex_mark_leving_arc(self, p, q)
    Description:
        Marks leaving arc.
    Input:
        p: tail of the leaving arc
        q: head of the leaving arc
    Post:
        Changes color attribute of leaving arc.
    &#39;&#39;&#39;
    self.set_edge_attr(p, q, &#39;color&#39;, &#39;red&#39;)</code></pre>
</details>
</dd>
<dt id="coinor.gimpy.graph.Graph.simplex_mark_st_arcs"><code class="name flex">
<span>def <span class="ident">simplex_mark_st_arcs</span></span>(<span>self, t)</span>
</code></dt>
<dd>
<div class="desc"><h2 id="api">Api</h2>
<p>simplex_mark_st_arcs(self, t)</p>
<h2 id="description">Description</h2>
<p>Marks spanning tree arcs.
Case 1, Blue: Arcs that are at lower bound and in tree.
Case 2, Red: Arcs that are at upper bound and in tree.
Case 3, Green: Arcs that are between bounds are green.
Case 4, Brown: Non-tree arcs at lower bound.
Case 5, Violet: Non-tree arcs at upper bound.</p>
<h2 id="input">Input</h2>
<p>t: t is the current spanning tree</p>
<h2 id="post">Post</h2>
<p>(1) color attribute of edges.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def simplex_mark_st_arcs(self, t):
    &#39;&#39;&#39;
    API:
        simplex_mark_st_arcs(self, t)
    Description:
        Marks spanning tree arcs.
        Case 1, Blue: Arcs that are at lower bound and in tree.
        Case 2, Red: Arcs that are at upper bound and in tree.
        Case 3, Green: Arcs that are between bounds are green.
        Case 4, Brown: Non-tree arcs at lower bound.
        Case 5, Violet: Non-tree arcs at upper bound.
    Input:
        t: t is the current spanning tree
    Post:
        (1) color attribute of edges.
    &#39;&#39;&#39;
    tel = list(t.edge_attr.keys())
    for e in self.get_edge_list():
        flow_e = self.edge_attr[e][&#39;flow&#39;]
        capacity_e = self.edge_attr[e][&#39;capacity&#39;]
        if e in tel:
            if flow_e == 0:
                self.edge_attr[e][&#39;color&#39;] = &#39;blue&#39;
            elif flow_e == capacity_e:
                self.edge_attr[e][&#39;color&#39;] = &#39;blue&#39;
            else:
                self.edge_attr[e][&#39;color&#39;] = &#39;blue&#39;
        else:
            if flow_e == 0:
                self.edge_attr[e][&#39;color&#39;] = &#39;black&#39;
            elif flow_e == capacity_e:
                self.edge_attr[e][&#39;color&#39;] = &#39;black&#39;
            else:
                msg = &#34;Arc is not in ST but has flow between bounds.&#34;
                raise Exception(msg)</code></pre>
</details>
</dd>
<dt id="coinor.gimpy.graph.Graph.simplex_optimal"><code class="name flex">
<span>def <span class="ident">simplex_optimal</span></span>(<span>self, t)</span>
</code></dt>
<dd>
<div class="desc"><h2 id="api">Api</h2>
<p>simplex_optimal(self, t)</p>
<h2 id="description">Description</h2>
<p>Checks if the current solution is optimal, if yes returns True,
False otherwise.</p>
<h2 id="pre">Pre</h2>
<p>'flow' attributes represents a solution.</p>
<h2 id="input">Input</h2>
<p>t: Graph instance tat reperesents spanning tree solution.</p>
<h2 id="return">Return</h2>
<p>Returns True if the current solution is optimal (optimality
conditions are satisfied), else returns False</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def simplex_optimal(self, t):
    &#39;&#39;&#39;
    API:
        simplex_optimal(self, t)
    Description:
        Checks if the current solution is optimal, if yes returns True,
        False otherwise.
    Pre:
        &#39;flow&#39; attributes represents a solution.
    Input:
        t: Graph instance tat reperesents spanning tree solution.
    Return:
        Returns True if the current solution is optimal (optimality
        conditions are satisfied), else returns False
    &#39;&#39;&#39;
    for e in self.edge_attr:
        if e in t.edge_attr:
            continue
        flow_ij = self.edge_attr[e][&#39;flow&#39;]
        potential_i = self.get_node(e[0]).get_attr(&#39;potential&#39;)
        potential_j = self.get_node(e[1]).get_attr(&#39;potential&#39;)
        capacity_ij = self.edge_attr[e][&#39;capacity&#39;]
        c_ij = self.edge_attr[e][&#39;cost&#39;]
        cpi_ij = c_ij - potential_i + potential_j
        if flow_ij==0:
            if cpi_ij &lt; 0:
                return False
        elif flow_ij==capacity_ij:
            if cpi_ij &gt; 0:
                return False
    return True</code></pre>
</details>
</dd>
<dt id="coinor.gimpy.graph.Graph.simplex_redraw"><code class="name flex">
<span>def <span class="ident">simplex_redraw</span></span>(<span>self, display, root)</span>
</code></dt>
<dd>
<div class="desc"><h2 id="api">Api</h2>
<p>simplex_redraw(self, display, root)</p>
<h2 id="description">Description</h2>
<p>Returns a new graph instance that is same as self but adds nodes
and arcs in a way that the resulting tree will be displayed
properly.</p>
<h2 id="input">Input</h2>
<p>display: display mode
root: root node in tree.</p>
<h2 id="return">Return</h2>
<p>Returns a graph same as self.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def simplex_redraw(self, display, root):
    &#39;&#39;&#39;
    API:
        simplex_redraw(self, display, root)
    Description:
        Returns a new graph instance that is same as self but adds nodes
        and arcs in a way that the resulting tree will be displayed
        properly.
    Input:
        display: display mode
        root: root node in tree.
    Return:
        Returns a graph same as self.
    &#39;&#39;&#39;
    nl = self.get_node_list()
    el = self.get_edge_list()
    new = Graph(type=DIRECTED_GRAPH, layout=&#39;dot&#39;, display=display)
    pred_i = self.get_node(root).get_attr(&#39;pred&#39;)
    thread_i = self.get_node(root).get_attr(&#39;thread&#39;)
    depth_i = self.get_node(root).get_attr(&#39;depth&#39;)
    new.add_node(root, pred=pred_i, thread=thread_i, depth=depth_i)
    q = [root]
    visited = [root]
    while q:
        name = q.pop()
        visited.append(name)
        neighbors = self.neighbors[name] + self.in_neighbors[name]
        for n in neighbors:
            if n not in new.get_node_list():
                pred_i = self.get_node(n).get_attr(&#39;pred&#39;)
                thread_i = self.get_node(n).get_attr(&#39;thread&#39;)
                depth_i = self.get_node(n).get_attr(&#39;depth&#39;)
                new.add_node(n, pred=pred_i, thread=thread_i, depth=depth_i)
            if (name,n) in el:
                if (name,n) not in new.edge_attr:
                    new.add_edge(name,n)
            else:
                if (n,name) not in new.edge_attr:
                    new.add_edge(n,name)
            if n not in visited:
                q.append(n)
    for e in el:
        flow = self.edge_attr[e][&#39;flow&#39;]
        capacity = self.edge_attr[e][&#39;capacity&#39;]
        cost = self.edge_attr[e][&#39;cost&#39;]
        new.edge_attr[e][&#39;flow&#39;] = flow
        new.edge_attr[e][&#39;capacity&#39;] = capacity
        new.edge_attr[e][&#39;cost&#39;] = cost
        new.edge_attr[e][&#39;label&#39;] =  &#34;%d/%d/%d&#34; %(flow,capacity,cost)
    return new</code></pre>
</details>
</dd>
<dt id="coinor.gimpy.graph.Graph.simplex_remove_arc"><code class="name flex">
<span>def <span class="ident">simplex_remove_arc</span></span>(<span>self, t, p, q, min_capacity, cycle)</span>
</code></dt>
<dd>
<div class="desc"><h2 id="api">Api</h2>
<p>simplex_remove_arc(self, p, q, min_capacity, cycle)</p>
<h2 id="description">Description</h2>
<p>Removes arc (p,q), updates t, updates flows, where (k,l) is
the entering arc.</p>
<h2 id="input">Input</h2>
<p>t: tree solution to be updated.
p: tail of the leaving arc.
q: head of the leaving arc.
min_capacity: capacity of the cycle.
cycle: cycle obtained when entering arc considered.</p>
<h2 id="post">Post</h2>
<p>(1) updates t.
(2) updates 'flow' attributes.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def simplex_remove_arc(self, t, p, q, min_capacity, cycle):
    &#39;&#39;&#39;
    API:
        simplex_remove_arc(self, p, q, min_capacity, cycle)
    Description:
        Removes arc (p,q), updates t, updates flows, where (k,l) is
        the entering arc.
    Input:
        t: tree solution to be updated.
        p: tail of the leaving arc.
        q: head of the leaving arc.
        min_capacity: capacity of the cycle.
        cycle: cycle obtained when entering arc considered.
    Post:
        (1) updates t.
        (2) updates &#39;flow&#39; attributes.
    &#39;&#39;&#39;
    # augment min_capacity along cycle
    n = len(cycle)
    tel = list(t.edge_attr.keys())
    index = 0
    while index &lt; (n-1):
        if (cycle[index], cycle[index+1]) in tel:
            flow_e = self.edge_attr[(cycle[index], cycle[index+1])][&#39;flow&#39;]
            self.edge_attr[(cycle[index], cycle[index+1])][&#39;flow&#39;] =\
                flow_e+min_capacity
        else:
            flow_e = self.edge_attr[(cycle[index+1], cycle[index])][&#39;flow&#39;]
            self.edge_attr[(cycle[index+1], cycle[index])][&#39;flow&#39;] =\
                flow_e-min_capacity
        index += 1
    # augment arc cycle[n-1], cycle[0]
    if (cycle[n-1], cycle[0]) in tel:
        flow_e = self.edge_attr[(cycle[n-1], cycle[0])][&#39;flow&#39;]
        self.edge_attr[(cycle[n-1], cycle[0])][&#39;flow&#39;] =\
            flow_e+min_capacity
    else:
        flow_e = self.edge_attr[(cycle[0], cycle[n-1])][&#39;flow&#39;]
        self.edge_attr[(cycle[0], cycle[n-1])][&#39;flow&#39;] =\
            flow_e-min_capacity
    # remove leaving arc
    t.del_edge((p, q))
    # set label of removed arc
    flow_pq = self.get_edge_attr(p, q, &#39;flow&#39;)
    capacity_pq = self.get_edge_attr(p, q, &#39;capacity&#39;)
    cost_pq = self.get_edge_attr(p, q, &#39;cost&#39;)
    self.set_edge_attr(p, q, &#39;label&#39;,
                       &#34;%d/%d/%d&#34; %(flow_pq,capacity_pq,cost_pq))
    for e in t.edge_attr:
        flow = self.edge_attr[e][&#39;flow&#39;]
        capacity = self.edge_attr[e][&#39;capacity&#39;]
        cost = self.edge_attr[e][&#39;cost&#39;]
        t.edge_attr[e][&#39;flow&#39;] = flow
        t.edge_attr[e][&#39;capacity&#39;] = capacity
        t.edge_attr[e][&#39;cost&#39;] = cost
        t.edge_attr[e][&#39;label&#39;] = &#34;%d/%d/%d&#34; %(flow,capacity,cost)
        self.edge_attr[e][&#39;label&#39;] = &#34;%d/%d/%d&#34; %(flow,capacity,cost)</code></pre>
</details>
</dd>
<dt id="coinor.gimpy.graph.Graph.simplex_search"><code class="name flex">
<span>def <span class="ident">simplex_search</span></span>(<span>self, source, component_nr)</span>
</code></dt>
<dd>
<div class="desc"><h2 id="api">Api</h2>
<p>simplex_search(self, source, component_nr)</p>
<h2 id="description">Description</h2>
<p>Searches graph starting from source. Its difference from usual
search is we can also go backwards along an arc. When the graph
is a spanning tree it computes predecessor, thread and depth
indexes and stores them as node attributes. These values should be
considered as junk when the graph is not a spanning tree.</p>
<h2 id="input">Input</h2>
<p>source: source node
component_nr: component number</p>
<h2 id="post">Post</h2>
<p>(1) Sets the component number of all reachable nodes to component.
Changes 'component' attribute of nodes.
(2) Sets 'pred', 'thread' and 'depth' attributes of nodes. These
values are junk if the graph is not a tree.</p>
<h2 id="return">Return</h2>
<p>Returns predecessor dictionary.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def simplex_search(self, source, component_nr):
    &#39;&#39;&#39;
    API:
        simplex_search(self, source, component_nr)
    Description:
        Searches graph starting from source. Its difference from usual
        search is we can also go backwards along an arc. When the graph
        is a spanning tree it computes predecessor, thread and depth
        indexes and stores them as node attributes. These values should be
        considered as junk when the graph is not a spanning tree.
    Input:
        source: source node
        component_nr: component number
    Post:
        (1) Sets the component number of all reachable nodes to component.
        Changes &#39;component&#39; attribute of nodes.
        (2) Sets &#39;pred&#39;, &#39;thread&#39; and &#39;depth&#39; attributes of nodes. These
        values are junk if the graph is not a tree.
    Return:
        Returns predecessor dictionary.
    &#39;&#39;&#39;
    q = [source]
    pred = {source:None}
    depth = {source:0}
    sequence = []
    for n in self.neighbors:
        self.get_node(n).set_attr(&#39;component&#39;, None)
    while q:
        current = q.pop()
        self.get_node(current).set_attr(&#39;component&#39;, component_nr)
        sequence.append(current)
        neighbors = self.in_neighbors[current] + self.neighbors[current]
        for n in neighbors:
            if n in pred:
                continue
            self.get_node(n).set_attr(&#39;component&#39;, component_nr)
            pred[n] = current
            depth[n] = depth[current]+1
            q.append(n)
    for i in range(len(sequence)-1):
        self.get_node(sequence[i]).set_attr(&#39;thread&#39;, int(sequence[i+1]))
    self.get_node(sequence[-1]).set_attr(&#39;thread&#39;, int(sequence[0]))
    for n in pred:
        self.get_node(n).set_attr(&#39;pred&#39;, pred[n])
        self.get_node(n).set_attr(&#39;depth&#39;, depth[n])
    return pred</code></pre>
</details>
</dd>
<dt id="coinor.gimpy.graph.Graph.simplex_select_entering_arc"><code class="name flex">
<span>def <span class="ident">simplex_select_entering_arc</span></span>(<span>self, t, pivot)</span>
</code></dt>
<dd>
<div class="desc"><h2 id="api">Api</h2>
<p>simplex_select_entering_arc(self, t, pivot)</p>
<h2 id="description">Description</h2>
<p>Decides and returns entering arc using pivot rule.</p>
<h2 id="input">Input</h2>
<p>t: current spanning tree solution
pivot: May be one of the following; 'first_eligible' or 'dantzig'.
'dantzig' is the default value.</p>
<h2 id="return">Return</h2>
<p>Returns entering arc tuple (k,l)</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def simplex_select_entering_arc(self, t, pivot):
    &#39;&#39;&#39;
    API:
        simplex_select_entering_arc(self, t, pivot)
    Description:
        Decides and returns entering arc using pivot rule.
    Input:
        t: current spanning tree solution
        pivot: May be one of the following; &#39;first_eligible&#39; or &#39;dantzig&#39;.
        &#39;dantzig&#39; is the default value.
    Return:
        Returns entering arc tuple (k,l)
    &#39;&#39;&#39;
    if pivot==&#39;dantzig&#39;:
        # pick the maximum violation
        candidate = {}
        for e in self.edge_attr:
            if e in t.edge_attr:
                continue
            flow_ij = self.edge_attr[e][&#39;flow&#39;]
            potential_i = self.get_node(e[0]).get_attr(&#39;potential&#39;)
            potential_j = self.get_node(e[1]).get_attr(&#39;potential&#39;)
            capacity_ij = self.edge_attr[e][&#39;capacity&#39;]
            c_ij = self.edge_attr[e][&#39;cost&#39;]
            cpi_ij = c_ij - potential_i + potential_j
            if flow_ij==0:
                if cpi_ij &lt; 0:
                    candidate[e] = cpi_ij
            elif flow_ij==capacity_ij:
                if cpi_ij &gt; 0:
                    candidate[e] = cpi_ij
        for e in candidate:
            max_c = e
            max_v = abs(candidate[e])
            break
        for e in candidate:
            if max_v &lt; abs(candidate[e]):
                max_c = e
                max_v = abs(candidate[e])
    elif pivot==&#39;first_eligible&#39;:
        # pick the first eligible
        for e in self.edge_attr:
            if e in t.edge_attr:
                continue
            flow_ij = self.edge_attr[e][&#39;flow&#39;]
            potential_i = self.get_node(e[0]).get_attr(&#39;potential&#39;)
            potential_j = self.get_node(e[1]).get_attr(&#39;potential&#39;)
            capacity_ij = self.edge_attr[e][&#39;capacity&#39;]
            c_ij = self.edge_attr[e][&#39;cost&#39;]
            cpi_ij = c_ij - potential_i + potential_j
            if flow_ij==0:
                if cpi_ij &lt; 0:
                    max_c = e
                    max_v = abs(cpi_ij)
            elif flow_ij==capacity_ij:
                if cpi_ij &gt; 0:
                    max_c = e
                    max_v = cpi_ij
    else:
        raise Exception(&#34;Unknown pivot rule.&#34;)
    return max_c</code></pre>
</details>
</dd>
<dt id="coinor.gimpy.graph.Graph.strong_connect"><code class="name flex">
<span>def <span class="ident">strong_connect</span></span>(<span>self, q, node, index, component)</span>
</code></dt>
<dd>
<div class="desc"><p>API: strong_connect (self, q, node, index, component)
Description:
Used by tarjan method. This method should not be called directly by
user.</p>
<h2 id="input">Input</h2>
<p>q: Node list.
node: Node that is being connected to nodes in q.
index: Index used by tarjan method.
component: Current component number.</p>
<h2 id="pre">Pre</h2>
<p>Should be called by tarjan and itself (recursive) only.</p>
<h2 id="post">Post</h2>
<p>Nodes will have 'component' attribute that will have component
number as value. Changes 'index' attribute of nodes.</p>
<h2 id="return">Return</h2>
<p>Returns new index and component numbers.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def strong_connect(self, q, node, index, component):
    &#39;&#39;&#39;
    API: strong_connect (self, q, node, index, component)
    Description:
    Used by tarjan method. This method should not be called directly by
    user.
    Input:
        q: Node list.
        node: Node that is being connected to nodes in q.
        index: Index used by tarjan method.
        component: Current component number.
    Pre:
        Should be called by tarjan and itself (recursive) only.
    Post:
        Nodes will have &#39;component&#39; attribute that will have component
        number as value. Changes &#39;index&#39; attribute of nodes.
    Return:
        Returns new index and component numbers.
    &#39;&#39;&#39;
    self.set_node_attr(node, &#39;index&#39;, index)
    self.set_node_attr(node, &#39;lowlink&#39;, index)
    index += 1
    q.append(node)
    for m in self.get_neighbors(node):
        if self.get_node_attr(m, &#39;index&#39;) is None:
            index, component = self.strong_connect(q, m, index, component)
            self.set_node_attr(node, &#39;lowlink&#39;,
                               min([self.get_node_attr(node, &#39;lowlink&#39;),
                                    self.get_node_attr(m, &#39;lowlink&#39;)]))
        elif m in q:
            self.set_node_attr(node, &#39;lowlink&#39;,
                               min([self.get_node_attr(node, &#39;lowlink&#39;),
                                    self.get_node_attr(m, &#39;index&#39;)]))
    if self.get_node_attr(node, &#39;lowlink&#39;) == self.get_node_attr(node, &#39;index&#39;):
        m = q.pop()
        self.set_node_attr(m, &#39;component&#39;, component)
        while (node!=m):
            m = q.pop()
            self.set_node_attr(m, &#39;component&#39;, component)
        component += 1
        self.num_components = component

    return (index, component)</code></pre>
</details>
</dd>
<dt id="coinor.gimpy.graph.Graph.tarjan"><code class="name flex">
<span>def <span class="ident">tarjan</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>API: tarjan(self)
Description:
Implements Tarjan's algorithm for determining strongly connected set of
nodes.</p>
<h2 id="pre">Pre</h2>
<p>self.graph_type should be DIRECTED_GRAPH.</p>
<h2 id="post">Post</h2>
<p>Nodes will have 'component' attribute that will have component
number as value. Changes 'index' attribute of nodes.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def tarjan(self):
    &#39;&#39;&#39;
    API: tarjan(self)
    Description:
    Implements Tarjan&#39;s algorithm for determining strongly connected set of
    nodes.
    Pre:
        self.graph_type should be DIRECTED_GRAPH.
    Post:
        Nodes will have &#39;component&#39; attribute that will have component
        number as value. Changes &#39;index&#39; attribute of nodes.
    &#39;&#39;&#39;
    index = 0
    component = 0
    q = []
    for n in self.get_node_list():
        if self.get_node_attr(n, &#39;index&#39;) is None:
            index, component = self.strong_connect(q, n, index, component)</code></pre>
</details>
</dd>
<dt id="coinor.gimpy.graph.Graph.to_string"><code class="name flex">
<span>def <span class="ident">to_string</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>API: to_string(self)
Description:
This method is based on pydot Graph class with the same name.
Returns a string representation of the graph in dot language.
It will return the graph and all its subelements in string form.</p>
<h2 id="return">Return</h2>
<p>String that represents graph in dot language.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def to_string(self):
    &#39;&#39;&#39;
    API: to_string(self)
    Description:
    This method is based on pydot Graph class with the same name.
    Returns a string representation of the graph in dot language.
    It will return the graph and all its subelements in string form.
    Return:
        String that represents graph in dot language.
    &#39;&#39;&#39;
    graph = list()
    processed_edges = {}
    graph.append(&#39;%s %s {\n&#39; %(self.graph_type, self.name))
    for a in self.attr:
        if a not in GRAPH_ATTRIBUTES:
            continue
        val = self.attr[a]
        if val is not None:
            graph.append( &#39;%s=%s&#39; % (a, quote_if_necessary(val)) )
        else:
            graph.append(a)
        graph.append( &#39;;\n&#39; )
    # clusters
    for c in self.cluster:
        graph.append(&#39;subgraph cluster_%s {\n&#39; %c)
        for a in self.cluster[c][&#39;attrs&#39;]:
            if a==&#39;label&#39;:
                graph.append(a+&#39;=&#39;+quote_if_necessary(self.cluster[c][&#39;attrs&#39;][a])+&#39;;\n&#39;)
                continue
            graph.append(a+&#39;=&#39;+self.cluster[c][&#39;attrs&#39;][a]+&#39;;\n&#39;)
        if len(self.cluster[c][&#39;node_attrs&#39;])!=0:
            graph.append(&#39;node [&#39;)
        for a in self.cluster[c][&#39;node_attrs&#39;]:
            graph.append(a+&#39;=&#39;+self.cluster[c][&#39;node_attrs&#39;][a])
            graph.append(&#39;,&#39;)
        if len(self.cluster[c][&#39;node_attrs&#39;])!=0:
            graph.pop()
            graph.append(&#39;];\n&#39;)
        # process cluster nodes
        for n in self.cluster[c][&#39;node_list&#39;]:
            data = self.get_node(n).to_string()
            graph.append(data + &#39;;\n&#39;)
        # process cluster edges
        for n in self.cluster[c][&#39;node_list&#39;]:
            for m in self.cluster[c][&#39;node_list&#39;]:
                if self.check_edge(n,m):
                    data = self.edge_to_string((n,m))
                    graph.append(data + &#39;;\n&#39;)
                    processed_edges[(n,m)]=None
        graph.append(&#39;}\n&#39;)
    # process remaining (non-cluster) nodes
    for n in self.neighbors:
        for c in self.cluster:
            if n in self.cluster[c][&#39;node_list&#39;]:
                break
        else:
            data = self.get_node(n).to_string()
            graph.append(data + &#39;;\n&#39;)
    # process edges
    for e in self.edge_attr:
        if e in processed_edges:
            continue
        data = self.edge_to_string(e)
        graph.append(data + &#39;;\n&#39;)
    graph.append( &#39;}\n&#39; )
    return &#39;&#39;.join(graph)</code></pre>
</details>
</dd>
<dt id="coinor.gimpy.graph.Graph.write"><code class="name flex">
<span>def <span class="ident">write</span></span>(<span>self, file_obj, layout=None, format='png')</span>
</code></dt>
<dd>
<div class="desc"><h2 id="api">Api</h2>
<p>write(self, basename = 'graph', layout = None, format='png')
Description:
Writes graph to dist using layout and format.</p>
<h2 id="input">Input</h2>
<p>basename: name of the file that will be written.
layout: Dot layout for generating graph image.
format: Image format, all format supported by Dot are wellcome.</p>
<h2 id="post">Post</h2>
<p>File will be written to disk.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def write(self, file_obj, layout = None, format=&#39;png&#39;):
    &#39;&#39;&#39;
    API:
        write(self, basename = &#39;graph&#39;, layout = None, format=&#39;png&#39;)
    Description:
    Writes graph to dist using layout and format.
    Input:
        basename: name of the file that will be written.
        layout: Dot layout for generating graph image.
        format: Image format, all format supported by Dot are wellcome.
    Post:
        File will be written to disk.
    &#39;&#39;&#39;
    if layout == None:
        layout = self.get_layout()
    if format == &#39;dot&#39;:
        file_obj.write(bytearray(self.to_string(), &#39;utf8&#39;))
    else:
        out = self.create(layout, format)
        if (out != None):
            file_obj.write(out)</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="coinor.gimpy.graph.Node"><code class="flex name class">
<span>class <span class="ident">Node</span></span>
<span>(</span><span>name, **attr)</span>
</code></dt>
<dd>
<div class="desc"><p>Node class. A node object keeps node attributes. Has a method to write
node in Dot language grammer.</p>
<p>API: <strong>init</strong>(self, name, **attrs)
Description:
Node class constructor. Sets name and attributes using arguments.</p>
<h2 id="input">Input</h2>
<p>name: Name of node.
**attrs: Node attributes.</p>
<h2 id="post">Post</h2>
<p>Sets self.name and self.attr.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Node(object):
    &#39;&#39;&#39;
    Node class. A node object keeps node attributes. Has a method to write
    node in Dot language grammer.
    &#39;&#39;&#39;
    def __init__(self, name, **attr):
        &#39;&#39;&#39;
        API: __init__(self, name, **attrs)
        Description:
        Node class constructor. Sets name and attributes using arguments.
        Input:
            name: Name of node.
            **attrs: Node attributes.
        Post:
            Sets self.name and self.attr.
        &#39;&#39;&#39;
        self.name = name
        self.attr = copy.deepcopy(DEFAULT_NODE_ATTRIBUTES)
        for a in attr:
            self.attr[a] = attr[a]

    def get_attr(self, attr):
        &#39;&#39;&#39;
        API: get_attr(self, attr)
        Description:
        Returns node attribute attr.
        Input:
            attr: Node attribute to get.
        Return:
            Returns Node attribute attr if exists returns None, otherwise.
        &#39;&#39;&#39;
        if attr in self.attr:
            return self.attr[attr]
        else:
            return None

    def set_attr(self, attr, value):
        &#39;&#39;&#39;
        API: set_attr(self, attr, value)
        Description:
        Sets node attribute attr to value.
        Input:
            attr: Node attribute to set.
            value: New value of the attribute.
        Post:
            Updates self.attr[attr].
        &#39;&#39;&#39;
        self.attr[attr] = value

    def to_string(self):
        &#39;&#39;&#39;
        API: to_string(self)
        Description:
        Returns string representation of node in dot language.
        Return:
            String representation of node.
        &#39;&#39;&#39;
        node = list()
        node.append(quote_if_necessary(str(self.name)))
        node.append(&#39; [&#39;)
        flag = False
        for a in self.attr:
            flag = True
            node.append(a)
            node.append(&#39;=&#39;)
            node.append(quote_if_necessary(str(self.attr[a])))
            node.append(&#39;, &#39;)
        if flag is True:
            node = node[:-1]
        node.append(&#39;]&#39;)
        return &#39;&#39;.join(node)

    def __repr__(self):
        &#39;&#39;&#39;
        API: __repr__(self)
        Description:
        Returns string representation of node in dot language.
        Return:
            String representation of node.
        &#39;&#39;&#39;
        return self.to_string()</code></pre>
</details>
<h3>Methods</h3>
<dl>
<dt id="coinor.gimpy.graph.Node.get_attr"><code class="name flex">
<span>def <span class="ident">get_attr</span></span>(<span>self, attr)</span>
</code></dt>
<dd>
<div class="desc"><p>API: get_attr(self, attr)
Description:
Returns node attribute attr.</p>
<h2 id="input">Input</h2>
<p>attr: Node attribute to get.</p>
<h2 id="return">Return</h2>
<p>Returns Node attribute attr if exists returns None, otherwise.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_attr(self, attr):
    &#39;&#39;&#39;
    API: get_attr(self, attr)
    Description:
    Returns node attribute attr.
    Input:
        attr: Node attribute to get.
    Return:
        Returns Node attribute attr if exists returns None, otherwise.
    &#39;&#39;&#39;
    if attr in self.attr:
        return self.attr[attr]
    else:
        return None</code></pre>
</details>
</dd>
<dt id="coinor.gimpy.graph.Node.set_attr"><code class="name flex">
<span>def <span class="ident">set_attr</span></span>(<span>self, attr, value)</span>
</code></dt>
<dd>
<div class="desc"><p>API: set_attr(self, attr, value)
Description:
Sets node attribute attr to value.</p>
<h2 id="input">Input</h2>
<p>attr: Node attribute to set.
value: New value of the attribute.</p>
<h2 id="post">Post</h2>
<p>Updates self.attr[attr].</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_attr(self, attr, value):
    &#39;&#39;&#39;
    API: set_attr(self, attr, value)
    Description:
    Sets node attribute attr to value.
    Input:
        attr: Node attribute to set.
        value: New value of the attribute.
    Post:
        Updates self.attr[attr].
    &#39;&#39;&#39;
    self.attr[attr] = value</code></pre>
</details>
</dd>
<dt id="coinor.gimpy.graph.Node.to_string"><code class="name flex">
<span>def <span class="ident">to_string</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>API: to_string(self)
Description:
Returns string representation of node in dot language.</p>
<h2 id="return">Return</h2>
<p>String representation of node.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def to_string(self):
    &#39;&#39;&#39;
    API: to_string(self)
    Description:
    Returns string representation of node in dot language.
    Return:
        String representation of node.
    &#39;&#39;&#39;
    node = list()
    node.append(quote_if_necessary(str(self.name)))
    node.append(&#39; [&#39;)
    flag = False
    for a in self.attr:
        flag = True
        node.append(a)
        node.append(&#39;=&#39;)
        node.append(quote_if_necessary(str(self.attr[a])))
        node.append(&#39;, &#39;)
    if flag is True:
        node = node[:-1]
    node.append(&#39;]&#39;)
    return &#39;&#39;.join(node)</code></pre>
</details>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="coinor.gimpy" href="index.html">coinor.gimpy</a></code></li>
</ul>
</li>
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="">
<li><code><a title="coinor.gimpy.graph.handle_close" href="#coinor.gimpy.graph.handle_close">handle_close</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="coinor.gimpy.graph.DisjointSet" href="#coinor.gimpy.graph.DisjointSet">DisjointSet</a></code></h4>
<ul class="">
<li><code><a title="coinor.gimpy.graph.DisjointSet.add" href="#coinor.gimpy.graph.DisjointSet.add">add</a></code></li>
<li><code><a title="coinor.gimpy.graph.DisjointSet.find" href="#coinor.gimpy.graph.DisjointSet.find">find</a></code></li>
<li><code><a title="coinor.gimpy.graph.DisjointSet.union" href="#coinor.gimpy.graph.DisjointSet.union">union</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="coinor.gimpy.graph.Graph" href="#coinor.gimpy.graph.Graph">Graph</a></code></h4>
<ul class="">
<li><code><a title="coinor.gimpy.graph.Graph.add_edge" href="#coinor.gimpy.graph.Graph.add_edge">add_edge</a></code></li>
<li><code><a title="coinor.gimpy.graph.Graph.add_node" href="#coinor.gimpy.graph.Graph.add_node">add_node</a></code></li>
<li><code><a title="coinor.gimpy.graph.Graph.augment_cycle" href="#coinor.gimpy.graph.Graph.augment_cycle">augment_cycle</a></code></li>
<li><code><a title="coinor.gimpy.graph.Graph.bfs" href="#coinor.gimpy.graph.Graph.bfs">bfs</a></code></li>
<li><code><a title="coinor.gimpy.graph.Graph.check_edge" href="#coinor.gimpy.graph.Graph.check_edge">check_edge</a></code></li>
<li><code><a title="coinor.gimpy.graph.Graph.create" href="#coinor.gimpy.graph.Graph.create">create</a></code></li>
<li><code><a title="coinor.gimpy.graph.Graph.create_cluster" href="#coinor.gimpy.graph.Graph.create_cluster">create_cluster</a></code></li>
<li><code><a title="coinor.gimpy.graph.Graph.create_residual_graph" href="#coinor.gimpy.graph.Graph.create_residual_graph">create_residual_graph</a></code></li>
<li><code><a title="coinor.gimpy.graph.Graph.cycle_canceling" href="#coinor.gimpy.graph.Graph.cycle_canceling">cycle_canceling</a></code></li>
<li><code><a title="coinor.gimpy.graph.Graph.del_edge" href="#coinor.gimpy.graph.Graph.del_edge">del_edge</a></code></li>
<li><code><a title="coinor.gimpy.graph.Graph.del_node" href="#coinor.gimpy.graph.Graph.del_node">del_node</a></code></li>
<li><code><a title="coinor.gimpy.graph.Graph.dfs" href="#coinor.gimpy.graph.Graph.dfs">dfs</a></code></li>
<li><code><a title="coinor.gimpy.graph.Graph.display" href="#coinor.gimpy.graph.Graph.display">display</a></code></li>
<li><code><a title="coinor.gimpy.graph.Graph.edge_to_string" href="#coinor.gimpy.graph.Graph.edge_to_string">edge_to_string</a></code></li>
<li><code><a title="coinor.gimpy.graph.Graph.fifo_label_correcting" href="#coinor.gimpy.graph.Graph.fifo_label_correcting">fifo_label_correcting</a></code></li>
<li><code><a title="coinor.gimpy.graph.Graph.find_cycle_capacity" href="#coinor.gimpy.graph.Graph.find_cycle_capacity">find_cycle_capacity</a></code></li>
<li><code><a title="coinor.gimpy.graph.Graph.find_feasible_flow" href="#coinor.gimpy.graph.Graph.find_feasible_flow">find_feasible_flow</a></code></li>
<li><code><a title="coinor.gimpy.graph.Graph.floyd_warshall" href="#coinor.gimpy.graph.Graph.floyd_warshall">floyd_warshall</a></code></li>
<li><code><a title="coinor.gimpy.graph.Graph.floyd_warshall_get_cycle" href="#coinor.gimpy.graph.Graph.floyd_warshall_get_cycle">floyd_warshall_get_cycle</a></code></li>
<li><code><a title="coinor.gimpy.graph.Graph.floyd_warshall_get_path" href="#coinor.gimpy.graph.Graph.floyd_warshall_get_path">floyd_warshall_get_path</a></code></li>
<li><code><a title="coinor.gimpy.graph.Graph.get_degrees" href="#coinor.gimpy.graph.Graph.get_degrees">get_degrees</a></code></li>
<li><code><a title="coinor.gimpy.graph.Graph.get_diameter" href="#coinor.gimpy.graph.Graph.get_diameter">get_diameter</a></code></li>
<li><code><a title="coinor.gimpy.graph.Graph.get_edge_attr" href="#coinor.gimpy.graph.Graph.get_edge_attr">get_edge_attr</a></code></li>
<li><code><a title="coinor.gimpy.graph.Graph.get_edge_cost" href="#coinor.gimpy.graph.Graph.get_edge_cost">get_edge_cost</a></code></li>
<li><code><a title="coinor.gimpy.graph.Graph.get_edge_list" href="#coinor.gimpy.graph.Graph.get_edge_list">get_edge_list</a></code></li>
<li><code><a title="coinor.gimpy.graph.Graph.get_edge_num" href="#coinor.gimpy.graph.Graph.get_edge_num">get_edge_num</a></code></li>
<li><code><a title="coinor.gimpy.graph.Graph.get_in_degrees" href="#coinor.gimpy.graph.Graph.get_in_degrees">get_in_degrees</a></code></li>
<li><code><a title="coinor.gimpy.graph.Graph.get_in_neighbors" href="#coinor.gimpy.graph.Graph.get_in_neighbors">get_in_neighbors</a></code></li>
<li><code><a title="coinor.gimpy.graph.Graph.get_layout" href="#coinor.gimpy.graph.Graph.get_layout">get_layout</a></code></li>
<li><code><a title="coinor.gimpy.graph.Graph.get_negative_cycle" href="#coinor.gimpy.graph.Graph.get_negative_cycle">get_negative_cycle</a></code></li>
<li><code><a title="coinor.gimpy.graph.Graph.get_neighbors" href="#coinor.gimpy.graph.Graph.get_neighbors">get_neighbors</a></code></li>
<li><code><a title="coinor.gimpy.graph.Graph.get_node" href="#coinor.gimpy.graph.Graph.get_node">get_node</a></code></li>
<li><code><a title="coinor.gimpy.graph.Graph.get_node_attr" href="#coinor.gimpy.graph.Graph.get_node_attr">get_node_attr</a></code></li>
<li><code><a title="coinor.gimpy.graph.Graph.get_node_list" href="#coinor.gimpy.graph.Graph.get_node_list">get_node_list</a></code></li>
<li><code><a title="coinor.gimpy.graph.Graph.get_node_num" href="#coinor.gimpy.graph.Graph.get_node_num">get_node_num</a></code></li>
<li><code><a title="coinor.gimpy.graph.Graph.get_out_degrees" href="#coinor.gimpy.graph.Graph.get_out_degrees">get_out_degrees</a></code></li>
<li><code><a title="coinor.gimpy.graph.Graph.get_out_neighbors" href="#coinor.gimpy.graph.Graph.get_out_neighbors">get_out_neighbors</a></code></li>
<li><code><a title="coinor.gimpy.graph.Graph.get_simplex_solution_graph" href="#coinor.gimpy.graph.Graph.get_simplex_solution_graph">get_simplex_solution_graph</a></code></li>
<li><code><a title="coinor.gimpy.graph.Graph.label_components" href="#coinor.gimpy.graph.Graph.label_components">label_components</a></code></li>
<li><code><a title="coinor.gimpy.graph.Graph.label_correcting_check_cycle" href="#coinor.gimpy.graph.Graph.label_correcting_check_cycle">label_correcting_check_cycle</a></code></li>
<li><code><a title="coinor.gimpy.graph.Graph.label_correcting_get_cycle" href="#coinor.gimpy.graph.Graph.label_correcting_get_cycle">label_correcting_get_cycle</a></code></li>
<li><code><a title="coinor.gimpy.graph.Graph.label_strong_component" href="#coinor.gimpy.graph.Graph.label_strong_component">label_strong_component</a></code></li>
<li><code><a title="coinor.gimpy.graph.Graph.max_flow" href="#coinor.gimpy.graph.Graph.max_flow">max_flow</a></code></li>
<li><code><a title="coinor.gimpy.graph.Graph.max_flow_preflowpush" href="#coinor.gimpy.graph.Graph.max_flow_preflowpush">max_flow_preflowpush</a></code></li>
<li><code><a title="coinor.gimpy.graph.Graph.min_cost_flow" href="#coinor.gimpy.graph.Graph.min_cost_flow">min_cost_flow</a></code></li>
<li><code><a title="coinor.gimpy.graph.Graph.minimum_spanning_tree_kruskal" href="#coinor.gimpy.graph.Graph.minimum_spanning_tree_kruskal">minimum_spanning_tree_kruskal</a></code></li>
<li><code><a title="coinor.gimpy.graph.Graph.minimum_spanning_tree_prim" href="#coinor.gimpy.graph.Graph.minimum_spanning_tree_prim">minimum_spanning_tree_prim</a></code></li>
<li><code><a title="coinor.gimpy.graph.Graph.network_simplex" href="#coinor.gimpy.graph.Graph.network_simplex">network_simplex</a></code></li>
<li><code><a title="coinor.gimpy.graph.Graph.page_rank" href="#coinor.gimpy.graph.Graph.page_rank">page_rank</a></code></li>
<li><code><a title="coinor.gimpy.graph.Graph.print_flow" href="#coinor.gimpy.graph.Graph.print_flow">print_flow</a></code></li>
<li><code><a title="coinor.gimpy.graph.Graph.process_edge_dijkstra" href="#coinor.gimpy.graph.Graph.process_edge_dijkstra">process_edge_dijkstra</a></code></li>
<li><code><a title="coinor.gimpy.graph.Graph.process_edge_flow" href="#coinor.gimpy.graph.Graph.process_edge_flow">process_edge_flow</a></code></li>
<li><code><a title="coinor.gimpy.graph.Graph.process_edge_prim" href="#coinor.gimpy.graph.Graph.process_edge_prim">process_edge_prim</a></code></li>
<li><code><a title="coinor.gimpy.graph.Graph.process_edge_search" href="#coinor.gimpy.graph.Graph.process_edge_search">process_edge_search</a></code></li>
<li><code><a title="coinor.gimpy.graph.Graph.process_node_search" href="#coinor.gimpy.graph.Graph.process_node_search">process_node_search</a></code></li>
<li><code><a title="coinor.gimpy.graph.Graph.random" href="#coinor.gimpy.graph.Graph.random">random</a></code></li>
<li><code><a title="coinor.gimpy.graph.Graph.relabel" href="#coinor.gimpy.graph.Graph.relabel">relabel</a></code></li>
<li><code><a title="coinor.gimpy.graph.Graph.search" href="#coinor.gimpy.graph.Graph.search">search</a></code></li>
<li><code><a title="coinor.gimpy.graph.Graph.set_display_mode" href="#coinor.gimpy.graph.Graph.set_display_mode">set_display_mode</a></code></li>
<li><code><a title="coinor.gimpy.graph.Graph.set_edge_attr" href="#coinor.gimpy.graph.Graph.set_edge_attr">set_edge_attr</a></code></li>
<li><code><a title="coinor.gimpy.graph.Graph.set_layout" href="#coinor.gimpy.graph.Graph.set_layout">set_layout</a></code></li>
<li><code><a title="coinor.gimpy.graph.Graph.set_node_attr" href="#coinor.gimpy.graph.Graph.set_node_attr">set_node_attr</a></code></li>
<li><code><a title="coinor.gimpy.graph.Graph.show_flow" href="#coinor.gimpy.graph.Graph.show_flow">show_flow</a></code></li>
<li><code><a title="coinor.gimpy.graph.Graph.simplex_augment_cycle" href="#coinor.gimpy.graph.Graph.simplex_augment_cycle">simplex_augment_cycle</a></code></li>
<li><code><a title="coinor.gimpy.graph.Graph.simplex_compute_potentials" href="#coinor.gimpy.graph.Graph.simplex_compute_potentials">simplex_compute_potentials</a></code></li>
<li><code><a title="coinor.gimpy.graph.Graph.simplex_connect" href="#coinor.gimpy.graph.Graph.simplex_connect">simplex_connect</a></code></li>
<li><code><a title="coinor.gimpy.graph.Graph.simplex_determine_leaving_arc" href="#coinor.gimpy.graph.Graph.simplex_determine_leaving_arc">simplex_determine_leaving_arc</a></code></li>
<li><code><a title="coinor.gimpy.graph.Graph.simplex_find_cycle" href="#coinor.gimpy.graph.Graph.simplex_find_cycle">simplex_find_cycle</a></code></li>
<li><code><a title="coinor.gimpy.graph.Graph.simplex_find_tree" href="#coinor.gimpy.graph.Graph.simplex_find_tree">simplex_find_tree</a></code></li>
<li><code><a title="coinor.gimpy.graph.Graph.simplex_identify_cycle" href="#coinor.gimpy.graph.Graph.simplex_identify_cycle">simplex_identify_cycle</a></code></li>
<li><code><a title="coinor.gimpy.graph.Graph.simplex_mark_entering_arc" href="#coinor.gimpy.graph.Graph.simplex_mark_entering_arc">simplex_mark_entering_arc</a></code></li>
<li><code><a title="coinor.gimpy.graph.Graph.simplex_mark_leaving_arc" href="#coinor.gimpy.graph.Graph.simplex_mark_leaving_arc">simplex_mark_leaving_arc</a></code></li>
<li><code><a title="coinor.gimpy.graph.Graph.simplex_mark_st_arcs" href="#coinor.gimpy.graph.Graph.simplex_mark_st_arcs">simplex_mark_st_arcs</a></code></li>
<li><code><a title="coinor.gimpy.graph.Graph.simplex_optimal" href="#coinor.gimpy.graph.Graph.simplex_optimal">simplex_optimal</a></code></li>
<li><code><a title="coinor.gimpy.graph.Graph.simplex_redraw" href="#coinor.gimpy.graph.Graph.simplex_redraw">simplex_redraw</a></code></li>
<li><code><a title="coinor.gimpy.graph.Graph.simplex_remove_arc" href="#coinor.gimpy.graph.Graph.simplex_remove_arc">simplex_remove_arc</a></code></li>
<li><code><a title="coinor.gimpy.graph.Graph.simplex_search" href="#coinor.gimpy.graph.Graph.simplex_search">simplex_search</a></code></li>
<li><code><a title="coinor.gimpy.graph.Graph.simplex_select_entering_arc" href="#coinor.gimpy.graph.Graph.simplex_select_entering_arc">simplex_select_entering_arc</a></code></li>
<li><code><a title="coinor.gimpy.graph.Graph.strong_connect" href="#coinor.gimpy.graph.Graph.strong_connect">strong_connect</a></code></li>
<li><code><a title="coinor.gimpy.graph.Graph.tarjan" href="#coinor.gimpy.graph.Graph.tarjan">tarjan</a></code></li>
<li><code><a title="coinor.gimpy.graph.Graph.to_string" href="#coinor.gimpy.graph.Graph.to_string">to_string</a></code></li>
<li><code><a title="coinor.gimpy.graph.Graph.write" href="#coinor.gimpy.graph.Graph.write">write</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="coinor.gimpy.graph.Node" href="#coinor.gimpy.graph.Node">Node</a></code></h4>
<ul class="">
<li><code><a title="coinor.gimpy.graph.Node.get_attr" href="#coinor.gimpy.graph.Node.get_attr">get_attr</a></code></li>
<li><code><a title="coinor.gimpy.graph.Node.set_attr" href="#coinor.gimpy.graph.Node.set_attr">set_attr</a></code></li>
<li><code><a title="coinor.gimpy.graph.Node.to_string" href="#coinor.gimpy.graph.Node.to_string">to_string</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc"><cite>pdoc</cite> 0.9.2</a>.</p>
</footer>
</body>
</html>